<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mybatis on 飞狐的部落格</title>
    <link>http://lucumt.info/categories/mybatis/</link>
    <description>Recent content in Mybatis on 飞狐的部落格</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 18 Dec 2017 18:33:14 +0800</lastBuildDate>
    <atom:link href="http://lucumt.info/categories/mybatis/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>在不同版本的MyBatis中通过Log4j打印实际执行的SQL</title>
      <link>http://lucumt.info/posts/print-sql-in-different-mybatis-version/</link>
      <pubDate>Mon, 18 Dec 2017 18:33:14 +0800</pubDate>
      
      <guid>http://lucumt.info/posts/print-sql-in-different-mybatis-version/</guid>
      <description>

&lt;p&gt;项目中ORM框架用的是 &lt;strong&gt;&lt;a href=&#34;http://www.mybatis.org/mybatis-3/&#34;&gt;MyBatis&lt;/a&gt;&lt;/strong&gt;，最近由于业务上的需求将 &lt;em&gt;MyBatis&lt;/em&gt; 从3.1.1升级到3.4.5，发现升级后通过 &lt;strong&gt;&lt;a href=&#34;https://logging.apache.org/log4j/1.2/download.html&#34;&gt;Log4j&lt;/a&gt;&lt;/strong&gt; 显示SQL的配置方式发生了变化，由于变化较大，故先记录下。&lt;/p&gt;

&lt;p&gt;假设我们测试的sql文件为 &lt;em&gt;UserMapper.xml&lt;/em&gt; ， 对应的代码如下，其命名空间为 &lt;em&gt;com.lucumt.mapper.UserMappper&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot; &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;

&amp;lt;mapper namespace=&amp;quot;com.lucumt.mapper.UserMappper&amp;quot;&amp;gt;
    &amp;lt;select id=&amp;quot;getUsers&amp;quot; parameterType=&amp;quot;String&amp;quot; resultType=&amp;quot;com.lucumt.model.UserModel&amp;quot;&amp;gt;
        SELECT id,username,password,create_time AS createTime FROM system_users WHERE username!=#{username}
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应的执行代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testMybatis(){
    String resource = &amp;quot;mybatis-config.xml&amp;quot;;
    InputStream is = AppTest.class.getClassLoader().getResourceAsStream(resource);
    SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is);
    
    SqlSession session = sessionFactory.openSession();
    String statement = &amp;quot;com.lucumt.mapper.UserMappper.getUsers&amp;quot;;
    List&amp;lt;UserModel&amp;gt; userList = session.selectList(statement, &amp;quot;admin&amp;quot;);
    for(UserModel u:userList){
    	System.out.println(u.toString());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本文会基于上述代码说明不同版本下如何利用 &lt;em&gt;Log4j&lt;/em&gt; 在 &lt;em&gt;MyBatis&lt;/em&gt; 中配置打印日志以及其实现原理。&lt;/p&gt;

&lt;h2 id=&#34;mybatis3-1-1显示sql的配置与分析:7eadf44b310a8365cd3dc766a1e45c58&#34;&gt;MyBatis3.1.1显示SQL的配置与分析&lt;/h2&gt;

&lt;h3 id=&#34;log4j相关配置:7eadf44b310a8365cd3dc766a1e45c58&#34;&gt;Log4j相关配置&lt;/h3&gt;

&lt;p&gt;在 &lt;em&gt;MyBatis3.1.1&lt;/em&gt; 及以前的版本中若我们想通过 &lt;em&gt;Log4j&lt;/em&gt; 配置来打印实际执行的SQL，&lt;em&gt;log4j.properties&lt;/em&gt; 的配置通常类似如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#在不开启log4j DEBUG模式下显示mybatis中运行的SQL语句 
log4j.logger.java.sql.Connection=DEBUG 
log4j.logger.java.sql.Statement=DEBUG 
log4j.logger.java.sql.PreparedStatement=DEBUG 
log4j.logger.java.sql.ResultSet=DEBUG 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;原理分析:7eadf44b310a8365cd3dc766a1e45c58&#34;&gt;原理分析&lt;/h3&gt;

&lt;p&gt;以 &lt;em&gt;log4j.logger.java.sql.Connection=DEBUG&lt;/em&gt;  这个配置为例，分析源码可知其sql日志来源于&lt;code&gt;ConnectionLogger&lt;/code&gt;，查看 &lt;em&gt;ConnectionLogger&lt;/em&gt; 的代码可知，&lt;em&gt;ConnectionLogger&lt;/em&gt; 以硬编码的方式生成了一个log对象,当 &lt;em&gt;DEBUG&lt;/em&gt; 模式开启时该log对象会打印sql语句等信息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class ConnectionLogger extends BaseJdbcLogger implements InvocationHandler {

  //生成一个Connection的log
  private static final Log log = LogFactory.getLog(Connection.class);

  private Connection connection;

  private ConnectionLogger(Connection conn, Log statementLog) {
    super(statementLog);
    this.connection = conn;
    if (isDebugEnabled()) {
      debug(&amp;quot;ooo Using Connection [&amp;quot; + conn + &amp;quot;]&amp;quot;);
    }
  }

  public Object invoke(Object proxy, Method method, Object[] params)
      throws Throwable {
    try {
      if (&amp;quot;prepareStatement&amp;quot;.equals(method.getName())) {
        if (isDebugEnabled()) {//打印执行的SQL语句
          debug(&amp;quot;==&amp;gt;  Preparing: &amp;quot; + removeBreakingWhitespace((String) params[0]));
        }        
        PreparedStatement stmt = (PreparedStatement) method.invoke(connection, params);
        stmt = PreparedStatementLogger.newInstance(stmt, getStatementLog());
        return stmt;
      }
      //... other code
    } catch (Throwable t) {
      throw ExceptionUtil.unwrapThrowable(t);
    }
  }

  //... other code

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果如下&lt;br /&gt;
&lt;img src=&#34;http://lucumt.info/blog_img/print-sql-in-different-mybatis-version/mybatis-3.1.1-print-sql-result.png&#34; alt=&#34;&amp;quot;MyBatis3.1.1时显示执行SQL&amp;quot;&#34; title=&#34;MyBatis1.1.1时显示执行SQL&#34; /&gt;
&lt;br /&gt;
从上述代码可知在 &lt;em&gt;Mybatis3.1.1&lt;/em&gt; 中通过 &lt;em&gt;Log4j&lt;/em&gt; 实现打印执行SQL的操作很简单，实现原理也易懂，但其存在的一个缺点: &lt;strong&gt;当开启打印SQL日志后，会打印所有正在执行的SQL语句，不能实现针对特定SQL的打印&lt;/strong&gt; ，基于此 &lt;em&gt;MyBatis&lt;/em&gt; 从3.2.0版本之后重新实现了相关功能。&lt;/p&gt;

&lt;h2 id=&#34;mybatis3-4-5显示sql的配置与分析:7eadf44b310a8365cd3dc766a1e45c58&#34;&gt;MyBatis3.4.5显示SQL的配置与分析&lt;/h2&gt;

&lt;h3 id=&#34;log4j相关配置-1:7eadf44b310a8365cd3dc766a1e45c58&#34;&gt;Log4j相关配置&lt;/h3&gt;

&lt;p&gt;在 &lt;em&gt;MyBatis3.2.0&lt;/em&gt; 及以后的版本中若我们想通过Log4j配置来打印实际执行的SQL，&lt;em&gt;log4j.properties&lt;/em&gt; 的配置通常类似如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#在不开启log4j DEBUG模式下显示mybatis中运行的SQL语句 
log4j.logger.com.lucumt.mapper=DEBUG 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在本文写作时，mybatis官网上已有关于这方面更 &lt;strong&gt;&lt;a href=&#34;http://www.mybatis.org/mybatis-3/zh/logging.html&#34;&gt;详细的说明&lt;/a&gt;&lt;/strong&gt; 。&lt;/p&gt;

&lt;h3 id=&#34;原理分析-1:7eadf44b310a8365cd3dc766a1e45c58&#34;&gt;原理分析&lt;/h3&gt;

&lt;p&gt;同样以 &lt;em&gt;log4j.logger.java.sql.Connection=DEBUG&lt;/em&gt; 为例，其sql日志来源于 &lt;em&gt;ConnectionLogger&lt;/em&gt; ，对应代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class ConnectionLogger extends BaseJdbcLogger implements InvocationHandler {

  private final Connection connection;

  //通过注入的方式生成log对象
  private ConnectionLogger(Connection conn, Log statementLog, int queryStack) {
    super(statementLog, queryStack);
    this.connection = conn;
  }

  @Override
  public Object invoke(Object proxy, Method method, Object[] params)
      throws Throwable {
    try {
      if (Object.class.equals(method.getDeclaringClass())) {
        return method.invoke(this, params);
      }    
      if (&amp;quot;prepareStatement&amp;quot;.equals(method.getName())) {
        if (isDebugEnabled()) {
          debug(&amp;quot; Preparing: &amp;quot; + removeBreakingWhitespace((String) params[0]), true);
        }        
      }
      //... other code
    } catch (Throwable t) {
      throw ExceptionUtil.unwrapThrowable(t);
    }
  }

  //... other code

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上述代码可知，其日志生成是调用&lt;code&gt;BaseJdbcLogger&lt;/code&gt;的构造方法生成的，&lt;em&gt;BaseJdbcLogger&lt;/em&gt; 代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public abstract class BaseJdbcLogger {

  protected Log statementLog;
  protected int queryStack;


  public BaseJdbcLogger(Log log, int queryStack) {
    this.statementLog = log;
    if (queryStack == 0) {
      this.queryStack = 1;
    } else {
      this.queryStack = queryStack;
    }
  }
   
  //... other code
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DEBUG模式下查看 &lt;em&gt;ConnectionLogger&lt;/em&gt; 的调用堆栈如下&lt;br /&gt;
&lt;img src=&#34;http://lucumt.info/blog_img/print-sql-in-different-mybatis-version/connection_logger_stack.png&#34; alt=&#34;&amp;quot;ConnectionLogger的调用堆栈&amp;quot;&#34; title=&#34;ConnectionLogger的调用堆栈&#34; /&gt;
&lt;br /&gt;
从其调用堆栈可知log对象是通过&lt;code&gt;MappedStatement&lt;/code&gt;生成的，如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SimpleExecutor extends BaseExecutor {
   
  //... other code

  @Override
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; doQuery(MappedStatement ms,Object parameter,
                  RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
    Statement stmt = null;
    try {
      Configuration configuration = ms.getConfiguration();
      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
      //log对象通过MappedStatement生成
      stmt = prepareStatement(handler, ms.getStatementLog());
      return handler.&amp;lt;E&amp;gt;query(stmt, resultHandler);
    } finally {
      closeStatement(stmt);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看 &lt;em&gt;MappedStatement&lt;/em&gt; 的源码，发现log的生成是在 &lt;em&gt;Builder&lt;/em&gt; 方法中，如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class MappedStatement {

  public static class Builder {
    private MappedStatement mappedStatement = new MappedStatement();

    public Builder(Configuration configuration, String id, SqlSource sqlSource, SqlCommandType sqlCommandType) {
      mappedStatement.configuration = configuration;
      mappedStatement.id = id;
      mappedStatement.sqlSource = sqlSource;
      mappedStatement.statementType = StatementType.PREPARED;
      mappedStatement.parameterMap = new ParameterMap.Builder(configuration, &amp;quot;defaultParameterMap&amp;quot;, null, new ArrayList&amp;lt;ParameterMapping&amp;gt;()).build();
      mappedStatement.resultMaps = new ArrayList&amp;lt;ResultMap&amp;gt;();
      mappedStatement.sqlCommandType = sqlCommandType;
      mappedStatement.keyGenerator = configuration.isUseGeneratedKeys() &amp;amp;&amp;amp; SqlCommandType.INSERT.equals(sqlCommandType) ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;
      String logId = id;
      //可以通过设置logPrefix的方法来生成log对象
      if (configuration.getLogPrefix() != null) {
        logId = configuration.getLogPrefix() + id;
      }
      //通过logId生成log对象
      mappedStatement.statementLog = LogFactory.getLog(logId);
      mappedStatement.lang = configuration.getDefaultScriptingLanguageInstance();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过上面的代码可知log对象是由logId生成的，进一步debug发现logId是由 &lt;strong&gt;namespace+方法id&lt;/strong&gt; 组成，在本例中为 &lt;em&gt;com.lucumt.mapper.UserMappper.getUsers&lt;/em&gt; ，而前面的配置为 &lt;em&gt;log4j.logger.com.lucumt.mapper=DEBUG&lt;/em&gt; ，由于 &lt;em&gt;Log4j&lt;/em&gt; 中的log示例的继承关系，相当于 &lt;em&gt;com.lucumt.mapper.UserMappper.getUser&lt;/em&gt; 也开启了DEBUG模式，故在实际执行时可以显示打印SQL语句，运行结果如下&lt;br /&gt;
&lt;img src=&#34;http://lucumt.info/blog_img/print-sql-in-different-mybatis-version/mybatis-3.4.5-print-sql-result.png&#34; alt=&#34;&amp;quot;MyBatis3.4.5时显示执行SQL&amp;quot;&#34; title=&#34;MyBatis3.4.5时显示执行SQL&#34; /&gt;
&lt;br /&gt;
利用新版 &lt;em&gt;MyBatis&lt;/em&gt; 的这一特性，我们可以实现类似如下的不同粒度sql打印&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;log4j.logger.com.xxx.mapper=DEBUG #打印xxx包下所有的执行SQL
log4j.logger.com.yyy.mapper.PersonMapper=DEBUG #打印PersonMapper下所有的执行SQL
log4j.logger.com.zzz.mapper.GroupMapper.getGroups=DEBUG #只打印getGroups对应的执行SQL  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
由前面的代码可知 &lt;em&gt;MappedStatement&lt;/em&gt; 的 &lt;em&gt;Build&lt;/em&gt; 方法在生成log对象时会检测是否有 &lt;em&gt;logPrefix&lt;/em&gt; 配置，若有则用 &lt;em&gt;logPrefix&lt;/em&gt; 来生成log对象，于是可以通过设置 &lt;em&gt;logPrefix&lt;/em&gt; 以另外一种方式配置打印sql。 可在 &lt;em&gt;MyBatis&lt;/em&gt; 配置文件中添加如下配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;settings&amp;gt;
   &amp;lt;setting name=&amp;quot;logPrefix&amp;quot; value=&amp;quot;dao.&amp;quot;/&amp;gt; &amp;lt;!-- 设置前缀为dao --&amp;gt;
   &amp;lt;setting name=&amp;quot;logImpl&amp;quot; value=&amp;quot;log4j&amp;quot;/&amp;gt; &amp;lt;!-- 设置使用log4j为日志实现类 --&amp;gt;
&amp;lt;/settings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后将 &lt;em&gt;log4j.properties&lt;/em&gt; 的配置修改为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;log4j.logger.dao=DEBUG
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果与前面相同，通过 &lt;em&gt;logPrefix&lt;/em&gt; 可以在有些时候简化sql打印配置。&lt;/p&gt;

&lt;h3 id=&#34;待分析问题:7eadf44b310a8365cd3dc766a1e45c58&#34;&gt;待分析问题&lt;/h3&gt;

&lt;p&gt;若将 &lt;em&gt;MyBatis&lt;/em&gt; 的版本变 &lt;em&gt;3.3.0&lt;/em&gt; 时，通过 &lt;em&gt;Log4j&lt;/em&gt; 配置打印SQL时，如下所示的配置方式只有部分生效，原因待分析&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;log4j.logger.com.xxx=DEBUG #可以打印SQL
log4j.logger.com.xxx.mapper=DEBUG #可以打印SQL
log4j.logger.com.xxx.mapper.UserMapper=DEBUG #不能打印SQL
log4j.logger.com.xxx.mapper.UserMapper.getUsers=DEBUG #不能打印SQL
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>mybatis batch insert exception的解决方法</title>
      <link>http://lucumt.info/posts/mybatis-batch-insert-exception/</link>
      <pubDate>Mon, 30 May 2016 18:20:37 +0800</pubDate>
      
      <guid>http://lucumt.info/posts/mybatis-batch-insert-exception/</guid>
      <description>&lt;p&gt;在利用 &lt;strong&gt;&lt;a href=&#34;http://www.mybatis.org/mybatis-3/&#34;&gt;MyBatis&lt;/a&gt;&lt;/strong&gt; 进行多条数据插入时，为了提高性能我们可能会使用批量插入的功能来实现。示例代码如下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SQL配置文件:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;insert id=&amp;quot;addAuthorityRoleBatch&amp;quot; parameterType=&amp;quot;List&amp;quot;&amp;gt;
    INSERT INTO system_authority_role(role_id,authority_id)
      VALUES
      &amp;lt;foreach collection=&amp;quot;list&amp;quot; item=&amp;quot;authRole&amp;quot; separator=&amp;quot;,&amp;quot;&amp;gt;
        (#{authRole.roleId},#{authRole.authorityId})
      &amp;lt;/foreach&amp;gt;
  &amp;lt;/insert&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public void adjustRoleAuth(String roleId, String authIdsStr) {
        authRoleDao.deleteAuthorityRoleByRole(roleId);
        String[] authIds=authIdsStr.split(&amp;quot;;&amp;quot;);
        List&amp;lt;AuthorityRoleModel&amp;gt; authRoleList=new ArrayList&amp;lt;AuthorityRoleModel&amp;gt;();
        for(String authId:authIds){
            authRoleList.add(new AuthorityRoleModel(roleId,authId));
        }
        authRoleDao.addAuthorityRoleBatch(authRoleList);
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面的代码大多数时候可以正常运行，但是偶尔会出现如下异常：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;### SQL: INSERT INTO system_authority_role(role_id,authority_id)       VALUES
### Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39; at line 2
; bad SQL grammar []; nested exception is com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39; at line 2
at org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator.doTranslate(SQLErrorCodeSQLExceptionTranslator.java:233
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的异常堆栈信息显示现在执行的MySQL语句发生了语法错误，INSERT VALUE后面的值为空，由于该问题有时候发生，有时候不发生，给我们分析该问题造成了一定的困扰。&lt;strong&gt;该问题产生的根源为批量插入时的集合数据为空，使得SQL配置文件中的foreach循环没有执行，从而导致SQL语句不完整，进而产生该异常。&lt;/strong&gt;为了解决该问题我们可以批量插入之前先检查List数据集合是否为空，只有在不为空的情况下才进行插入，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void adjustRoleAuth(String roleId, String authIdsStr) {
    authRoleDao.deleteAuthorityRoleByRole(roleId);
    String[] authIds=authIdsStr.split(&amp;quot;;&amp;quot;);
    List&amp;lt;AuthorityRoleModel&amp;gt; authRoleList=new ArrayList&amp;lt;AuthorityRoleModel&amp;gt;();
    for(String authId:authIds){
        authRoleList.add(new AuthorityRoleModel(roleId,authId));
    }
    if(authRoleList.size()&amp;gt;0){//只有在List不为空时才进行插入
        authRoleDao.addAuthorityRoleBatch(authRoleList);        
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>