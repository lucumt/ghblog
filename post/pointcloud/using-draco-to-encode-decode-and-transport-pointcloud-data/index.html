<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>利用Draco对点云数据进行编码解码以实现高效网络传输 - 飞狐的部落格</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Rosen Lu" /><meta name="description" content="基于自己项目中的经验，介绍如何利用Google Draco对点云数据编码与解码，以便缩小点云数据体积实现高效的网络传输" /><meta name="keywords" content="点云,three.js,draco,编码,解码,网络传输" />
<meta name="generator" content="Hugo0.126.1with theme even" />


<link rel="canonical" href="https://lucumt.info/post/pointcloud/using-draco-to-encode-decode-and-transport-pointcloud-data/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link href="/sass/main.min.f8a15eb0c012e3545d8b6ed47dcb94694059de6131ffb16c8bf6a65b3af1bf61.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet"><meta property="og:url" content="https://lucumt.info/post/pointcloud/using-draco-to-encode-decode-and-transport-pointcloud-data/">
  <meta property="og:site_name" content="飞狐的部落格">
  <meta property="og:title" content="利用Draco对点云数据进行编码解码以实现高效网络传输">
  <meta property="og:description" content="基于自己项目中的经验，介绍如何利用Google Draco对点云数据编码与解码，以便缩小点云数据体积实现高效的网络传输">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2025-02-26T10:20:20+08:00">
    <meta property="article:modified_time" content="2025-02-26T10:20:20+08:00">
    <meta property="article:tag" content="Pointcloud">
    <meta property="article:tag" content="Draco">

  <meta itemprop="name" content="利用Draco对点云数据进行编码解码以实现高效网络传输">
  <meta itemprop="description" content="基于自己项目中的经验，介绍如何利用Google Draco对点云数据编码与解码，以便缩小点云数据体积实现高效的网络传输">
  <meta itemprop="datePublished" content="2025-02-26T10:20:20+08:00">
  <meta itemprop="dateModified" content="2025-02-26T10:20:20+08:00">
  <meta itemprop="wordCount" content="5347">
  <meta itemprop="keywords" content="点云,three.js,draco,编码,解码,网络传输">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="利用Draco对点云数据进行编码解码以实现高效网络传输">
  <meta name="twitter:description" content="基于自己项目中的经验，介绍如何利用Google Draco对点云数据编码与解码，以便缩小点云数据体积实现高效的网络传输">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link href="/lib/prism-1.29.0/themes/prism-solarizedlight.min.css" rel="stylesheet">
<link href="/lib/prism-1.29.0/plugins/line-highlight/prism-line-highlight.min.css" rel="stylesheet">
<link href="/lib/prism-1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">
</head>
<body>
	  
	  <a href="https://github.com/lucumt/ghblog" title="https://github.com/lucumt/ghblog" target="_blank">  
	  <img style="position: fixed; top: 0; right: 0; border: 0; z-index:9999;" 
		 src="/blog_img/forkme_right_gray.png" 
		 alt="Fork me on GitHub">
	  </a><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Rosen&#39;s World</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于我</li>
      </a><a href="https://tech.lucumt.info">
        <li class="mobile-menu-item">外链</li>
      </a><a href="/search/">
        <li class="mobile-menu-item">搜索</li>
      </a>
  </ul>

  


</nav>
<div class="container" id="mobile-panel"><header id="header" class="header"><div class="logo-wrapper">
  <a href="/" class="logo">Rosen&#39;s World</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于我</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="https://tech.lucumt.info">外链</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/search/">搜索</a>
      </li>
  </ul>
</nav>

    </header><main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">利用Draco对点云数据进行编码解码以实现高效网络传输</h1>

      <div class="post-meta">
        <span class="post-time"> 2025-02-26 </span>
        <div class="post-category">
            <a href="/categories/web%E7%BC%96%E7%A8%8B/"> web编程 </a>
            </div>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次阅读 </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#背景">背景</a></li>
        <li><a href="#整合draco">整合Draco</a></li>
        <li><a href="#使用说明">使用说明</a></li>
        <li><a href="#点云编码">点云编码</a></li>
        <li><a href="#点云解码">点云解码</a></li>
        <li><a href="#脚本转换">脚本转换</a></li>
        <li><a href="#精确度问题">精确度问题</a>
          <ul>
            <li><a href="#float对比">Float对比</a></li>
            <li><a href="#int对比">Int对比</a></li>
            <li><a href="#高量化对比">高量化对比</a></li>
          </ul>
        </li>
        <li><a href="#显示效果对比">显示效果对比</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
	 
	  	
	
    <div class="post-content image-border">
	 <p>个人在项目中使用了<a href="https://github.com/google/draco"><strong>Draco</strong></a>对<a href="https://en.wikipedia.org/wiki/Point_cloud"><strong>点云</strong></a>数据进行编码与解码，其通过压缩点云数据以减少在网络传输过程中的数据包大小，最终加快点云帧的播放速度，同时由于网络上关于此方面的资料太少，故将其用法和个人踩过的坑简单记录下。</p>
<h2 id="背景">背景</h2>
<p>项目中某个功能模块需要将点云文件按帧进行连续播放，实现类似动画播放的效果，但实际对相关功能进行测试时发现有明显延迟，即使在公司内部网络具有<code>GPU</code>的环境进行测试也是如此<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<p><img src="/blog_img/pointcloud/using-draco-to-encode-decode-and-transport-pointcloud-data/original-point-cloud-transmit-time-cost.png" alt="原始点云文件传输耗时" title="原始点云文件传输耗时"></p>
<p>从数据截图可看出，即使在同一个区域的公司内部网络，其网络请求耗时也接近1s，而在不同区域的公司内网其耗时已经接近4s，完全不满足使用需求。</p>
<p>造成点云数据传输缓慢的原因是多方面的，如网络环境、数据包体积、服务器性能、浏览器端硬件性能等。</p>
<p>在此问题中采用排除法以及基于前述的截图可以很快的找到问题原因：<strong>网络传输太慢是由于数据包体积太大</strong>，而个人项目中数据包的体积为1.3M，远超正常的网络请求数据包大小。</p>
<p>要解决此问题也很简单，只需要有针对性的减少网络传输中的数据包大小即可，而之前项目中已经采用了常规的<a href="https://en.wikipedia.org/wiki/Gzip">gzip</a>与<a href="https://protobuf.dev/">Protocol Buffers</a>对相关请求进行了压缩处理，必须采用其它方式进一步的减少数据包体积。</p>
<p><img src="/blog_img/pointcloud/using-draco-to-encode-decode-and-transport-pointcloud-data/original-transmit-point-cloud-data.png" alt="原始点云传输方式" title="原始点云传输方式"></p>
<h2 id="整合draco">整合Draco</h2>
<p>在常规的数据压缩方式不满足要求之后，只能结合本身的业务特性进一步的寻求有针对性的压缩算法，由于项目中主要是涉及到点云数据，属于三维数据处理的范畴，一番对比后我们选择了<code>Draco</code>!</p>
<p><code>Draco</code>是<code>Google</code>官方推出专门处理3D数据的开源数据库，在其<a href="https://github.com/google/draco">官方文档</a>中有如下说明</p>
<blockquote>
<p>Draco is a library for compressing and decompressing 3D geometric <a href="https://en.wikipedia.org/wiki/Polygon_mesh">meshes</a> and <a href="https://en.wikipedia.org/wiki/Point_cloud">point clouds</a>. It is intended to improve the storage and transmission of 3D graphics.</p>
</blockquote>
<p>可看出其主要作用是通过数据压缩与解压，来提升网格和点云数据的存储与传输效率。</p>
<p>其本质上还是通过基于特定业务场景的算法对数据进行针对性的压缩，来减少其大小，数据变小后，当然能存储更多的数据，也能传输的更快！</p>
<p>在<a href="https://opensource.googleblog.com/2017/01/introducing-draco-compression-for-3d.html">这篇文章</a>中对其压缩比有直观对比展示，相对于常用的<code>zip</code>压缩，其压缩比很高，官方文档说明<strong>最高可达到1%</strong>。</p>
<p><img src="/blog_img/pointcloud/using-draco-to-encode-decode-and-transport-pointcloud-data/draco-comparing-instruction.png" alt="Draco对比说明" title="Draco对比说明"></p>
<p><code>Draco</code>主要是采用算法，将点云文件(通常是<code>ply</code>文件)或数据压缩编码为<code>drc</code>文件，此文件相对于原始的点云文件体积很小，适合网络传输，客户端接收后基于<code>Draco</code>进行解码为实际的点云数据<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>，然后进行播放。</p>
<p>相比之前的流程，整合<code>Draco</code>后的改进流程如下：</p>
<p><img src="/blog_img/pointcloud/using-draco-to-encode-decode-and-transport-pointcloud-data/draco-transmit-point-cloud-data.png" alt="Draco点云传输方式" title="Draco点云传输方式"></p>
<p>改进后的测试结果类似如下，压缩后的体积变为原来的三分之一，至于网络传输耗时则最快能缩短到100ms之内，即使在不同地域的网络进行点云传输，其耗时相对于改进前也大大缩短，基本上能满足实际生产使用要求。</p>
<p><img src="/blog_img/pointcloud/using-draco-to-encode-decode-and-transport-pointcloud-data/draco-point-cloud-transmit-time-cost.png" alt="Draco点云文件传输耗时" title="Draco点云文件传输耗时"></p>
<p>上图中采用<code>Draco</code>之后的数据压缩率相对于之前只有30%左右，与其官方宣称的最高1%的压缩率差异较大的原因如下：</p>
<ol>
<li>自己测试中采用的是4帧点云数据同时传输，数据包里面附带了一些其它信息</li>
<li>自己项目中已经对原始点云数据采用<code>gzip</code>与<code>Protocol Buffers</code>进行了前期的处理，4帧点云原始大小为12M左右</li>
<li>为了保留较高的精确度，适当调整了压缩比设置参数</li>
</ol>
<h2 id="使用说明">使用说明</h2>
<p><code>Draco</code>官方提供如下2种数据编解码操作：</p>
<ol>
<li>
<p>通过编程语言实现，当前主要是<code>C++</code>和<code>JavaScript</code>，从前面图示中可看出，在相同条件下使用<code>C++</code>进行编解码时其耗时相对于<code>JavaScript</code>耗时更短，当对性能严苛要求时，优先推荐<code>C++</code>实现。</p>
</li>
<li>
<p>通过脚本实现，主要是编译后的<code>C++</code>脚本，以命令行参数的形式执行，可结合<code>Shell</code>脚本实现批量的编码与解码</p>
<pre class="line-numbers language-bash " title="bash">
<code># 数据编码
./draco_encoder -point_cloud -i testdata/bun_zipper.ply -o out.drc

# 数据解码
./draco_decoder -i in.drc -o out.obj</code>
</pre></li>
</ol>
<p>本文主要聚焦于通过使用<code>JavaScript</code>以代码的方式对其进行相关操作。</p>
<p>网络上关于<code>Draco</code>使用的资料不是很多，自己主要参考的是<a href="https://github.com/google/draco/blob/main/javascript/npm/draco3d/draco_nodejs_example.js">draco_nodejs_example.js</a>中的相关实现，由于该示例中编解码实现都是基于网格(<code>Mesh</code>)实现，而个人项目涉及到的是点云(<code>PointCloud</code>)，故需要对其做适当的改进。</p>
<p>理论上只需要将对应方法中的<code>Mesh</code>修改为<code>PointCloud</code>即可，自己实际操作时发现此路不通，只能基于其官方提供的<a href="https://en.wikipedia.org/wiki/IDL_specification_language">IDL</a>格式的说明文件<a href="https://github.com/google/draco/blob/main/src/draco/javascript/emscripten/draco_web_encoder.idl">draco_web_encoder.idl</a>和<a href="https://github.com/google/draco/blob/main/src/draco/javascript/emscripten/draco_web_decoder.idl">draco_web_decoder.idl</a>进行修改。</p>
<p><code>IDL</code>中的描述类似如下，对于有编程基础的人而言很容易看懂。</p>
<pre class="line-numbers language-idl " title="idl">
<code>interface PointCloudBuilder {
  void PointCloudBuilder();
  long AddFloatAttribute(PointCloud pc, draco_GeometryAttribute_Type type,
                         long num_vertices, long num_components,
                         [Const] float[] att_values);
  long AddInt8Attribute(PointCloud pc, draco_GeometryAttribute_Type type,
                        long num_vertices, long num_components,
                        [Const] byte[] att_values);
  long AddUInt8Attribute(PointCloud pc, draco_GeometryAttribute_Type type,
                         long num_vertices, long num_components,
                         [Const] octet[] att_values);
                         
    // xxx
};</code>
</pre><h2 id="点云编码">点云编码</h2>
<p>基于<code>JavaScript</code>修改后的<code>Draco</code>点云编码实现如下，核心将指定的点云文件转化为指定的<code>drc</code>文件。</p>
<pre class="line-numbers language-js " title="js">
<code>&#39;use_strict&#39;;

const fs = require(&#39;fs&#39;);
const draco3d = require(&#39;draco3d&#39;);
const readline = require(&#39;readline&#39;);
const { styleText } = require(&#39;node:util&#39;);

// Global encoder module variables.
let encoderModule = null;
let fileSize = 0,
    encodedSize = 0,
    startTime = null,
    endTime = null;

draco3d.createEncoderModule({}).then(function(module) {
    encoderModule = module;
    console.log(&#39;Encoder Module Initialized!&#39;);
    if (!encoderModule) {
        return;
    }
    encodeData(process.argv[2], process.argv[3]);
});

function encodeData(srcFile, dstFile) {
    startTime = new Date();
    let data = [];
    let rl = readline.createInterface({
        input: fs.createReadStream(srcFile),
        crlfDelay: Infinity
    });

    rl.on(&#39;line&#39;, (line) =&gt; {
        data.push(line);
        const encoder = new TextEncoder();
        fileSize &#43;= Buffer.byteLength(line);
    });

    rl.on(&#39;close&#39;, () =&gt; {
        let readEndTime = new Date();
        let readTimeCost = styleText(&#39;green&#39;, `${readEndTime - startTime}`);
        console.log(&#34;Reading file of size &#34; &#43; styleText(&#39;green&#39;, `${fileSize}`) &#43; &#34; bytes for file &#34; &#43; srcFile &#43; `,time cost: ${readTimeCost}ms`);
        let points = []
        for (i in data) {
            let pdata = convertPcdToPointCloudData(data[i]);
            if (!!pdata) {
                points = [...points, ...pdata];
            }
        }
        // 计算大小时排除掉表头的声明部分
        let pointSize = styleText(&#39;green&#39;, `${data.length - 7}`);
        console.log(`point size: ${pointSize}`);
        //printPointClouds(points);
        encodePointCloudToFile(dstFile, points);
    });
}

function encodePointCloudToFile(file, data) {
    const encoder = new encoderModule.Encoder();
    const pointBuilder = new encoderModule.PointCloudBuilder();
    const pointCloud = new encoderModule.PointCloud();

    const attrs = {
        POSITION: 3
    };

    Object.keys(attrs).forEach((attr) =&gt; {

        const numValues = data.length;
        const stride = attrs[attr];
        const numPoints = numValues / stride;
        const encoderAttr = encoderModule[attr];

        const attributeDataArray = new Float32Array(numValues);
        for (let i = 0; i &lt; numValues; &#43;&#43;i) {
            attributeDataArray[i] = data[i]
        }

        pointBuilder.AddFloatAttribute(pointCloud, encoderAttr, numPoints, stride, attributeDataArray);
    });


    let encodedData = new encoderModule.DracoInt8Array();
    // Set encoding options.
    encoder.SetSpeedOptions(5, 5);
    encoder.SetAttributeQuantization(encoderModule.POSITION, 5);
    encoder.SetEncodingMethod(encoderModule.MESH_EDGEBREAKER_ENCODING);

    // Encoding.
    console.log(&#34;Encoding...&#34;);
    encodedSize = encoder.EncodePointCloudToDracoBuffer(pointCloud, false, encodedData);
    encoderModule.destroy(pointCloud);

    if (encodedSize &gt; 0) {
        console.log(&#34;Encoded size is &#34; &#43; styleText(&#39;green&#39;, `${encodedSize}`) &#43; &#34; bytes&#34;);
    } else {
        console.log(&#34;Error: Encoding failed.&#34;);
        return
    }
    // Copy encoded data to buffer.
    const outputBuffer = new ArrayBuffer(encodedSize);
    const outputData = new Int8Array(outputBuffer);
    for (let i = 0; i &lt; encodedSize; &#43;&#43;i) {
        outputData[i] = encodedData.GetValue(i);
    }
    encoderModule.destroy(encodedData);
    encoderModule.destroy(encoder);
    encoderModule.destroy(pointBuilder);
    fs.writeFile(file, Buffer.from(outputBuffer), &#34;binary&#34;,
        function(err) {
            if (err) {
                console.log(err);
            } else {
                console.log(&#34;The file &#34; &#43; file &#43; &#34; was saved!&#34;);
            }
        });
    let endTime = new Date();
    let timeCost = styleText(&#39;green&#39;, `${endTime - startTime}`);
    let rate = styleText(&#39;green&#39;, (encodedSize / fileSize * 100).toFixed(2) &#43; &#39;%&#39;);
    console.log(`Encode finished,time cost: ${timeCost}ms, compress rate: ${rate}`);
}

function convertPcdToPointCloudData(line) {
    let data = line.split(/\s/);
    if (data.length != 3) {
        return null;
    }
    for (let i = 0; i &lt; 3; i&#43;&#43;) {
        if (!isNumeric(data[i])) {
            return null;
        }
    }
    return [Number(data[0]), Number(data[1]), Number(data[2])];
}

function isNumeric(str) {
    if (typeof str != &#34;string&#34;) {
        return false;
    }
    return !isNaN(str) &amp;&amp; !isNaN(parseFloat(str));
}</code>
</pre><p>分别执行下述指令对3个不同的点云<code>ply</code>文件编码为<code>drc</code>文件</p>
<pre class="line-numbers language-bash " title="bash">
<code>node draco_encode_test.js 000000.ply 000000.drc
node draco_encode_test.js 000001.ply 000001.drc
node draco_encode_test.js 000002.ply 000002.drc</code>
</pre><p>执行结果类似如下</p>
<p><img src="/blog_img/pointcloud/using-draco-to-encode-decode-and-transport-pointcloud-data/draco-encode-results.png" alt="Draco编码结果展示" title="Draco编码结果展示"></p>
<p>基于上述操作可得出如下结论：</p>
<ol>
<li>点云数据量较小时，压缩率不高，事实上太小的数量也没必要这么折腾</li>
<li>点云文件越大，压缩耗时越高，主要耗时点在于<code>Draco</code>自身相关的操作</li>
<li>在文件大小相似时，不同内容的点云文件，其压缩率也可能不相同，但不会偏离太大</li>
<li>鱼与熊掌不可兼得，<code>Draco</code>相当于提前利用编码过程中的耗时来实现减小文件体积与缩小传输耗时，另一种时间换空间？</li>
</ol>
<h2 id="点云解码">点云解码</h2>
<p>基于<code>JavaScript</code>修改后的<code>Draco</code>点云解码实现如下</p>
<pre class="line-numbers language-js " title="js">
<code>&#39;use_strict&#39;;

const fs = require(&#39;fs&#39;);
const draco3d = require(&#39;draco3d&#39;);
const { styleText } = require(&#39;node:util&#39;);

// Global decoder module variables.
let decoderModule = null;

draco3d.createDecoderModule({}).then(function(module) {
    decoderModule = module;
    console.log(&#39;Decoder Module Initialized!&#39;);
    decodeData(process.argv[2]);
});

let startTime = null;

function decodeData(srcFile) {
    if (!decoderModule) {
        return;
    }
    startTime = new Date();
    fs.readFile(srcFile, function(err, data) {
        if (err) {
            return console.log(err);
        }
        let fileSize = styleText(&#39;green&#39;, `${data.byteLength} bytes`);
        console.log(&#34;Decoding file of size &#34; &#43; fileSize &#43; &#34; ..&#34;);
        const decoder = new decoderModule.Decoder();
        decodeDracoData(data, decoder);
    });
}

function decodeDracoData(rawBuffer, decoder) {
    const buffer = new decoderModule.DecoderBuffer();
    buffer.Init(new Float32Array(rawBuffer), rawBuffer.byteLength);
    const geometryType = decoder.GetEncodedGeometryType(buffer);

    let dracoGeometry = null;
    let status;
    if (geometryType === decoderModule.TRIANGULAR_MESH) {
        dracoGeometry = new decoderModule.Mesh();
        status = decoder.DecodeBufferToMesh(buffer, dracoGeometry);
    } else if (geometryType === decoderModule.POINT_CLOUD) {
        dracoGeometry = new decoderModule.PointCloud();
        status = decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);
    } else {
        const errorMsg = &#39;Error: Unknown geometry type.&#39;;
        console.error(errorMsg);
    }
    decoderModule.destroy(buffer);

    const attrs = {
        POSITION: 3
    };
    const numPoints = dracoGeometry.num_points();
    Object.keys(attrs).forEach((attr) =&gt; {
        const decoderAttr = decoderModule[attr];
        const attrId = decoder.GetAttributeId(dracoGeometry, decoderAttr);
        const stride = attrs[attr];
        const numValues = numPoints * stride;

        const attribute = decoder.GetAttribute(dracoGeometry, attrId);
        const attributeData = new decoderModule.DracoFloat32Array();
        decoder.GetAttributeFloatForAllPoints(dracoGeometry, attribute, attributeData);
        let points = [];
        for (let i = 0; i &lt; numValues; i = i &#43; stride) {
            for (let j = i; j &lt; i &#43; stride; j&#43;&#43;) {
                points.push(attributeData.GetValue(j));
            }
        }
        decoderModule.destroy(attributeData);
    });
    let endTime = new Date();
    let timeCost = styleText(&#39;green&#39;, `${endTime - startTime}`);
    console.log(`Encode finished,time cost: ${timeCost}ms, decode point size: ` &#43; styleText(&#39;green&#39;, `${numPoints}`));
    decoderModule.destroy(decoder);
    decoderModule.destroy(dracoGeometry);
}</code>
</pre><p>执行下述指令对前述生成的drc文件分别进行解码</p>
<pre class="line-numbers language-bash " title="bash">
<code>node draco_decode_test.js 000000.drc
node draco_decode_test.js 000001.drc
node draco_decode_test.js 000002.drc</code>
</pre><p>执行结果类似如下，可以看出虽然其解码耗时也随着<code>drc</code>变大而增多，但相对于<code>JavaScript</code>形式的编码而言已经非常短，可直接用于生产环境。</p>
<p><img src="/blog_img/pointcloud/using-draco-to-encode-decode-and-transport-pointcloud-data/draco-decode-results.png" alt="Draco解码结果展示" title="Draco解码结果展示"></p>
<p>进一步同前述编码过程的输出对比，可发现编码解码后的点云总数保持一致，那为啥其文件体积能缩小这么多呢？</p>
<p>除了编码算法的功劳，还在于<strong>其在不影响使用的前提下牺牲了一部分的精确度</strong>，解码后的数据值无法完全同编码前的保持一致。</p>
<p><img src="/blog_img/pointcloud/using-draco-to-encode-decode-and-transport-pointcloud-data/draco-encode-decode-compare.png" alt="Draco编码解码结果对比" title="Draco编码解码结果对比"></p>
<h2 id="脚本转换">脚本转换</h2>
<p>前述过程中演示了基于<code>js</code>代码实现的编码与解码，虽然解码过程很快，但是编码过程很慢，实际使用中不可能忍受如此长的编码时间。</p>
<p>前述的官方对比中采用<code>C++</code>进行编解码效率更高，故可采用基于<code>C++</code>编译后的脚本进行数据编解码来进一度缩短耗时。</p>
<p>1.在<code>Draco</code>官网下载对应的源码文件后解压，进入<code>cmake</code>目录下，可发现有相关的编译文件</p>
<p><img src="/blog_img/pointcloud/using-draco-to-encode-decode-and-transport-pointcloud-data/draco-cmake-files.png" alt="Draco编译文件列表" title="Draco编译文件列表"></p>
<p>2.基于<a href="https://github.com/google/draco/blob/main/BUILDING.md">此说明</a>在<code>Draco</code>的根目录下执行如下操作</p>
<pre class="line-numbers language-bash " title="bash">
<code>mkdir build_dir &amp;&amp; cd build_dir
cmake ../</code>
</pre><p>3.若是初次执行，可能会有如下报错</p>
<p><img src="/blog_img/pointcloud/using-draco-to-encode-decode-and-transport-pointcloud-data/draco-cmake-error.png" alt="Draco CMake失败" title="Draco CMake失败"></p>
<p>4.根据不同的操作系统，需要查询<code>no cmake_cxx_compiler could be found</code>的解决方案，并进行针对性的修复，以<code>CentOS 9</code>为例，可执行如下指令</p>
<pre class="line-numbers language-bash " title="bash">
<code>yum -y update
yum -y install g&#43;&#43;</code>
</pre><p>5.之后重新重新步骤2中的编译指令，可正常执行，同时可发现在当前目录下生成了一个名为<code>Makefile</code>的文件</p>
<p><img src="/blog_img/pointcloud/using-draco-to-encode-decode-and-transport-pointcloud-data/draco-cmake-success.png" alt="Draco CMake成功" title="Draco CMake成功"></p>
<p>6.在当前目录下执行<code>make</code>指令</p>
<p><img src="/blog_img/pointcloud/using-draco-to-encode-decode-and-transport-pointcloud-data/draco-make-progress.png" alt="Draco开始make编译" title="Draco开始make编译"></p>
<p>7.若一切正常，<code>make</code>指令编译后的输出类似如下，其中标红的即为可供最终使用的编码与解码脚本</p>
<p><img src="/blog_img/pointcloud/using-draco-to-encode-decode-and-transport-pointcloud-data/draco-make-result.png" alt="Draco中make编译结果" title="Draco中make编译结果"></p>
<p>8.执行下述指令，创建对应的测试目录，并将<code>ply</code>文件拷贝到<code>ply_src_data</code>目录下去</p>
<pre class="line-numbers language-bash " title="bash">
<code>cd .. &amp;&amp; mkdir -p draco_test/ply_src_data

cp build_dir/draco_encoder draco_test/
cp build_dir/draco_decoder draco_test/

cd draco_test

# 将ply文件拷贝到ply_src_data目录下去</code>
</pre><p>9.<code>Draco</code>官方提供的编码指令类似</p>
<pre class="line-numbers language-bash " title="bash">
<code># 包含网格数据
./draco_encoder -i testdata/bun_zipper.ply -o out.drc

# 单纯的对点云进行编码
./draco_encoder -point_cloud -i testdata/bun_zipper.ply -o out.drc

# 采用更高的压缩率
./draco_encoder -point_cloud -cl 10 -i testdata/bun_zipper.ply -o out.drc</code>
</pre><p>为了便于批量测试与统计，可将其封装为类似如下的<code>Shell</code>脚本</p>
<pre class="line-numbers language-bash " title="bash">
<code>#!/bin/sh

encode_drc(){
  file=$1
  dst_folder=$2
  filename1=$(echo $file | awk -F &#34;/&#34; &#39;{print $NF}&#39;)
  filename2=$(echo $filename1 | awk -F &#34;.&#34; &#39;{print $1}&#39;)

  echo &#34;--------------begin to encode ${filename2}-------------------&#34;

  # 记录开始时间（秒.纳秒）
  start=$(date &#43;%s.%N)

  # 转化为ply文件
  echo $filename1
  ./draco_encoder -point_cloud -i $file -o ${dst_folder}/${filename2}.drc

  # 记录结束时间
  end=$(date &#43;%s.%N)

  # 计算时间差（保留6位小数，即微秒）
  runtime=$(echo &#34;scale=3; ($end - $start) * 1000&#34; | bc)

  # 输出结果
  GREEN=&#39;\033[32m&#39;
  # 重置样式
  RESET=&#39;\033[0m&#39;
  echo -e &#34;${filename1} enecode time cost: ${GREEN}${runtime}${RESET} ms\n\n&#34;
}

dst_folder=&#39;drc_encode_result&#39;
rm -rf ${dst_folder}
mkdir ${dst_folder}
for file in ply_src_data/*.ply; do
    encode_drc $file ${dst_folder}
done</code>
</pre><p>10.编码后测试结果如下，对比可看出，相对于<code>js</code>版本的耗时操作，采用脚本的方式几乎都是<strong>秒级完成</strong>，实际生产环境建议采用<code>C++</code>代码进行编码或类似上述的脚本编码。</p>
<p><img src="/blog_img/pointcloud/using-draco-to-encode-decode-and-transport-pointcloud-data/draco-script-encode-result.png" alt="Draco脚本文件编码结果" title="Draco脚本文件编码结果"></p>
<p>同时输出过程中也提示可基于类似<code>-cl 10</code>的设置来获得更好的压缩效果，此操作虽然能减少文件大小，但同时会牺牲一定程度的精确度，后续部分会说明。</p>
<p>11.<code>Draco</code>官方提供的编码脚本相对简单</p>
<pre class="line-numbers language-bash " title="bash">
<code># 输出为obj文件
./draco_decoder -i in.drc -o out.obj

# 输出为ply文件
./draco_decoder -i in.drc -o out.ply</code>
</pre><p>同样将其封装为<code>Shell</code>脚本</p>
<pre class="line-numbers language-bash " title="bash">
<code>#!/bin/sh

decode_drc(){
  file=$1
  dst_folder=$2
  filename1=$(echo $file | awk -F &#34;/&#34; &#39;{print $NF}&#39;)
  filename2=$(echo $filename1 | awk -F &#34;.&#34; &#39;{print $1}&#39;)

  echo &#34;--------------begin to decode ${filename1}-------------------&#34;

  # 记录开始时间（秒.纳秒）
  start=$(date &#43;%s.%N)

  # 转化为ply文件
  dst_file=${dst_folder}/${filename2}.ply
  ./draco_decoder -i $file -o ${dst_file}

  # 记录结束时间
  end=$(date &#43;%s.%N)

  # 计算时间差（保留6位小数，即微秒）
  runtime=$(echo &#34;scale=3; ($end - $start) * 1000&#34; | bc)

  # 输出结果
  GREEN=&#39;\033[32m&#39;
  # 重置样式
  RESET=&#39;\033[0m&#39;
  point_size=$(awk &#39;NR==3&#39; ${dst_file} | awk &#39;{print $NF}&#39;)
  echo -e &#34;${filename1} decode time cost: ${GREEN}${runtime}${RESET} ms, point size: ${GREEN}${point_size}${RESET}\n&#34;
}

dst_folder=&#39;ply_decode_result&#39;
rm -rf ${dst_folder}
mkdir ${dst_folder}
for file in drc_encode_result/*.drc; do
    decode_drc $file ${dst_folder}
done</code>
</pre><p>12.解码操作执行结果如下，可看出解码后的点云数据总数与原始文件中保持一致，由于即使是<code>js</code>的解码耗时也不太多，故实际生产中采用脚本解码的方式并不常见。</p>
<p><img src="/blog_img/pointcloud/using-draco-to-encode-decode-and-transport-pointcloud-data/draco-script-decode-result.png" alt="Draco脚本文件解码结果" title="Draco脚本文件解码结果"></p>
<h2 id="精确度问题">精确度问题</h2>
<p>前述测试主要对比的是点云数据，没有对编码解码后的具体点云信息进行对比，而在点云总数符合要求时，基于不同的量化属性设置，其精确度可能会发生变化，最终对点云整体渲染显示效果造成干扰。</p>
<p>关于量化参数的设置，官方的说明如下</p>
<blockquote>
<p>In general, the more you quantize your attributes the better compression rate you will get. It is up to your project to decide how much deviation it will tolerate. In general, most projects can set quantization values of about <code>11</code> without any noticeable difference in quality.</p>
</blockquote>
<p>其在脚本中是通过<code>-qp</code>参数设置的，在代码中则是通过<code>SetAttributeQuantization(encoderModule.POSITION, 5);</code>实现</p>
<p>利用下述代码对编码和解码过程中的数据进行输出对比</p>
<pre class="line-numbers language-js " title="js">
<code>function printPointClouds(points) {
    // 最多只输出20点的坐标数据，便于进行对比
    let num = points.length &lt; 20 ? points.length : 20;
    for (let i = 0; i &lt; num * 3; i = i &#43; 3) {
        console.log(styleText(&#39;yellow&#39;, points[i] &#43; &#39;\t\t&#39; &#43; points[i &#43; 1] &#43; &#39;\t&#39; &#43; points[i &#43; 2]));
    }
}</code>
</pre><p>将编码部分修改如下</p>
<pre class="line-numbers language-javascript " data-line="8" title="javascript">
<code>rl.on(&#39;close&#39;, () =&gt; {
    // xxx
    // 计算大小时排除掉表头的声明部分
    let pointSize = styleText(&#39;green&#39;, `${data.length - 7}`);
    console.log(`point size: ${pointSize}`);
    
    // 添加此行代码详细信息
    printPointClouds(points);
    
    encodePointCloudToFile(dstFile, points);
});

// 设置低量化参数
encoder.SetAttributeQuantization(encoderModule.POSITION, 5);</code>
</pre><p>将解码部分修改如下</p>
<pre class="line-numbers language-javascript " data-line="10" title="javascript">
<code>decoder.GetAttributeFloatForAllPoints(dracoGeometry, attribute, attributeData);
let points = [];
for (let i = 0; i &lt; numValues; i = i &#43; stride) {
    for (let j = i; j &lt; i &#43; stride; j&#43;&#43;) {
        points.push(attributeData.GetValue(j));
    }
}

// 添加此行代码详细信息
printPointClouds(points);

decoderModule.destroy(attributeData);</code>
</pre><p>然后可以执行下述指令并对比输出结果</p>
<pre class="line-numbers language-bash " title="bash">
<code>node draco_encode_test.js 000000.ply 000000.drc
node draco_decode_test.js 000000.drc</code>
</pre><h3 id="float对比">Float对比</h3>
<p>点云数据通常情况下都是以<code>Float</code>形式存储的，执行完毕后的输出对比如下</p>
<p><img src="/blog_img/pointcloud/using-draco-to-encode-decode-and-transport-pointcloud-data/draco-float-compare.png" alt="Draco基于Float的编解码对比" title="Draco基于Float的编解码对比"></p>
<p>基于上述输出可得出如下结论：</p>
<ol>
<li>点云解码后的结果与原始文件的数据顺序不一定一致，但同一个点云的相关数据(x,y,z,颜色等)一定是在一起的，点云存储的顺序对最终结果无影响</li>
<li>在低量化参数时，虽然编解码速度上去了，但是数据的精确度牺牲很大(在本例中的z坐标数据都一样)，可能会对实际使用造成影响</li>
</ol>
<h3 id="int对比">Int对比</h3>
<p>观察原始的点云数据输出，发现其小数点后最多有6位小数，尝试在编码过程中可将其放大为整数，解码过程中缩小为浮点数，以验证是否为<code>Float</code>类型导致的精确度丢失。</p>
<p>将编码部分修改如下</p>
<pre class="line-numbers language-javascript " data-line="9" title="javascript">
<code>rl.on(&#39;close&#39;, () =&gt; {
    // xxx
    // 计算大小时排除掉表头的声明部分
    let pointSize = styleText(&#39;green&#39;, `${data.length - 7}`);
    console.log(`point size: ${pointSize}`);
    printPointClouds(points);

    // 对点云数据进行放大
    points = points.map(p =&gt; p*1_000_000);
    encodePointCloudToFile(dstFile, points);
});</code>
</pre><p>将解码部分修改如下</p>
<pre class="line-numbers language-javascript " data-line="5" title="javascript">
<code>let points = [];
for (let i = 0; i &lt; numValues; i = i &#43; stride) {
    for (let j = i; j &lt; i &#43; stride; j&#43;&#43;) {
        // 对点云数据进行缩小
        points.push(Number(attributeData.GetValue(j))/1_000_000);
    }
}		
printPointClouds(points);
decoderModule.destroy(attributeData);</code>
</pre><p>重新执行编解码后的输出如下，可以看出其对比结果与<code>Float</code>类型的差别不大，精确度的丢失不是由于<code>Float</code>数据类型造成的</p>
<p><img src="/blog_img/pointcloud/using-draco-to-encode-decode-and-transport-pointcloud-data/draco-int-compare.png" alt="Draco基于Int的编解码对比" title="Draco基于Int的编解码对比"></p>
<h3 id="高量化对比">高量化对比</h3>
<p>在编码过程中设置高压缩比，以牺牲解码性能</p>
<pre class="line-numbers language-bash " title="bash">
<code># 调高量化参数
encoder.SetAttributeQuantization(encoderModule.POSITION, 10);</code>
</pre><p>执行结果对比如下，可看出其精确度有了明显的提升！</p>
<p><img src="/blog_img/pointcloud/using-draco-to-encode-decode-and-transport-pointcloud-data/draco-compress-level-compare.png" alt="Draco基于不同量化参数的对比" title="Draco基于不同量化参数的对比"></p>
<h2 id="显示效果对比">显示效果对比</h2>
<p>原始点云数据直接渲染的效果如下</p>
<p><img src="/blog_img/pointcloud/using-draco-to-encode-decode-and-transport-pointcloud-data/original-point-cloud-render.png" alt="原始点云渲染" title="原始点云渲染"></p>
<p>基于低量化压缩率编码解码后的渲染效果如下，如前所述此时其会损失一定程度的精确度，导致渲染后效果与原始渲染效果有肉眼可见的清晰度差异。</p>
<p>尽管如此还是能看清楚要展示的内容，此种方式适合对性能要求严苛的场景。</p>
<p><img src="/blog_img/pointcloud/using-draco-to-encode-decode-and-transport-pointcloud-data/float-draco-point-cloud-render.png" alt="基于低量化压缩率的Draco点云渲染" title="基于低量化压缩率的Draco点云渲染"></p>
<p>采用高量化压缩率的编码解码后的渲染效果如下，其显示效果与原始渲染效果差别已经很接近了。
<img src="/blog_img/pointcloud/using-draco-to-encode-decode-and-transport-pointcloud-data/int-draco-point-cloud-render.png" alt="基于量化高压缩率的Draco点云渲染" title="基于高量化压缩率的Draco点云渲染"></p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>数据差异较大的原因网络环境导致，左侧为公司内部网络测试、右侧为其它区域的分公司测试&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>基于编码压缩时设置的参数，实际解码后的数据与原始数据会有一定程度的误差，但整体上不会对正常使用造成影响&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/pointcloud/">pointcloud</a>
          <a href="/tags/draco/">draco</a>
          </div>
      <nav class="post-nav">
        
        <a class="next" href="/post/translate/ai/if-gpus-are-so-good-why-do-we-still/">
            <span class="next-text nav-default">[译]既然GPU如此强大，为啥我们还需要使用CPU?</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://giscus.app/client.js"
            data-repo="lucumt/ghblog"
            data-repo-id="MDEwOlJlcG9zaXRvcnk0MTQ3MDEzOA=="
            data-category="General"
            data-category-id="DIC_kwDOAnjIus4CRN6c"
            data-mapping="pathname"
            data-strict="0"
            data-reactions-enabled="1"
            data-emit-metadata="0"
            data-input-position="top"
            data-theme="light"
            data-lang="en"
            data-loading="lazy"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/giscus/giscus">comments powered by giscus.</a></noscript>

      </div>
    </main>
	<footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:cumtlu@126.com" class="iconfont icon-email" title="email"></a>
      <a href="https://stackoverflow.com/users/3176419" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="https://www.linkedin.com/in/%E8%BF%90%E5%BC%BA-%E5%8D%A2-50a08bb5/" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="https://github.com/lucumt" class="iconfont icon-github" title="github"></a>
  <a href="" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 本站总访问量 <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次 </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> 本站总访客数 <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 人 </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2016 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer><div class="back-to-top" id="back-to-top" title="回到顶部">
      <i class="iconfont icon-up"></i>
    </div>
  </div><script type="text/javascript" src="/lib/jquery/jquery-3.6.4.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script><script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script><script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7546563545653680"
            crossorigin="anonymous"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-75123653-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-75123653-1');
</script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-3S3FFW5PH3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-3S3FFW5PH3');
</script><script id="baidu_analytics">
	  var _hmt = _hmt || [];
	  (function() {
		if (window.location.hostname === 'localhost') return;
		var hm = document.createElement("script"); hm.async = true;
		hm.src = "https://hm.baidu.com/hm.js?cabc0a71f63da092412d82d1aefe7d1c";
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(hm, s);
	  })();
	</script>


	<script id="baidu_push">
	  (function(){
		if (window.location.hostname === 'localhost') return;
		var bp = document.createElement('script'); bp.async = true;
		var curProtocol = window.location.protocol.split(':')[0];
		if (curProtocol === 'https') {
		  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
		}
		else {
		  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
		}
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(bp, s);
	  })();
	</script>


<script>
  let copyIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
  <path fill-rule="evenodd" 
  d="M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2zm2-1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1zM2 
      5a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1h1v1a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h1v1z"/>
</svg>`;
  let copiedIcon=`<svg clip-rule="evenodd" fill-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="2" width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
  <path d="m2.25 12.321 7.27 6.491c.143.127.321.19.499.19.206 0 .41-.084.559-.249l11.23-12.501c.129-.143.192-.321.192-.5 0-.419-.338-.75-.749-.75-.206 0-.411.084-.559.249l-10.731 11.945-6.711-5.994c-.144-.127-.322-.19-.5-.19-.417 0-.75.336-.75.749 0 .206.084.412.25.56" fill-rule="nonzero"/></svg>`;
  function createCopyButton(codeDiv) {
    const div = document.createElement("div");
    div.className = "copy-code";
    div.innerHTML = copyIcon;
    div.addEventListener("click", () =>
      copyCodeToClipboard(div, codeDiv)
    );
    addCopyButtonToDom(div, codeDiv);
  }

  async function copyCodeToClipboard(button, codeDiv) {
    const codeToCopy = codeDiv.querySelector(":scope > code")
      .innerText;
    await navigator.clipboard.writeText(codeToCopy);
    button.blur();
	button.innerHTML = copiedIcon;
    setTimeout(() => button.innerHTML = copyIcon, 2000);
  }

  function addCopyButtonToDom(button, codeDiv) {
    const wrapper = document.createElement("div");
    wrapper.className = "highlight-wrapper";
    codeDiv.parentNode.insertBefore(wrapper, codeDiv);
    wrapper.appendChild(codeDiv);
	wrapper.insertBefore(button, wrapper.firstChild);
  }

  var isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
  if(!isMobile){
     document.querySelectorAll("pre[class*=language]").forEach((codeDiv) => createCopyButton(codeDiv));
  }
</script>  




  <script type="text/javascript" src="/lib/prism-1.29.0/components/prism-core.min.js"></script>
  <script type="text/javascript" src="/lib/prism-1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  <script type="text/javascript" src="/lib/prism-1.29.0/plugins/line-highlight/prism-line-highlight.min.js"></script>
  <script type="text/javascript" src="/lib/prism-1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
  
  <script type="text/javascript">
     document.addEventListener('DOMContentLoaded', initCodeTabs);
	 document.addEventListener('DOMContentLoaded', switchTabCodes);
	 function initCodeTabs(){
	     document.querySelectorAll('.codetabs').forEach(tab =>{
		    let tabHeader = tab.querySelector('.codetabs-header');
			let tabBody = tab.querySelector('.codetabs-body');
		    let codeblocks = tab.querySelectorAll('.codetabs-body > .highlight-wrapper');
			codeblocks.forEach((block,index) =>{
			   let titleContent = block.querySelector('pre').getAttribute('title');
			   let title = document.createElement('div');
			   title.classList.add('tab');
			   if(index == 0){
			   	  title.classList.add('active');
			   }
			   title.setAttribute('data-codetab',index);
			   title.appendChild(document.createTextNode(titleContent));
			   tabHeader.appendChild(title);
			   
			   let div = document.createElement('div');
			   div.classList.add('tab');
			   if(index == 0){
			   	  div.classList.add('active');
			   }
			   div.setAttribute('data-codetab',index);
			   div.appendChild(block);
			   tabBody.appendChild(div);
			});
		 });
	 }
	 function switchTabCodes(){
		 document.querySelectorAll('.codetabs  .codetabs-header > .tab').forEach(tab => {
			 tab.addEventListener('click', function() {
			      if(tab.classList.contains('active')){
					 return;
				  }
				  let tabId = tab.getAttribute('data-codetab');
				  let codetabs = tab.parentNode.parentNode;
				  
				  codetabs.querySelectorAll('.codetabs .tab.active').forEach(e => e.classList.remove('active'));
				  codetabs.querySelectorAll('.codetabs .tab[data-codetab="' + tabId + '"]').forEach(e => e.classList.add('active'));  
			 });
		 });
	 }
  </script>
</body>
</html>
