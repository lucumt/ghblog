<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 飞狐的部落格</title>
    <link>http://lucumt.info/posts/</link>
    <description>Recent content in Posts on 飞狐的部落格</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 05 Mar 2017 14:04:43 +0800</lastBuildDate>
    <atom:link href="http://lucumt.info/posts/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>在Intellij IDEA中引用Golang本地包</title>
      <link>http://lucumt.info/posts/import-local-page-in-intellij-idea/</link>
      <pubDate>Sun, 05 Mar 2017 14:04:43 +0800</pubDate>
      
      <guid>http://lucumt.info/posts/import-local-page-in-intellij-idea/</guid>
      <description>

&lt;p&gt;在学习&lt;code&gt;Golang&lt;/code&gt;时，自己最开始用的是eclpse中的&lt;a href=&#34;https://goclipse.github.io/&#34;&gt;goclipse&lt;/a&gt;插件来进行&lt;code&gt;Golang&lt;/code&gt;编程，但其对&lt;code&gt;Golang&lt;/code&gt;的支持不是太好，如代码格式化、自动导入引用包等都无法直接在eclipse中使用，并且其自动提示功能也没有像&lt;code&gt;Java&lt;/code&gt;那么强，于是转用&lt;a href=&#34;https://www.jetbrains.com/idea/&#34;&gt;Intellij IDEA&lt;/a&gt;安装&lt;a href=&#34;https://plugins.jetbrains.com/plugin/5047-go&#34;&gt;Golang插件&lt;/a&gt;来替代使用，安装完插件后的&lt;a href=&#34;https://www.jetbrains.com/idea/&#34;&gt;Intellij IDEA&lt;/a&gt;对&lt;code&gt;Golang&lt;/code&gt;的支持在各方面都很令人满意，唯独引入本地包的支持不太好用。经过一阵摸索自己找出了解决方案，先记录下。&lt;/p&gt;

&lt;h1 id=&#34;在eclipse中引用golang本地包:d0311b7d249635030def3a3303ae4d70&#34;&gt;在Eclipse中引用Golang本地包&lt;/h1&gt;

&lt;p&gt;若我们采用的是&lt;a href=&#34;https://goclipse.github.io/&#34;&gt;goclipse&lt;/a&gt;来开发&lt;code&gt;Golang&lt;/code&gt;,则在其中引用本地包很简单，和引用Java包类似。如下图所示，假设 &lt;em&gt;src&lt;/em&gt; 是源代码所在的目录，在 &lt;em&gt;src&lt;/em&gt; 的 &lt;em&gt;sec&lt;/em&gt; 文件夹下有一个名为 &lt;em&gt;calculate.go&lt;/em&gt; 的文件，其中有一个名为 &lt;em&gt;Add&lt;/em&gt; 的函数用于计算两个整数的相加之和。&lt;br /&gt;
&lt;img src=&#34;http://lucumt.info/blog_img/import-local-page-in-intellij-idea/goclipse_package.png&#34; alt=&#34;goclipse中的本地包&#34; /&gt;
&lt;br /&gt;
若要在主程序main方法中调用 &lt;em&gt;Add&lt;/em&gt; 方法，先通过import引入该文件的包名&lt;code&gt;import service&lt;/code&gt;，然后通过包名调用该方法&lt;code&gt;service.Add(1,2)&lt;/code&gt;，如下图所示，可以看出在Eclipse中引用&lt;code&gt;Golang&lt;/code&gt;本地包与引用Java包没有太大的区别，都是将包文件放到 &lt;em&gt;src&lt;/em&gt; 源文件夹下，然后通过包名来引用。&lt;br /&gt;
&lt;img src=&#34;http://lucumt.info/blog_img/import-local-page-in-intellij-idea/goclipse_package_reference.png&#34; alt=&#34;goclipse中的本地包引用&#34; /&gt;
&lt;br /&gt;
也可以通过直接导入该包所在的文件夹的名称来调用该方法，此时需要将&lt;code&gt;import service&lt;/code&gt;改为&lt;code&gt;import sec&lt;/code&gt;，如下图所示&lt;br /&gt;
&lt;img src=&#34;http://lucumt.info/blog_img/import-local-page-in-intellij-idea/goclipse_package_reference_folder.png&#34; alt=&#34;goclipse中的本地包通过文件夹引用&#34; /&gt;
&lt;br /&gt;
可以看出在eclipse中导入&lt;code&gt;Golang&lt;/code&gt;本地包时有两种方法： &lt;strong&gt;通过import导入包名&lt;/strong&gt; 或 &lt;strong&gt;通过import导入该包对应的文件夹&lt;/strong&gt; ，这两种方法均可使程序正常运行。&lt;/p&gt;

&lt;h1 id=&#34;在intellij-idea中引用golang本地包:d0311b7d249635030def3a3303ae4d70&#34;&gt;在Intellij IDEA中引用Golang本地包&lt;/h1&gt;

&lt;p&gt;下面2张图为在IDEA中建立的对应项目，图中 &lt;em&gt;gproject&lt;/em&gt; 是一个项目，&lt;em&gt;gotest&lt;/em&gt; 是一个模块，我们在 &lt;em&gt;gotest&lt;/em&gt; 下建立相关的测试文件。&lt;br /&gt;
&lt;img src=&#34;http://lucumt.info/blog_img/import-local-page-in-intellij-idea/idea_package.png&#34; alt=&#34;IDEA中的本地包&#34; /&gt;
&lt;br /&gt;
&lt;img src=&#34;http://lucumt.info/blog_img/import-local-page-in-intellij-idea/idea_package_reference.png&#34; alt=&#34;IDEA中的本地包引用&#34; /&gt;
&lt;br /&gt;
在上述代码中我们是通过&lt;code&gt;import service&lt;/code&gt;的方式来导入相应包的，由于IDEA对Golang很强，从图中可以看出 &lt;em&gt;service&lt;/em&gt; 的颜色与其它导入包的颜色不一致，当把鼠标移动到 &lt;em&gt;service&lt;/em&gt; 上时会提示 &lt;em&gt;Cannot resolve file &amp;lsquo;service&amp;rsquo;&lt;/em&gt; ，直接运行时，会出现如下图所示 &lt;em&gt;cannot find package&lt;/em&gt; 错误，将&lt;code&gt;import service&lt;/code&gt;修改为&lt;code&gt;import sec&lt;/code&gt;时，会出现同样的错误，可以看出在idea中默认不支持直接导入本地&lt;code&gt;Golang&lt;/code&gt;包。&lt;br /&gt;
&lt;img src=&#34;http://lucumt.info/blog_img/import-local-page-in-intellij-idea/idea_package_reference_run_error.png&#34; alt=&#34;IDEA中引用本地包运行出错&#34; /&gt;
&lt;br /&gt;
从报错信息可以看出，程序在运行时先去 &lt;strong&gt;GOROOT&lt;/strong&gt; 去搜索导入包，然后去 &lt;strong&gt;GOPATH&lt;/strong&gt; 寻找导入包，最后在当前项目模块下寻找导入包，但实际上不存在 &lt;em&gt;D:\program\IntelliJ IDEA 2016.2.1\workspace\gproject\gotest\src\service&lt;/em&gt; 这个目录，故而程序报错，不能正常运行。&lt;/p&gt;

&lt;p&gt;解决该问题的关键是明白 &lt;strong&gt;&lt;a href=&#34;http://golang.org/doc/install#tarball_non_standard&#34;&gt;GOROOT&lt;/a&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;a href=&#34;http://golang.org/cmd/go/#hdr-GOPATH_environment_variable&#34;&gt;GOPATH&lt;/a&gt;&lt;/strong&gt; 的作用，根据官方文档的解释 &lt;strong&gt;GOPATH&lt;/strong&gt; 的主要作用是存放文件以便&lt;code&gt;Golang&lt;/code&gt;程序编译时可以进行搜索引用，&lt;strong&gt;GOPATH&lt;/strong&gt; 可以设置一个值或多个值，多个值之间以分号隔开。很明显只要我们将本地&lt;code&gt;Golang&lt;/code&gt;加入到 &lt;strong&gt;GOPATH&lt;/strong&gt;中即可在IDEA中正常运行该程序。&lt;/p&gt;

&lt;p&gt;如下图所示，在IDEA中依次选择 &lt;strong&gt;File-&amp;gt;Settings-&amp;gt;Language&amp;amp;Frameworks-&amp;gt;Go-&amp;gt;Go Libraries&lt;/strong&gt; ，会出现如下图所示的配置&lt;code&gt;Golang&lt;/code&gt;库的界面，在该界面可以添加&lt;code&gt;Golang&lt;/code&gt;本地包所在的路径，该界面包含3个不同作用范围的配置方式： &lt;em&gt;Global libraries&lt;/em&gt; 、 &lt;em&gt;Project libraries&lt;/em&gt; 和 &lt;em&gt;Module libraries&lt;/em&gt; ，其中 &lt;em&gt;Global libraries&lt;/em&gt; 的配置对所有项目生效为全局配置，&lt;em&gt;Project libraries&lt;/em&gt; 的配置对整个项目生效，&lt;em&gt;Module libraries&lt;/em&gt; 的配置只对模块生效，可以看出在 &lt;em&gt;Global libraries&lt;/em&gt; 默认包含了 &lt;strong&gt;GOPATH&lt;/strong&gt; 。根据实际使用的需求我们可以选择把本地包设置在 &lt;em&gt;Project libraries&lt;/em&gt; 还是 &lt;em&gt;Module libraries&lt;/em&gt; 中。&lt;br /&gt;
&lt;img src=&#34;http://lucumt.info/blog_img/import-local-page-in-intellij-idea/idea_package_select_gopath.png&#34; alt=&#34;IDEA中配置程序库&#34; /&gt;
&lt;br /&gt;
本文的程序都是在 &lt;em&gt;gotest&lt;/em&gt; 模块下，故将其添加到 &lt;em&gt;Module libraries&lt;/em&gt; 下，添加完的结果如下所示：&lt;br /&gt;
&lt;img src=&#34;http://lucumt.info/blog_img/import-local-page-in-intellij-idea/idea_package_gopath_config.png&#34; alt=&#34;IDEA中配置程序库的结果&#34; /&gt;
&lt;br /&gt;
将本地包添加到模块库之后，还需要在go文件中将导入包的语句设置为&lt;code&gt;import sec&lt;/code&gt;，不能设置为&lt;code&gt;import service&lt;/code&gt;，然后该&lt;code&gt;Golang&lt;/code&gt;程序即可正常运行。&lt;/p&gt;

&lt;p&gt;可以看出，不同于&lt;a href=&#34;https://goclipse.github.io/&#34;&gt;goclipse&lt;/a&gt;，在IDEA中只能使用 &lt;strong&gt;通过import导入该包对应的文件夹&lt;/strong&gt; 来导入本地&lt;code&gt;Golang&lt;/code&gt;包，至于原因还需要进一步研究。&lt;/p&gt;

&lt;h1 id=&#34;利用goclipse时无法运行程序的解决方法:d0311b7d249635030def3a3303ae4d70&#34;&gt;利用Goclipse时无法运行程序的解决方法&lt;/h1&gt;

&lt;p&gt;在使用&lt;a href=&#34;https://goclipse.github.io/&#34;&gt;goclipse&lt;/a&gt;运行&lt;code&gt;Golang&lt;/code&gt;程序时，偶尔会出现程序无法编译和运行的情况，这种情形一般都是 &lt;em&gt;src&lt;/em&gt; 没有被设置成源代码目录造成的，此时可以通过如下图所示的方法，将 &lt;em&gt;src&lt;/em&gt; 目录添加源代码目录。在Eclipse中选中该项目然后点击 &lt;strong&gt;Properties&lt;/strong&gt; ，会出现项目属性配置界面，点击 &lt;strong&gt;Go Project Configuration&lt;/strong&gt; ，通过 &lt;strong&gt;Add Folder&lt;/strong&gt; 可以将 &lt;em&gt;src&lt;/em&gt; 添加到源代码中，之后程序即可正常运行。&lt;br /&gt;
&lt;img src=&#34;http://lucumt.info/blog_img/import-local-page-in-intellij-idea/goclipse_add_source_folder.png&#34; alt=&#34;goclipse中添加源程序目录&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>计算两个平行于坐标轴的矩形相交的面积</title>
      <link>http://lucumt.info/posts/calculate-total-area-of-two-rectangles/</link>
      <pubDate>Sun, 26 Feb 2017 19:26:33 +0800</pubDate>
      
      <guid>http://lucumt.info/posts/calculate-total-area-of-two-rectangles/</guid>
      <description>&lt;p&gt;之前面试时遇到一个算法题: &lt;em&gt;假定两个矩形各条边都是平行于坐标轴，已知k、l、m、n分别为其中一个矩形左下角和右上角x轴、y轴坐标，p、q、r、s分别为另一个矩形的左下角和右上角x轴、y轴坐标，求这两个矩形的总面积，当矩形相交时要减去相交的面积。&lt;/em&gt; 此题利用常规的枚举法很复杂，但利用排除法和归纳法却能很快解决，故先记录下。&lt;/p&gt;

&lt;p&gt;很明显，此题的重点在于如何判断矩形是否相交以及检测相交形成的新矩形面积，当不相交时总面积直接为两个矩形的面积之和，当相交时需要减去相交矩形的面积，由于题目已经告诉了矩形的左下角和右上角坐标已知，问题又转化为在相交时如何计算相交矩形的左下角和右上角的坐标。&lt;/p&gt;

&lt;p&gt;最开始我想通过常规的枚举法把矩形相交的所有情况都列出来，在稿纸上简单的比划后，发现采用枚举的方式太复杂，矩形相交理论上有下图所示的16种组合方式，短时间内很难一一列举出来，实际编程中不仅代码量大还很容易产生遗漏。&lt;br /&gt;
&lt;img src=&#34;http://lucumt.info/blog_img/calculate-total-area-of-two-rectangles/intersect1.png&#34; alt=&#34;矩形相交1&#34; /&gt;

&lt;img src=&#34;http://lucumt.info/blog_img/calculate-total-area-of-two-rectangles/intersect2.png&#34; alt=&#34;矩形相交2&#34; /&gt;
&lt;br /&gt;
&lt;img src=&#34;http://lucumt.info/blog_img/calculate-total-area-of-two-rectangles/intersect3.png&#34; alt=&#34;矩形相交3&#34; /&gt;

&lt;img src=&#34;http://lucumt.info/blog_img/calculate-total-area-of-two-rectangles/intersect4.png&#34; alt=&#34;矩形相交4&#34; /&gt;
&lt;br /&gt;
排除枚举方法之后，只能对其进行分析找出通用的处理方式。下图展示了在相交矩形的左下角和右上角的位置，仔细分析后便可发现&lt;strong&gt;相交矩形的左下角x,y坐标是两个矩形左下角x,y坐标中取较大值，相交矩形的右上角x,y坐标是两个矩形右上角x,y坐标中取较小值&lt;/strong&gt;。&lt;br /&gt;
&lt;img src=&#34;http://lucumt.info/blog_img/calculate-total-area-of-two-rectangles/position_calculate.png&#34; alt=&#34;矩形相交坐标计算&#34; /&gt;
&lt;br /&gt;
通过分析归纳之后，我们将之前的16种相交情况统一为1个表达式，而这个表达式在编程时是很容易实现的，下面的代码展示了如何利用该表达式计算相交矩形的坐标以及其面积。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static int calculateIntersectArea(int k, int l, int m, int n, int p,int q, int r, int s) {
	int leftDownX = 0, leftDownY = 0, rightUpX = 0, rightUpY = 0;
	leftDownX = k &amp;gt; p ? k : p;
	leftDownY = l &amp;gt; q ? l : q;
	rightUpX = m &amp;lt; r ? m : r;
	rightUpY = n &amp;lt; s ? n : s;
	return (rightUpX - leftDownX) * (rightUpY - leftDownY);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;寻找出如何计算相交矩形的面积之后，还需要解决一个问题:&lt;strong&gt;上述实现只有在矩形相交时才正确，当矩形不相交时计算结果错误&lt;/strong&gt;，为此需要找出一个方法判定两个矩形是否相交。若利用枚举方法同样会有前述的16种情形需要考虑，同样很复杂，显然枚举方法不适合使用。换一种思路：&lt;strong&gt;如果把矩形不相交的情形排除掉，那么剩下的情形就是矩形相交了！&lt;/strong&gt;，而矩形不相交则相对容易多了，假设这两个矩形分别为A和B，则它们不相交一共有如下图所示的4中情况：&lt;br /&gt;
&lt;img src=&#34;http://lucumt.info/blog_img/calculate-total-area-of-two-rectangles/no_interact_position_compare.png&#34; alt=&#34;矩形不相交坐标计算&#34; /&gt;
&lt;br /&gt;
相应的代码实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static boolean isIntersect(int k, int l, int m, int n, int p, int q, int r, int s) {
	
	boolean nointersect = false;
	// B在A的上面
	nointersect = q &amp;gt; n;
	// B在A的下面
	nointersect = l &amp;gt; s;
	// B在A的左侧
	nointersect = r &amp;lt; k;
	// B在A的右侧
	nointersect = m &amp;lt; p;

	return !nointersect;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用上述2个判断方法，可以方便准确的计算出两个矩形在相交时的总面积，相应的代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static int solution(int k, int l, int m, int n, int p, int q, int r, int s) {

	int widthA = m - k;
	int heightA = n - l;
	int areaA = widthA * heightA;

	int widthB = r - p;
	int heightB = s - q;
	int areaB = widthB * heightB;
	int totalArea = areaA + areaB;

	boolean hasIntersect = isIntersect(k, l, m, n, p, q, r, s);
	if (hasIntersect) {
		totalArea -= calculateIntersectArea(k, l, m, n, p, q, r, s);
	}
	return totalArea;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析解决这个问题给我最深的感触是：&lt;strong&gt;有时候若某一类问题用枚举实现很复杂时，尝试去分析其中的规律，找出通用的解决方法&lt;/strong&gt;，不仅在算法方面，或许在生活中其它方面也适用吧！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在iframe嵌套的html5中播放视频时全屏显示和取消音量调整</title>
      <link>http://lucumt.info/posts/show-video-in-html5-page/</link>
      <pubDate>Sun, 30 Oct 2016 19:48:17 +0800</pubDate>
      
      <guid>http://lucumt.info/posts/show-video-in-html5-page/</guid>
      <description>

&lt;p&gt;由于项目需要，最近使用了在&lt;code&gt;html5&lt;/code&gt;中播放视频的功能，期间遇到了几个坑，先简单记录下。&lt;/p&gt;

&lt;h1 id=&#34;在html5页面中播放视频:29e51551d2052d8c2b6a55472d7ab989&#34;&gt;在html5页面中播放视频&lt;/h1&gt;

&lt;p&gt;如何在&lt;code&gt;html5&lt;/code&gt;页面中嵌入视频的代码在网上很容易直接搜索到，典型的代码如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;video width=&amp;quot;320&amp;quot; height=&amp;quot;240&amp;quot; controls=&amp;quot;controls&amp;quot;&amp;gt;
  &amp;lt;source src=&amp;quot;movie.mp4&amp;quot; type=&amp;quot;video/mp4&amp;quot;/&amp;gt;
  Your browser does not support the video tag.
&amp;lt;/video&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后的效果显示如下，从图中我们可以看出该视频播放界面包含 &lt;em&gt;快进&lt;/em&gt; 、 &lt;em&gt;音量调整&lt;/em&gt; 和 &lt;em&gt;全屏播放&lt;/em&gt; 这几个按钮&lt;br /&gt;
&lt;img src=&#34;https://ooo.0o0.ooo/2016/10/30/5815e96382a3c.png&#34; alt=&#34;浏览器中正常播放视频&#34; title=&#34;浏览器中正常播放视频&#34; /&gt;
&lt;/p&gt;

&lt;h1 id=&#34;在iframe中不能全屏播放视频:29e51551d2052d8c2b6a55472d7ab989&#34;&gt;在iframe中不能全屏播放视频&lt;/h1&gt;

&lt;p&gt;项目中好多地方都用&lt;code&gt;iframe&lt;/code&gt;来嵌套html页面，最开始我是用类似如下代码在被&lt;code&gt;iframe&lt;/code&gt;包含的页面中嵌入前面的视频播放代码，
发现显示出来的视频播放器没有全屏播放按钮，通过升级浏览器版本和清除缓存等方法依然不奏效。搜索&lt;strong&gt;&lt;a href=&#34;http://stackoverflow.com/&#34;&gt;stackoverflow&lt;/a&gt;&lt;/strong&gt;找到一个类似的问题&lt;a href=&#34;http://stackoverflow.com/questions/15276929/how-to-make-a-video-fullscreen-when-it-is-placed-inside-an-iframe&#34;&gt;How to make a video fullscreen when it is placed inside an iframe?&lt;/a&gt;，阅读后发现只需要将&lt;code&gt;iframe&lt;/code&gt;修改成&lt;code&gt;&amp;lt;iframe … allowfullscreen=&amp;quot;true&amp;quot; webkitallowfullscreen=&amp;quot;true&amp;quot; mozallowfullscreen=&amp;quot;true&amp;quot;&amp;gt;&lt;/code&gt;即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;iframe&amp;gt;
  &amp;lt;!DOCTYPE html&amp;gt;
  &amp;lt;html&amp;gt;
    &amp;lt;head /&amp;gt;
    &amp;lt;body&amp;gt;
      &amp;lt;video width=&amp;quot;320&amp;quot; height=&amp;quot;240&amp;quot; controls=&amp;quot;controls&amp;quot;&amp;gt;
		&amp;lt;source src=&amp;quot;movie.mp4&amp;quot; type=&amp;quot;video/mp4&amp;quot;/&amp;gt;
		Your browser does not support the video tag.
	  &amp;lt;/video&amp;gt;
    &amp;lt;body&amp;gt;
  &amp;lt;/html&amp;gt;
&amp;lt;/iframe&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://ooo.0o0.ooo/2016/10/30/581600e124b51.png&#34; alt=&#34;视频无法进行全屏播放&#34; title=&#34;视频无法进行全屏播放&#34; /&gt;
&lt;/p&gt;

&lt;h1 id=&#34;隐藏声音调整按钮:29e51551d2052d8c2b6a55472d7ab989&#34;&gt;隐藏声音调整按钮&lt;/h1&gt;

&lt;p&gt;有些演示视频只有图像没有声音，为了避免对使用者造成不必要的干扰，可以将声音播放按钮屏蔽掉，由于自己项目只支持基于&lt;code&gt;webkit&lt;/code&gt;内核的&lt;code&gt;Chrome&lt;/code&gt;浏览器访问，通过Google之后在 &lt;strong&gt;&lt;a href=&#34;http://stackoverflow.com/&#34;&gt;stackoverflow&lt;/a&gt;&lt;/strong&gt;找到
&lt;a href=&#34;http://stackoverflow.com/questions/15126921/why-do-no-user-agents-implement-the-css-cursor-style-for-video-elements/15145555#15145555&#34;&gt;Why do no user-agents implement the CSS cursor style for video elements&lt;/a&gt;这篇文章，其中列出了播放视频时相关控制按钮的css类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;video::-webkit-media-controls-panel&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-play-button&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-volume-slider-container&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-volume-slider&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-mute-button&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-timeline&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-current-time-display&lt;/li&gt;
&lt;li&gt;video::-webkit-full-page-media::-webkit-media-controls-panel&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-timeline-container&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-time-remaining-display&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-seek-back-button&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-seek-forward-button&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-fullscreen-button&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-rewind-button&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-return-to-realtime-button&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-toggle-closed-captions-button&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了屏蔽掉声音播放按钮，我们只需使用 &lt;em&gt;video::-webkit-media-controls-volume-slider&lt;/em&gt; 和  &lt;em&gt;video::-webkit-media-controls-mute-button&lt;/em&gt; 这两个属性即可，相应的css代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;	/**隐藏视频音量大小调整控件**/
	.no_sound_style&amp;gt;video::-webkit-media-controls-volume-slider{
		display:none;
	}
	
	/**影藏视频音量喇叭**/
	.no_sound_style&amp;gt;video::-webkit-media-controls-mute-button{
		display:none;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应的显示效果如下图所示，可以看到音量喇叭和音量调整空间都消失不见&lt;br /&gt;
&lt;img src=&#34;https://ooo.0o0.ooo/2016/10/30/5815f41099feb.png&#34; alt=&#34;屏蔽了声音播放按钮&#34; title=&#34;屏蔽了播放器中的声音播放按钮&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mybatis batch insert exception</title>
      <link>http://lucumt.info/posts/mybatis-batch-insert-exception/</link>
      <pubDate>Mon, 30 May 2016 18:20:37 +0800</pubDate>
      
      <guid>http://lucumt.info/posts/mybatis-batch-insert-exception/</guid>
      <description>&lt;p&gt;在利用 &lt;strong&gt;&lt;a href=&#34;http://www.mybatis.org/mybatis-3/&#34;&gt;MyBatis&lt;/a&gt;&lt;/strong&gt; 进行多条数据插入时，为了提高性能我们可能会使用批量插入的功能来实现。示例代码如下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SQL配置文件:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;insert id=&amp;quot;addAuthorityRoleBatch&amp;quot; parameterType=&amp;quot;List&amp;quot;&amp;gt;
    INSERT INTO system_authority_role(role_id,authority_id)
      VALUES
      &amp;lt;foreach collection=&amp;quot;list&amp;quot; item=&amp;quot;authRole&amp;quot; separator=&amp;quot;,&amp;quot;&amp;gt;
        (#{authRole.roleId},#{authRole.authorityId})
      &amp;lt;/foreach&amp;gt;
  &amp;lt;/insert&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Java代码:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public void adjustRoleAuth(String roleId, String authIdsStr) {
    authRoleDao.deleteAuthorityRoleByRole(roleId);
    String[] authIds=authIdsStr.split(&amp;quot;;&amp;quot;);
    List&amp;lt;AuthorityRoleModel&amp;gt; authRoleList=new ArrayList&amp;lt;AuthorityRoleModel&amp;gt;();
    for(String authId:authIds){
        authRoleList.add(new AuthorityRoleModel(roleId,authId));
    }
    authRoleDao.addAuthorityRoleBatch(authRoleList);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码大多数时候可以正常运行，但是偶尔会出现如下异常：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;### SQL: INSERT INTO system_authority_role(role_id,authority_id)       VALUES
### Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39; at line 2
; bad SQL grammar []; nested exception is com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39; at line 2
at org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator.doTranslate(SQLErrorCodeSQLExceptionTranslator.java:233
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的异常堆栈信息显示现在执行的MySQL语句发生了语法错误，INSERT VALUE后面的值为空，由于该问题有时候发生，有时候不发生，给我们分析该问题造成了一定的困扰。&lt;br/&gt;
该问题产生的根源为批量插入时的集合数据为空，使得SQL配置文件中的foreach循环没有执行，从而导致SQL语句不完整，进而产生该异常。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>利用SpringMVC下载大文件</title>
      <link>http://lucumt.info/posts/download-big-file-using-springmvc/</link>
      <pubDate>Sun, 20 Mar 2016 16:41:29 +0800</pubDate>
      
      <guid>http://lucumt.info/posts/download-big-file-using-springmvc/</guid>
      <description>&lt;p&gt;文件的上传和下载是Web系统中的一个很普通的功能，实现的方式也有很多种，如利用 &lt;strong&gt;&lt;a href=&#34;https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html&#34;&gt;java.io&lt;/a&gt;&lt;/strong&gt; 下面的各种IO类自己实现，或者利用 &lt;strong&gt;&lt;a href=&#34;https://commons.apache.org/proper/commons-io/&#34;&gt;Commons IO&lt;/a&gt;&lt;/strong&gt; 包中的 &lt;strong&gt;&lt;em&gt;FileUtils&lt;/em&gt;&lt;/strong&gt; 、 &lt;strong&gt;&lt;em&gt;IOUtils&lt;/em&gt;&lt;/strong&gt; 类中封装好的方法直接调用。由于目前我所开发的系统采用了 &lt;strong&gt;&lt;a href=&#34;http://docs.spring.io/autorepo/docs/spring/3.2.x/spring-framework-reference/html/mvc.html&#34;&gt;SpringMVC&lt;/a&gt;&lt;/strong&gt; 来作为项目的MVC实现，所以很自然的采用 &lt;strong&gt;&lt;a href=&#34;http://docs.spring.io/autorepo/docs/spring/3.2.x/spring-framework-reference/html/mvc.html&#34;&gt;SpringMVC&lt;/a&gt;&lt;/strong&gt;内置的API进行文件的下载，但在实际使用过程中发现其对大文件的下载支持不太好，现把解决方案记录如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @RequestMapping(&amp;quot;downloadRequireDocument&amp;quot;)
    public ResponseEntity&amp;lt;byte[]&amp;gt; downloadRequireDocument(String fileId,String fileName,String fileType,
         HttpServletRequest request) throws IOException{
	    HttpHeaders headers=new HttpHeaders();
	    String filePath=fileName+fileId+&amp;quot;.&amp;quot;+fileType;
	    headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
	    headers.setContentDispositionFormData(&amp;quot;attachment&amp;quot;,URLEncoder.encode(fileName,&amp;quot;UTF-8&amp;quot;)+&amp;quot;.&amp;quot;+fileType);
	    File downloadFile=new File(request.getSession().getServletContext().getRealPath(File.separator)   
             +FileConstants.REQUIREMENT_ASSOCIATE_DOCUNENT+filePath);
	    return new ResponseEntity&amp;lt;byte[]&amp;gt;(FileUtils.readFileToByteArray(downloadFile),headers,HttpStatus.CREATED);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该段代码在下载小文件时可以正常工作，但是当要下载的文件很大时（如几百M或上G），就会发生如下错误：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;java.lang.OutOfMemoryError: Java heap space
at org.apache.commons.io.output.ByteArrayOutputStream.toByteArray(ByteArrayOutputStream.java:271)
at org.apache.commons.io.IOUtils.toByteArray(IOUtils.java:219)
at org.apache.commons.io.FileUtils.readFileToByteArray(FileUtils.java:1136)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;去网上搜索 &lt;strong&gt;&lt;em&gt;java.lang.OutOfMemoryError: Java heap space&lt;/em&gt;&lt;/strong&gt; 这个错误时，一般都建议我们在tomcat中添加如下类似设置来提高JVM的配置:&lt;br /&gt;
&lt;code&gt;set JAVA_OPTS=%JAVA_OPTS% -server -Xms800m -Xmx800m -XX:MaxNewSize=256m -XX:MaxPermSize=256m&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;但即使按照把上面的参数配置都扩大一倍，在下载更大的文件时还是会遇到 &lt;strong&gt;&lt;em&gt;java.lang.OutOfMemoryError: Java heap space&lt;/em&gt;&lt;/strong&gt; 这个错误，上面的解决方法治标不治本。分析下异常堆栈可以发现问题产生的根源在于 &lt;em&gt;at org.apache.commons.io.FileUtils.readFileToByteArray(FileUtils.java:1136)&lt;/em&gt; 这行代码，&lt;strong&gt;&lt;em&gt;FileUtils.readFileToByteArray&lt;/em&gt;&lt;/strong&gt;  会把文件一次性读入内存中，要下载的文件越大，需要占用的内存也越大，当文件的大小超过JVM和Tomcat的内存配置时，&lt;strong&gt;&lt;em&gt;OutOfMemoryError&lt;/em&gt;&lt;/strong&gt; 这个问题就会不可避免的发生。弄清产生该问题的原因之后，解决的方法也很简单：&lt;strong&gt;不利用&lt;a href=&#34;https://commons.apache.org/proper/commons-io/&#34;&gt;Commons IO&lt;/a&gt;把文件一次性读入内存，而是利用普通的文件输出流按字节分段写入文件，把占用的内存固定在一个指定的范围内，从根本上避免内存占用过高的问题&lt;/strong&gt;,替代的代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;downloadRequireDocument&amp;quot;)
public void downloadRequireDocument(String fileId,String fileName,String fileType,
	HttpServletRequest request,HttpServletResponse response) throws IOException {
	String filePath = request.getSession().getServletContext().getRealPath(File.separator)
	+FileConstants.REQUIREMENT_ASSOCIATE_DOCUNENT+fileName+fileId+&amp;quot;.&amp;quot;+fileType;
	fileName = URLEncoder.encode(fileName.trim(),&amp;quot;UTF-8&amp;quot;)+&amp;quot;.&amp;quot;+fileType;
	InputStream is = new FileInputStream(filePath);
	response.setHeader(&amp;quot;Content-Disposition&amp;quot;,&amp;quot;attachment;filename=&amp;quot;+fileName);
	int read =0;
	byte[] bytes = new byte[2048];
	OutputStream os = response.getOutputStream();
	while((read = is.read(bytes))!=-1){
	os.write(bytes, 0, read);
	}
	os.flush();
	os.close();
	is.close();
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>利用Spring和JUnit进行单元测试</title>
      <link>http://lucumt.info/posts/using-junit-in-spring/</link>
      <pubDate>Sun, 20 Mar 2016 16:27:21 +0800</pubDate>
      
      <guid>http://lucumt.info/posts/using-junit-in-spring/</guid>
      <description>

&lt;p&gt;在进行Java程序开发时，我们偶尔会被要求使用&lt;strong&gt;&lt;a href=&#34;http://junit.org/&#34;&gt;JUnit&lt;/a&gt;&lt;/strong&gt;进行单元测试来确保我们所写的程序逻辑是正确的。一个良好的单元测试应该具备 &lt;strong&gt;&lt;em&gt;覆盖度高，可重复执行，单一性&lt;/em&gt;&lt;/strong&gt; 等特点。本文主要关注&lt;strong&gt;&lt;em&gt;可重复执行&lt;/em&gt;&lt;/strong&gt; ，在Web开发中，大部分方法都会使数据库的记录发生变化，为了能够重复执行，必须利用&lt;strong&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1&#34;&gt;数据库事务&lt;/a&gt;&lt;/strong&gt; 来进行 &lt;strong&gt;&lt;em&gt;回滚&lt;/em&gt;&lt;/strong&gt; 从而达到重复执行的目的。最原始的方法是利用 &lt;strong&gt;&lt;a href=&#34;https://docs.oracle.com/javase/7/docs/api/java/sql/Connection.html&#34;&gt;java.sql.Connection&lt;/a&gt;&lt;/strong&gt; 类的 &lt;strong&gt;&lt;em&gt;commit()&lt;/em&gt;&lt;/strong&gt; 或 &lt;strong&gt;&lt;em&gt;rollback()&lt;/em&gt;&lt;/strong&gt; 方法来在每个单元测试方法中手动的进行提交或回滚，此种方式使得单元测试代码嵌入了与实际业务逻辑无关的数据库操作事务控制代码。利用&lt;strong&gt;&lt;a href=&#34;https://spring.io/&#34;&gt;Spring&lt;/a&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;a href=&#34;http://junit.org/&#34;&gt;JUnit&lt;/a&gt;&lt;/strong&gt;通过注解的方式我们可以很容易的对单元测试中的数据库操作进行事务控制。&lt;/p&gt;

&lt;h1 id=&#34;所有方法都回滚:ca90282e7eb1ee4fd1fb33a78c3a6535&#34;&gt;所有方法都回滚&lt;/h1&gt;

&lt;p&gt;在该单元测试类的开头加上 &lt;em&gt;@TransactionConfiguration(defaultRollback=true)&lt;/em&gt; 可以确保该类中的所有方法在执行完毕之后默认都进行回滚。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.hirain.testmanagement.service.test;
 
import static org.junit.Assert.assertEquals;
 
import java.util.Date;
 
import javax.inject.Inject;
 
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.transaction.TransactionConfiguration;
import org.springframework.transaction.annotation.Transactional;
 
import com.hirain.testmanagement.common.util.StringUtil;
import com.hirain.testmanagement.model.ProjectModel;
import com.hirain.testmanagement.service.IProjectService;
 
@RunWith(SpringJUnit4ClassRunner.class)
@Transactional
@TransactionConfiguration(defaultRollback=true)
@ContextConfiguration(&amp;quot;classpath:spring/spring-context-*.xml&amp;quot;)
public class ProjectServiceTest{
 
	@Inject
	private IProjectService projectService;
	   
	@Test
	@Transactional
	public void testAddProject(){
	  ProjectModel pModel=new ProjectModel();
	  String projectId=StringUtil.getUUID();
	  pModel.setId(projectId);
	  pModel.setName(&amp;quot;汽车电子测试管理系统&amp;quot;);
	  pModel.setAlias(&amp;quot;INTA&amp;quot;);
	  pModel.setLastModifyTime(new Date());
	  pModel.setLastModifyUser(&amp;quot;6e518d0819d14148ae489f76dad80967&amp;quot;);
	  pModel.setCreateTime(new Date());
	  pModel.setCreateUser(&amp;quot;cface18d5fac11e28c68c89cdca4c015&amp;quot;);
	  projectService.addProject(pModel);
	  assertEquals(&amp;quot;Add project failed!&amp;quot;,projectService.getProject(projectId).getName(),pModel.getName());
	}
 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;指定方法回滚:ca90282e7eb1ee4fd1fb33a78c3a6535&#34;&gt;指定方法回滚&lt;/h1&gt;

&lt;p&gt;若想只对某个特定的方法进行回滚，需要在该单元测试类的开头去掉 &lt;em&gt;@TransactionConfiguration(defaultRollback=true)&lt;/em&gt; ，同时在对应的方法上加上注解声明 &lt;em&gt;@Rollback(true)&lt;/em&gt; 即可达到目的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.hirain.testmanagement.service.test;
 
import static org.junit.Assert.assertEquals;
 
import java.util.Date;
 
import javax.inject.Inject;
 
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.annotation.Rollback;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.transaction.annotation.Transactional;
 
import com.hirain.testmanagement.common.util.StringUtil;
import com.hirain.testmanagement.model.ProjectModel;
import com.hirain.testmanagement.service.IProjectService;
 
@RunWith(SpringJUnit4ClassRunner.class)
@Transactional
@ContextConfiguration(&amp;quot;classpath:spring/spring-context-*.xml&amp;quot;)
public class ProjectServiceTest{
 
	@Inject
	private IProjectService projectService;
	   
	@Test
	@Rollback(true)
	public void testAddProject(){
	  ProjectModel pModel=new ProjectModel();
	  String projectId=StringUtil.getUUID();
	  pModel.setId(projectId);
	  pModel.setName(&amp;quot;汽车电子测试管理系统&amp;quot;);
	  pModel.setAlias(&amp;quot;INTA&amp;quot;);
	  pModel.setLastModifyTime(new Date());
	  pModel.setLastModifyUser(&amp;quot;6e518d0819d14148ae489f76dad80967&amp;quot;);
	  pModel.setCreateTime(new Date());
	  pModel.setCreateUser(&amp;quot;cface18d5fac11e28c68c89cdca4c015&amp;quot;);
	  projectService.addProject(pModel);
	  assertEquals(&amp;quot;Add project failed!&amp;quot;,projectService.getProject(projectId).getName(),pModel.getName());
	}
 
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>利用Spring Security动态的改变权限</title>
      <link>http://lucumt.info/posts/update-authority-dynamic-using-spring-security/</link>
      <pubDate>Sun, 20 Mar 2016 16:05:52 +0800</pubDate>
      
      <guid>http://lucumt.info/posts/update-authority-dynamic-using-spring-security/</guid>
      <description>&lt;p&gt;利用 &lt;strong&gt;&lt;a href=&#34;http://projects.spring.io/spring-security/&#34;&gt;Spring Security&lt;/a&gt;&lt;/strong&gt; 来管理我们的web程序时，通常需要在&lt;strong&gt;&lt;em&gt;UserDetailsService&lt;/em&gt;&lt;/strong&gt; 接口中的 &lt;strong&gt;&lt;em&gt;loadUserByUsername&lt;/em&gt;&lt;/strong&gt; 方法中来初始化权限信息,但 &lt;strong&gt;&lt;em&gt;UserDetailsService&lt;/em&gt;&lt;/strong&gt; 一般用于登录验证，这也意味着用户的权限在登录过程中就会被计算出来。通常情况下由于用户的权限很少发生变化，在登录过程中计算出用户权限是合理的，但有些情况下，我们需要在中途来动态的改变用户的权限，此时我们可以利用 &lt;strong&gt;&lt;a href=&#34;http://projects.spring.io/spring-security/&#34;&gt;Spring Security&lt;/a&gt;&lt;/strong&gt; 提供的API来实现。&lt;/p&gt;

&lt;p&gt;以我自己的项目为例，&lt;strong&gt;&lt;em&gt;UserDetailsService&lt;/em&gt;&lt;/strong&gt; 接口中的 &lt;strong&gt;&lt;em&gt;loadUserByUsername&lt;/em&gt;&lt;/strong&gt; 具体实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
       UserModel userModel=userDao.getUserByUsername(username);
       if(userModel==null)
  throw new UsernameNotFoundException(username+&amp;quot; not exist!&amp;quot;);
       List&amp;lt;GrantedAuthority&amp;gt; userAuthList=new ArrayList&amp;lt;GrantedAuthority&amp;gt;();
       List&amp;lt;AuthorityVO&amp;gt; authList=authorityDao.queryAuthorityByUserId(userModel.getId());
       for(AuthorityVO authVO:authList){
   userAuthList.add(new SimpleGrantedAuthority(authVO.getAuthName()));
       }
       UserDetails userDetails=new User(userModel.getUsername(),userModel.getPassword(),true,true,true,true,userAuthList);
       return userDetails;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码会一次性的把用户权限查询出来然后放入特定的 &lt;strong&gt;session&lt;/strong&gt; 中，但是 &lt;strong&gt;&lt;em&gt;UserDetailService&lt;/em&gt;&lt;/strong&gt; 方法一般只在用户登录web系统成功时才会被调用一次，使用范围较为局限，有时候我们需要在用户使用的过程中动态的改变用户的权限（譬如在我自己的项目中，当用户选中不同的项目之后，不同的项目对应不同的权限）。利用 &lt;strong&gt;&lt;a href=&#34;http://projects.spring.io/spring-security/&#34;&gt;Spring Security&lt;/a&gt;&lt;/strong&gt; 来管理权限信息时，用户的权限本质上是存储在一个 &lt;strong&gt;session&lt;/strong&gt; 中，只不过被&lt;strong&gt;&lt;a href=&#34;http://projects.spring.io/spring-security/&#34;&gt;Spring Security&lt;/a&gt;&lt;/strong&gt;进行了进一步的封装而已。所以若想动态的改变用户的权限，我们只需要将用户的信息重新存储到 &lt;strong&gt;session&lt;/strong&gt; 中即可，具体代码如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  List&amp;lt;GrantedAuthority&amp;gt; authList=new ArrayList&amp;lt;GrantedAuthority&amp;gt;();//用于存储修改之后的权限列表
  authList.add(new SimpleGrantedAuthority(&amp;quot;addUser&amp;quot;));
  authList.add(new SimpleGrantedAuthority(&amp;quot;editUser&amp;quot;));
  SecurityContext context=SecurityContextHolder.getContext();
  UserDetails userDetails=(UserDetails) context.getAuthentication().getPrincipal();
  Authentication auth=new UsernamePasswordAuthenticationToken(userDetails,userDetails.getPassword(),authList);
  context.setAuthentication(auth); //重新设置上下文中存储的用户权限
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>在Spring中利用Mock对HttpServletRequest进行单元测试</title>
      <link>http://lucumt.info/posts/using-mock-test-http-servlet-request/</link>
      <pubDate>Sat, 19 Mar 2016 22:43:47 +0800</pubDate>
      
      <guid>http://lucumt.info/posts/using-mock-test-http-servlet-request/</guid>
      <description>

&lt;h1 id=&#34;编写单元测试时的注意事项:ce3acd839c9974eb09add799db7e87e2&#34;&gt;编写单元测试时的注意事项&lt;/h1&gt;

&lt;p&gt;根据软件开发过程中的&lt;strong&gt;&lt;em&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Test-driven_development&#34;&gt;TDD&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; 理论，在我们编写自己的代码时，要尽量使得该代码能够进行单元测试。为了能够使得代码可以进行单元测试，我们在给接口或方法传入参数时要尽量传入简单参数，避免传入 &lt;strong&gt;&lt;em&gt;HttpServletRequest&lt;/em&gt;&lt;/strong&gt; , &lt;strong&gt;&lt;em&gt;ServletContext&lt;/em&gt;&lt;/strong&gt; 等和web上下文相关的复杂对象。但仍有部分情况下基于代码简洁性和可维护性的考虑，我们需要传入 &lt;strong&gt;&lt;em&gt;HttpServletRequest&lt;/em&gt;&lt;/strong&gt; 对象，此时对此类方法进行&lt;strong&gt;&lt;a href=&#34;http://junit.org/&#34;&gt;JUnit&lt;/a&gt;&lt;/strong&gt;单元测试时会较为困难，本文介绍一种在&lt;strong&gt;&lt;a href=&#34;https://spring.io/&#34;&gt;Spring&lt;/a&gt;&lt;/strong&gt;中通过&lt;strong&gt;&lt;a href=&#34;http://mockito.org/&#34;&gt;Mock&lt;/a&gt;&lt;/strong&gt;来模拟&lt;strong&gt;&lt;em&gt;HttpServletRequest&lt;/em&gt;&lt;/strong&gt; 对象进行&lt;strong&gt;&lt;a href=&#34;http://junit.org/&#34;&gt;JUnit&lt;/a&gt;&lt;/strong&gt;单元测试的方法。&lt;/p&gt;

&lt;p&gt;假设在 &lt;strong&gt;&lt;em&gt;HttpServletRequest&lt;/em&gt;&lt;/strong&gt; 中有一个userId字符串对象，我们想在queryUserById方法中调用该参数来获取用户信息，则正确的做法应如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  String userId = request.getAttribute(&amp;quot;userId&amp;quot;).toString();//先获取userId对象
  queryUserById(userId);//然后将获取的userId传入对应方法

  public User queryUserById(String userId){//相关该方法
       User userModel = userDao.findById(userId);
       return userModel;
  }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请尽量避免使用第二种方式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  queryUserById(request);//直接传入request对象
  
  public User queryUserById(HttpServletRequest request){//相关方法
       String userId = request.getAttribute(&amp;quot;userId&amp;quot;).toString();//在该方法内部获取userId
 
       User userModel = userDao.findById(userId);
       return userModel;
  }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;若采用第一种方法，我么在进行单元测试时，可以很容易的自己制造一个String字符串来代表userId进行测试，但当采用第二种方法后，在进行单元测试时我们是比较难以模拟一个 &lt;strong&gt;HttpServletRequest&lt;/strong&gt; 对象，从而影响我们的测试。&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;spring和mock在单元测试中的使用:ce3acd839c9974eb09add799db7e87e2&#34;&gt;Spring和Mock在单元测试中的使用&lt;/h1&gt;

&lt;p&gt;在某些方法中，为了减少代码量和提高程序的可读性，我们有时候需要直接传入 &lt;strong&gt;&lt;em&gt;HttpServletRequest&lt;/em&gt;&lt;/strong&gt; 或 &lt;strong&gt;&lt;em&gt;ServletContext&lt;/em&gt;&lt;/strong&gt; 对象，如果我们想对这种方法进行测试，可以利用&lt;strong&gt;&lt;a href=&#34;http://mockito.org/&#34;&gt;Mock&lt;/a&gt;&lt;/strong&gt;来模拟相关的对象。&lt;/p&gt;

&lt;p&gt;由于&lt;strong&gt;&lt;a href=&#34;https://spring.io/&#34;&gt;Spring&lt;/a&gt;&lt;/strong&gt;自身已经整合了&lt;strong&gt;&lt;a href=&#34;http://mockito.org/&#34;&gt;Mock&lt;/a&gt;&lt;/strong&gt;相关的类，故在此处展示一个示例代码，以供参考:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.File;
 
import org.junit.Test;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.mock.web.MockServletContext;
 
public class SpringMockTest {
 
@Test
public void testHttpServletRequest(){
	String realPath =&amp;quot;file:D:\\Java\\apache-tomcat-7.0.23\\webapps\\tmn&amp;quot;;
	//模拟ServletContext,同时初始化realPath，注意要有file:前缀否则会报错
	MockServletContext context = new MockServletContext(realPath);
	//获取realPath
	System.out.println(context.getRealPath(File.separator));
	//模拟HttpServletRequest
	MockHttpServletRequest request = new MockHttpServletRequest(context);
	//通过HttpServletRequest来获取realPath
	System.out.println(request.getSession().getServletContext().getRealPath(File.separator));
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意:请在上下文路径的字符串前面加上 &lt;strong&gt;file:&lt;/strong&gt; 前缀，否则程序会报错。如上面的程序，realPath的值应为 &lt;em&gt;file:D:\Java\apache-tomcat-7.0.23\webapps\tmn&lt;/em&gt; ，若去掉 &lt;em&gt;file:&lt;/em&gt; 前缀，改为 &lt;em&gt;D:\Java\apache-tomcat-7.0.23\webapps\tmn&lt;/em&gt; ，则程序会报错。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mediawiki添加回到顶部的方法</title>
      <link>http://lucumt.info/posts/mediawiki-back-to-top/</link>
      <pubDate>Fri, 18 Mar 2016 23:14:59 +0800</pubDate>
      
      <guid>http://lucumt.info/posts/mediawiki-back-to-top/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://www.mediawiki.org/wiki/MediaWiki&#34;&gt;Mediawiki&lt;/a&gt;&lt;/strong&gt;是&lt;strong&gt;&lt;a href=&#34;https://www.wikipedia.org/&#34;&gt;维基百科&lt;/a&gt;&lt;/strong&gt;系统所采用的框架，适合于需要快速搭建知识分享的场合。采用&lt;strong&gt;&lt;a href=&#34;https://www.mediawiki.org/wiki/MediaWiki&#34;&gt;Mediawiki&lt;/a&gt;&lt;/strong&gt;生成的知识共享平台和&lt;strong&gt;&lt;a href=&#34;https://www.wikipedia.org/&#34;&gt;维基百科&lt;/a&gt;&lt;/strong&gt;的操作与使用类似，都支持采用&lt;strong&gt;&lt;a href=&#34;https://zh.wikipedia.org/zh-cn/Markdown&#34;&gt;Markdown&lt;/a&gt;&lt;/strong&gt;语法来编辑。在有些时候，某些词条的内容很长，使得浏览器出现了滚动条，如果能仿照微博等网站添加一个&lt;strong&gt;&lt;em&gt;回到顶部&lt;/em&gt;&lt;/strong&gt;的功能，将会给我们的使用带来很大的便利，本文介绍一种实现方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;以&lt;strong&gt;&lt;a href=&#34;https://www.mediawiki.org/wiki/MediaWiki&#34;&gt;Mediawiki&lt;/a&gt;&lt;/strong&gt;管理员身份登录mediawiki,在搜索栏输入MediaWiki:Common.js,然后输入如下代码并保存：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/* 此处的JavaScript将加载于所有用户每一个页面。 */
$(window).scroll(function(){
   if($(window).scrollTop()&amp;gt;100){
    $(&amp;quot;.back-to-top&amp;quot;).fadeIn(1000);
  }else{
    $(&amp;quot;.back-to-top&amp;quot;).fadeOut(1000);
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;在mediawiki\skins\Vector.php中的第252行添加如下代码：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;  &amp;lt;div class=&amp;quot;back-to-top&amp;quot; onClick=&amp;quot;$(&#39;html,body&#39;).animate({scrollTop:0},500);&amp;quot;&amp;gt;
     &amp;lt;span&amp;gt;返回顶部&amp;lt;/span&amp;gt;
  &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;在mediawiki\skins\vector\screen.css的最后添加如下代码：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.back-to-top {
    position: fixed;
    bottom: 6em;
    right: 3em;
    background-color: rgba(46, 46, 46, 0.8);
    text-align: center;
    padding: 5px 6px;
    color: #eee;
    -webkit-border-radius: 3px;
    -moz-border-radius: 3px;
    border-radius: 3px;
    cursor: pointer;
    display: none;
}
 
.back-to-top:hover {
    background: rgba(0, 221, 255, 0.8);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;当页面的高度超出限制时，就会出现“返回顶部”的悬浮框，效果图如下：&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://ooo.0o0.ooo/2016/03/18/56ec1de1a77ac.png&#34; alt=&#34;Back to top.PNG&#34; title=&#34;返回顶部示例图片&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[译] Java Volatile 关键字详解</title>
      <link>http://lucumt.info/posts/java-volatile-keyword/</link>
      <pubDate>Mon, 07 Mar 2016 18:03:18 +0800</pubDate>
      
      <guid>http://lucumt.info/posts/java-volatile-keyword/</guid>
      <description>

&lt;p&gt;本文翻译自 &lt;strong&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/volatile.html&#34;&gt;Java Volatile Keyword&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Java关键字&lt;code&gt;volatile&lt;/code&gt;用于将一个Java变量标记为 &lt;em&gt;在主内中存储&lt;/em&gt; ，更准确的解释为：每次读取一个&lt;code&gt;volatile&lt;/code&gt;变量时将从电脑的主内存中读取而不是从CPU缓存中读取，每次对一个&lt;code&gt;volatile&lt;/code&gt;变量进行写操作时，将会写入到主内存中而不是写入到CPU缓存中。&lt;/p&gt;

&lt;p&gt;事实上，从Java5之后，&lt;code&gt;volatile&lt;/code&gt;关键字不仅仅可以用来确保&lt;code&gt;volatile&lt;/code&gt;变量是写入到主内存和从主内存读取数据，我会在下面的章节进行详细的介绍：&lt;/p&gt;

&lt;h1 id=&#34;volatile变量可见性保证:a750225f0d61f6f6aa9de85e7ec295c8&#34;&gt;Volatile变量可见性保证&lt;/h1&gt;

&lt;p&gt;Java &lt;code&gt;volatile&lt;/code&gt;关键字确保了&lt;code&gt;volatile&lt;/code&gt;变量的修改在多线程中是可见的。这听起来有些抽象，接下来我将详细说明。&lt;/p&gt;

&lt;p&gt;在一个对非&lt;code&gt;volatile&lt;/code&gt;变量进行操作的多线程应用，由于性能的关系，当对这些变量进行读写时，每个线程都可能从主线程中拷贝变量到CPU缓存中。如果你的电脑不止一个CPU，每个线程可能会在不同的CPU上运行。这意味着，每个线程都可能将变量拷贝到不同的CPU的CPU缓存中，如下图所示：
&lt;img src=&#34;https://ooo.0o0.ooo/2016/03/07/56dd58a160db3.png&#34; alt=&#34;p1.png&#34; /&gt;
&lt;br /&gt;
对于&lt;code&gt;volatile&lt;/code&gt;变量而言，Java虚拟机(JVM)不能确保什么时候将数据从主内存读取到CPU缓存以及什么时候将CPU缓存的数据写入到主内存中。而这可能会引起一些问题，我将稍后解释。&lt;/p&gt;

&lt;p&gt;假设两个或更多的线程对下面这个包含一个计数器的共享变量拥有访问权限：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SharedObject {
    public int counter = 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再次假设，只有Thread1会增加 &lt;em&gt;counter&lt;/em&gt; 变量的值，但是Thread1和Thread2都能在任意时刻读取 &lt;em&gt;counter&lt;/em&gt; 变量的值。&lt;/p&gt;

&lt;p&gt;如果 &lt;em&gt;couner&lt;/em&gt; 变量没有声明为&lt;code&gt;volatile&lt;/code&gt;将无法保证在何时把CPU缓存中的值写入主内存中。这意味着 &lt;em&gt;counter&lt;/em&gt; 变量在CPU缓存中的值可能会与主内存中的值不一样，如下所示：&lt;br /&gt;
&lt;img src=&#34;https://ooo.0o0.ooo/2016/03/07/56dd58a7387d7.png&#34; alt=&#34;p2.png&#34; /&gt;
&lt;br /&gt;
造成线程不能获取变量最新值得原因为变量值没有被其它线程及时写回主内存中，这就是所谓的可见性问题。某个线程的更新对其它线程不可见。&lt;/p&gt;

&lt;p&gt;将 &lt;em&gt;counter&lt;/em&gt; 变量声明为&lt;code&gt;volatile&lt;/code&gt;之后，所有对 &lt;em&gt;counter&lt;/em&gt; 变量的写操作会立即写入主内存中，同样，所有对 &lt;em&gt;counter&lt;/em&gt; 变量的读操作都会从主内存中读取数据。下面的代码块展示了如何将 &lt;em&gt;counter&lt;/em&gt; 变量声明为&lt;code&gt;volatile&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SharedObject {
    public volatile int counter = 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此定义一个&lt;code&gt;volatile&lt;/code&gt;变量可以保证写变量的操作对于其它线程可见。&lt;/p&gt;

&lt;h1 id=&#34;volatile先行发生原则:a750225f0d61f6f6aa9de85e7ec295c8&#34;&gt;Volatile先行发生原则&lt;/h1&gt;

&lt;p&gt;从Java5之后&lt;code&gt;volatile&lt;/code&gt;关键字不仅能用于确保变量从主内存中读取和写入，事实上，&lt;code&gt;volatile&lt;/code&gt;关键字还有如下作用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果线程A写入了一个&lt;code&gt;volatile&lt;/code&gt;变量然后线程B读取了这个相同的&lt;code&gt;volatile&lt;/code&gt;变量，那么所有在线程A写之前对其可见的变量，在线程B读取这个&lt;code&gt;volatile&lt;/code&gt;之后也会对其可见。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;volatile&lt;/code&gt;变量的读写指令不能被JVM重排序（出于性能的考虑，JVM可能会对指令重排序如果JVM检测到指令排序不会对程序运行产生变化）。
前后的指令可以重排序，但是&lt;code&gt;volatile&lt;/code&gt;变量的读和写不能与这些重排序指令混在一起。任何跟随在&lt;code&gt;volatile&lt;/code&gt;变量读写之后的指令都会确保只有在变量的读写操作之后才能执行。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上述说明需要更进一步的解释。&lt;/p&gt;

&lt;p&gt;当一个线程向一个&lt;code&gt;volatile&lt;/code&gt;变量写操作，此时不仅这个&lt;code&gt;volatile&lt;/code&gt;变量自身会写入主内存，所有这个&lt;code&gt;volatile&lt;/code&gt;变量写入之前受影响发生改变的变量也会刷写入主内存。当一个线程向一个&lt;code&gt;volatile&lt;/code&gt;变量读操作时它同样也会从主内存中读取所有和这个&lt;code&gt;volatile&lt;/code&gt;变量一起刷写入主内存的变量。&lt;/p&gt;

&lt;p&gt;看看下面这个示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Thread A:
    sharedObject.nonVolatile = 123;
    sharedObject.counter     = sharedObject.counter + 1;

Thread B:
    int counter     = sharedObject.counter;
    int nonVolatile = sharedObject.nonVolatile;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于线程A在写操作&lt;code&gt;volatile&lt;/code&gt;变量 &lt;em&gt;sharedObject.counter&lt;/em&gt; 之前写操作非&lt;code&gt;volatile&lt;/code&gt;变量 &lt;em&gt;sharedObject.nonVolatile&lt;/em&gt; ，因而当线程A写操作变量 &lt;em&gt;sharedObject.counter&lt;/em&gt; 后,变量 &lt;em&gt;sharedObject.nonVolatile&lt;/em&gt; 和 &lt;em&gt;sharedObject.counter&lt;/em&gt; 都被写入主内存。&lt;/p&gt;

&lt;p&gt;由于线程B以读取&lt;code&gt;volatile&lt;/code&gt;变量 &lt;em&gt;sharedObject.counter&lt;/em&gt; 开始，因而变量 &lt;em&gt;sharedObject.counter&lt;/em&gt; 和变量&lt;em&gt;sharedObject.nonVolatile&lt;/em&gt; 都会被写入线程B所使用的CPU缓存中。当线程B读取 &lt;em&gt;sharedObject.nonVolatile&lt;/em&gt; 变量时，它将能看见被线程A写入的变量。&lt;/p&gt;

&lt;p&gt;开发人员可以利用这个扩展的可见性来优化线程之间变量的可见性。不同于把每个变量都设置为&lt;code&gt;volatile&lt;/code&gt;，此时只有少部分变量需要声明为&lt;code&gt;volatile&lt;/code&gt;。下面是一个利用此规则编写的简单示例程序 &lt;em&gt;Exchanger&lt;/em&gt; ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Exchanger {

    private Object   object       = null;
    private volatile hasNewObject = false;

    public void put(Object newObject) {
        while(hasNewObject) {
            //等待，不覆盖已经存在的新对象
        }
        object = newObject;
        hasNewObject = true; //volatile写入
    }

    public Object take(){
        while(!hasNewObject){ //volatile读取
            //等待，不获取旧的对象（或null对象）
        }
        Object obj = object;
        hasNewObject = false; //volatile写入
        return obj;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;线程A随时可能会通过调用 &lt;em&gt;put()&lt;/em&gt; 方法增加对象，线程B随时可能会通过调用 &lt;em&gt;take()&lt;/em&gt; 方法获取对象。只要线程A只调用 &lt;em&gt;put()&lt;/em&gt; ，线程B只调用 &lt;em&gt;take()&lt;/em&gt; ,这个 &lt;em&gt;Exchanger&lt;/em&gt; 就可以通过一个&lt;code&gt;volatile&lt;/code&gt;变量正常工作（排除&lt;code&gt;synchronized&lt;/code&gt;代码块的使用）。&lt;/p&gt;

&lt;p&gt;然而，JVM可能会重排序Java指令来优化性能，如果JVM可以通过不改变这些重排序指令的语义来实现此功能。如果JVM调换了 &lt;em&gt;put()&lt;/em&gt; 和 &lt;em&gt;take()&lt;/em&gt; 中的读和写的指令，会发生什么呢？如果 &lt;em&gt;put()&lt;/em&gt; 真的像下面这样执行会出现什么情况呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;while(hasNewObject) {
    //等待，不覆盖已经存在的新对象
}
hasNewObject = true; //volatile写入
object = newObject;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请注意此时对于&lt;code&gt;volatile&lt;/code&gt;变量 &lt;em&gt;hasNewObject&lt;/em&gt; 的写操作会在新变量的实际设置前先执行，而这在JVM看来可能会完全合法。两个写操作指令的值不再依赖于对方。&lt;/p&gt;

&lt;p&gt;但是，对于执行指令重排序可能会损害 &lt;em&gt;object&lt;/em&gt; 变量的可见性。首先，线程B可能会在线程A对 &lt;em&gt;object&lt;/em&gt; 真实的写入一个值到object之前读取到 &lt;em&gt;hasNewObject&lt;/em&gt; 的值为true。其次,现在甚至不能保证什么时候写入 &lt;em&gt;object&lt;/em&gt; 的新值会刷写入主内存（好吧，下次线程A在其它地方写入&lt;code&gt;volatile&lt;/code&gt;变量。。。）&lt;/p&gt;

&lt;p&gt;为了阻止上面所述的这种情况发生，&lt;code&gt;volatile&lt;/code&gt;关键字提供了一个 &lt;strong&gt;先行发生原则&lt;/strong&gt;。先行发生保证确保对于&lt;code&gt;volatile&lt;/code&gt;变量的读写指令不会被重排序。程序运行中前后的指令可能会被重排序，但是&lt;code&gt;volatile&lt;/code&gt;读写指令不能和它前后的任何指令重新排序。&lt;/p&gt;

&lt;p&gt;看看下面这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;sharedObject.nonVolatile1 = 123;
sharedObject.nonVolatile2 = 456;
sharedObject.nonVolatile3 = 789;

sharedObject.volatile     = true; //a volatile variable

int someValue1 = sharedObject.nonVolatile4;
int someValue2 = sharedObject.nonVolatile5;
int someValue3 = sharedObject.nonVolatile6;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JVM可能会重新排序前3条指令，只要它们都先发生于&lt;code&gt;volatile&lt;/code&gt;写指令（它们都必须在&lt;code&gt;volatile&lt;/code&gt;写指令之前执行）。&lt;/p&gt;

&lt;p&gt;同样的，JVM可能会重新排序最后3条指令，只要&lt;code&gt;volatile&lt;/code&gt;写指令先行发生于它们，这3条指令都不能被重新排序到&lt;code&gt;volatile&lt;/code&gt;指令的前面。&lt;/p&gt;

&lt;p&gt;这就是&lt;code&gt;volatile&lt;/code&gt;先行发生原则的基本含义。&lt;/p&gt;

&lt;h1 id=&#34;volatile并不是万能的:a750225f0d61f6f6aa9de85e7ec295c8&#34;&gt;Volatile并不是万能的&lt;/h1&gt;

&lt;p&gt;尽管&lt;code&gt;volatile&lt;/code&gt;关键字确保了所有对于&lt;code&gt;volatile&lt;/code&gt;变量的读操作都是直接从主内存中读取的，所有对于&lt;code&gt;volatile&lt;/code&gt;变量的写操作都是直接写入主内存的，但仍有一些情况只定义一个&lt;code&gt;volatile&lt;/code&gt;变量是不够的。&lt;/p&gt;

&lt;p&gt;在前面的场景中，线程1对共享变量&lt;code&gt;counter&lt;/code&gt;写入操作，声明 &lt;em&gt;counter&lt;/em&gt; 变量为&lt;code&gt;volatile&lt;/code&gt;之后就能够确保线程2总是可以看见最新的写入值。&lt;/p&gt;

&lt;p&gt;事实上，如果写入该变量的值不依赖于它前面的值，多个线程甚至可以在写入一个共享的&lt;code&gt;volatile&lt;/code&gt;变量时仍然能够持有在主内存中存储的正确值。换句话解释为，如果一个线程在写入volatile共享变量时，不需要先读取该变量的值以计算下一个值。&lt;/p&gt;

&lt;p&gt;一旦一个线程需要首先读取一个&lt;code&gt;volatile&lt;/code&gt;变量的值，然后基于该值产生&lt;code&gt;volatile&lt;/code&gt;共享变量的下一个值，那么该&lt;code&gt;volatile&lt;/code&gt;变量将不再能够完全确保正确的可见性。在读取&lt;code&gt;volatile&lt;/code&gt;变量和写入它的新值这个很短的时间间隔内，产生了一个 &lt;strong&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections.html&#34;&gt;竞争条件&lt;/a&gt;&lt;/strong&gt; :多个线程可能会读取&lt;code&gt;volatile&lt;/code&gt;变量的相同值，然后产生新值并写入主内存，这样将会覆盖互相的值。&lt;/p&gt;

&lt;p&gt;这种多个线程同时增加相同计数器的场景正是&lt;code&gt;volatile&lt;/code&gt;变量不适用的地方，接下来的部分进行了更详细的解释。&lt;/p&gt;

&lt;p&gt;假设线程1读取一个值为0的共享变量 &lt;em&gt;counter&lt;/em&gt; 到它的CPU缓存中，将它加1但是并没有将增加后的值写入主内存中。线程2可能会从主内存中读取同一个 &lt;em&gt;counter&lt;/em&gt; 变量，其值仍然为0，同样不将其写入主内存中，就如下面的图片所展示的那样：&lt;br /&gt;
&lt;img src=&#34;https://ooo.0o0.ooo/2016/03/07/56dd58ae1cdfb.png&#34; alt=&#34;p3.png&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;线程1和线程2现在都没有同步，共享变量 &lt;em&gt;counter&lt;/em&gt; 的真实值应该是2，但是在每个线程的CPU缓存中，其值都为1，并且主内存中的值仍然是0。它成了一个烂摊子，即使这些线程终于它们对共享变量 &lt;em&gt;counter&lt;/em&gt; 的计算值写入到主内存中，&lt;em&gt;counter&lt;/em&gt; 的值仍然是错的。&lt;/p&gt;

&lt;h1 id=&#34;volatile的适用场景:a750225f0d61f6f6aa9de85e7ec295c8&#34;&gt;Volatile的适用场景&lt;/h1&gt;

&lt;p&gt;就像我在前面提到的那样，如果两个线程同时对一个共享变量进行读和写，那么仅用&lt;code&gt;volatile&lt;/code&gt;变量是不够的。在这种情况下，你需要使用&lt;code&gt;synchronized&lt;/code&gt;来确保关于该变量的读和写都是原子操作。读或写一个&lt;code&gt;volatile&lt;/code&gt;变量时并不会阻塞其它线程对该变量的读和写。在这种情况下必须用&lt;code&gt;synchronzied&lt;/code&gt;关键字来修饰你的关键代码。&lt;/p&gt;

&lt;p&gt;除了使用&lt;code&gt;synchronzied&lt;/code&gt;之外，你也可以使用 &lt;strong&gt;java.util.concurrent&lt;/strong&gt; 包中的一些原子数据类型，如 &lt;strong&gt;AtomicLong&lt;/strong&gt; ， &lt;strong&gt;AtomicReference&lt;/strong&gt; 等。&lt;/p&gt;

&lt;p&gt;当只有一个线程对一个&lt;code&gt;volatile&lt;/code&gt;变量进行读写而其它线程只读取该变量时，&lt;code&gt;volatile&lt;/code&gt;可以确保这些读线程读取到的是该变量的最新写入值。如果不声明该变量为&lt;code&gt;volatile&lt;/code&gt;，则不能这些读线程保证读取的是最新写入值。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Volatile&lt;/code&gt;关键字适用于32位变量和64位变量。&lt;/p&gt;

&lt;h1 id=&#34;volatile性能思考:a750225f0d61f6f6aa9de85e7ec295c8&#34;&gt;Volatile性能思考&lt;/h1&gt;

&lt;p&gt;由于&lt;code&gt;volatile&lt;/code&gt;变量的读和写都是直接从主内存中进行的，相对于CPU缓存，直接对主内存进行读写代价更高，
访问一个&lt;code&gt;volatile&lt;/code&gt;变量也会阻止指令重新排序，而指令排序也是一个常用的性能增强技术。因此，你应该在只有当你确实需要确保变量可见性的时候才使用&lt;code&gt;volatile&lt;/code&gt;变量。&lt;/p&gt;

&lt;p&gt;&amp;lt;&amp;ndash;终于翻译完了!&amp;ndash;&amp;gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Cannot run program &#34;mysqldump&#34;: CreateProcess error=2, The system cannot find the file specified</title>
      <link>http://lucumt.info/posts/can-not-run-program-mysqldump/</link>
      <pubDate>Thu, 03 Mar 2016 14:33:43 +0800</pubDate>
      
      <guid>http://lucumt.info/posts/can-not-run-program-mysqldump/</guid>
      <description>&lt;p&gt;项目中用到了&lt;code&gt;MySQL&lt;/code&gt;数据库的备份功能，通过调用&lt;code&gt;Java&lt;/code&gt;程序中的&lt;strong&gt;&lt;a href=&#34;http://docs.oracle.com/javase/6/docs/api/&#34;&gt;Runtime&lt;/a&gt;&lt;/strong&gt;来执行&lt;code&gt;mysqldump&lt;/code&gt;命令自动的生成相关的&lt;code&gt;MySQL&lt;/code&gt;数据库文件以供恢复之用。相关的代码如下:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;Runtime&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;runtime&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;Runtime&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #a6e22e&#34;&gt;getRuntime&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;String&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;mysqlCmd&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;mysqldump&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot; -u&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;username&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot; -p&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;password&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;+&lt;/span&gt; 
           &lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;  -h &amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;databaseAddress&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot; &amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;databaseName&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;Process&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;process&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;runtime&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #a6e22e&#34;&gt;exec&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;mysqlCmd&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;但是在客户那里实际使用时，有时候会出现在cmd中&lt;code&gt;MySQL&lt;/code&gt;命令可以正常识别但是程序不能正常执行的情况，报错信息如下:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;java&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #a6e22e&#34;&gt;io&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #a6e22e&#34;&gt;IOException&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;Cannot&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;run&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;program&lt;/span&gt; &lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;mysqldump&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;CreateProcess&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;error&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;The&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;system&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;cannot&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;find&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;the&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;file&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;specified&lt;/span&gt;
	&lt;span style=&#34;color: #f8f8f2&#34;&gt;at&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;java&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #a6e22e&#34;&gt;lang&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #a6e22e&#34;&gt;ProcessBuilder&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #a6e22e&#34;&gt;start&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;ProcessBuilder&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #a6e22e&#34;&gt;java&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #ae81ff&#34;&gt;460&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;)&lt;/span&gt;
	&lt;span style=&#34;color: #f8f8f2&#34;&gt;at&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;java&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #a6e22e&#34;&gt;lang&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #a6e22e&#34;&gt;Runtime&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #a6e22e&#34;&gt;exec&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;Runtime&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #a6e22e&#34;&gt;java&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #ae81ff&#34;&gt;593&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;)&lt;/span&gt;
	&lt;span style=&#34;color: #f8f8f2&#34;&gt;at&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;java&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #a6e22e&#34;&gt;lang&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #a6e22e&#34;&gt;Runtime&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #a6e22e&#34;&gt;exec&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;Runtime&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #a6e22e&#34;&gt;java&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #ae81ff&#34;&gt;431&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;)&lt;/span&gt;
	&lt;span style=&#34;color: #f8f8f2&#34;&gt;at&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;java&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #a6e22e&#34;&gt;lang&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #a6e22e&#34;&gt;Runtime&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #a6e22e&#34;&gt;exec&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;Runtime&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #a6e22e&#34;&gt;java&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #ae81ff&#34;&gt;328&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Google之后，在&lt;strong&gt;&lt;a href=&#34;http://stackoverflow.com/&#34;&gt;Stackoverflow&lt;/a&gt;&lt;/strong&gt;发现两个相关的问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/15850548/error-when-backing-up-mysql-database&#34;&gt;Error when backing up MYSQL database&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/13376132/backup-mysql-database-java-code&#34;&gt;backup mysql database java code&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;阅读之后，发现上面说问题产生的原因是&lt;code&gt;mysqldump&lt;/code&gt;命令无法识别，把&lt;code&gt;mysqldump&lt;/code&gt;可执行文件的路径加入PATH环境变量中即可解决问题。&lt;/p&gt;

&lt;p&gt;但当我在cmd中无论执行&lt;code&gt;mysql&lt;/code&gt;或&lt;code&gt;mysqldump&lt;/code&gt;命令时，都显示这两个命令可以正常执行：&lt;br /&gt;
&lt;img src=&#34;https://ooo.0o0.ooo/2016/03/03/56d7e3254c0a0.png&#34; alt=&#34;mysql1.png&#34; /&gt;
&lt;br /&gt;
在cmd中输出PATH环境变量时，也显示&lt;code&gt;MySQL&lt;/code&gt;的bin目录已经添加:&lt;br /&gt;
&lt;img src=&#34;https://ooo.0o0.ooo/2016/03/03/56d7e39ff3ab8.png&#34; alt=&#34;mysql2.png&#34; /&gt;
&lt;br /&gt;
即使重启电脑，上述通过&lt;code&gt;Java&lt;/code&gt;备份&lt;code&gt;MySQL&lt;/code&gt;的代码还是不能正常执行，但当在cmd中执行&lt;code&gt;mysql&lt;/code&gt;、&lt;code&gt;mysqldump&lt;/code&gt;命令或输出PATH环境变量时，结果任何上面图片中显示的一致。&lt;/p&gt;

&lt;p&gt;这下让我感到很困惑:&amp;nbsp;&lt;strong&gt;通过&lt;/strong&gt;&lt;code&gt;Java&lt;/code&gt;&lt;strong&gt;代码来执行&lt;/strong&gt;&lt;code&gt;mysqldump&lt;/code&gt;&lt;strong&gt;导出操作时去不能正常执行原因是&lt;/strong&gt;&lt;code&gt;MySQL&lt;/code&gt;&lt;strong&gt;的执行路径没有加到PATH环境变量中,但实际检查发现&lt;/strong&gt;&lt;code&gt;MySQL&lt;/code&gt;&lt;strong&gt;的环境变量设置正常，在命令行通过&lt;/strong&gt;&lt;code&gt;mysqldump&lt;/code&gt;&lt;strong&gt;导出sql文件可以成功操作!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;继续在网上搜索该问题的解决方案，得到的答案也都是&lt;code&gt;MySQL&lt;/code&gt;的执行路径没有加到PATH环境变量中去，问题依旧。。。&lt;/p&gt;

&lt;p&gt;正当我在为这个问题发愁时，测试部门有个同事的新&lt;code&gt;Win7&lt;/code&gt;电脑上利用我们的软件执行&lt;code&gt;MySQL&lt;/code&gt;备份时也出现了类似的问题，之前我还猜有可能是由于客户服务器的操作系统版本太低或某些DLL文件不存在导致的。但现在居然在刚装好的&lt;code&gt;Win7&lt;/code&gt;电脑上也出现此问题，基本可以排除操作系统的问题。&lt;/p&gt;

&lt;p&gt;由于在我自己的笔记本和台式研发机上都没出现这个问题，无奈之下我只好把同事的电脑拿过来和我自己的电脑进行对比，看看哪里设置不一样。通过&lt;code&gt;Win7&lt;/code&gt;中&lt;code&gt;高级系统设置&lt;/code&gt;查看PATH环境变量，很快就发现了问题的根源：&lt;br /&gt;
&lt;code&gt;MySQL&lt;/code&gt;&lt;strong&gt;的执行路径被设置到了&lt;/strong&gt;&lt;code&gt;用户变量&lt;/code&gt;&lt;strong&gt;中的PATH变量里，&lt;/strong&gt;&lt;code&gt;系统变量&lt;/code&gt;&lt;strong&gt;中的PATH变量里却没有&lt;/strong&gt;&lt;code&gt;MySQL&lt;/code&gt;&lt;strong&gt;的执行路径，而&lt;/strong&gt;&lt;code&gt;Java&lt;/code&gt;&lt;strong&gt;代码是匿名执行的，无法获取到&lt;/strong&gt;&lt;code&gt;用户变量&lt;/code&gt;，&lt;strong&gt;只能去&lt;/strong&gt;&lt;code&gt;系统变量&lt;/code&gt;&lt;strong&gt;中寻找相关的可执行命令,因而程序会出错！&lt;/strong&gt;&lt;br /&gt;
&lt;img src=&#34;https://ooo.0o0.ooo/2016/03/03/56d7ebcbce7fc.png&#34; alt=&#34;mysql3.png&#34; /&gt;
&lt;br /&gt;
这下问题原因变得很清楚了，我们在&lt;code&gt;cmd&lt;/code&gt;中执行&lt;code&gt;mysql&lt;/code&gt;和&lt;code&gt;mysqldump&lt;/code&gt;命令以及输出PATH环境变量时，系统会把当前用户的&lt;code&gt;用户变量&lt;/code&gt;中的PATH和操作系统的&lt;code&gt;系统变量&lt;/code&gt;中的PATH变量整合到一块，所以我们在cmd中操作时一切正常。但是当我们在&lt;code&gt;Java&lt;/code&gt;程序中执行&lt;code&gt;mysqldump&lt;/code&gt;命令时，由于&lt;code&gt;Java&lt;/code&gt;程序的运行和用户无关，无法获取到&lt;code&gt;用户变量&lt;/code&gt;中的PATH值，所以当我们在&lt;code&gt;Java&lt;/code&gt;程序中执行&lt;code&gt;mysqldump&lt;/code&gt;命令时会出错。这也正好和&lt;strong&gt;&lt;a href=&#34;http://stackoverflow.com/&#34;&gt;Stackoverflow&lt;/a&gt;&lt;/strong&gt;中说明的原因一致。&lt;/p&gt;

&lt;p&gt;由于有的电脑上会出现此问题，有的电脑上没有此问题，进一步的深究问题的根源，发现发生问题的电脑和服务器在安装&lt;code&gt;MySQL&lt;/code&gt;数据库时都是通过我们自己写的&lt;code&gt;bat&lt;/code&gt;脚本来安装的。而&lt;code&gt;bat&lt;/code&gt;脚本中设置环境变量的代码如下:
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;@echo&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;%&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;Path&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;%&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;setx&lt;/span&gt; &lt;span style=&#34;color: #66d9ef&#34;&gt;PATH&lt;/span&gt; &lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;%Path%;C:\INTA\Database&lt;/span&gt;&lt;span style=&#34;color: #ae81ff&#34;&gt;\b&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;in;&amp;quot;&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;@echo&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;%&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;Path&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;%&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

问题的关键就在于&lt;strong&gt;&lt;em&gt;setx PATH &amp;ldquo;%Path%;C:\INTA\Database\bin;&amp;rdquo;&lt;/em&gt;&lt;/strong&gt;这行代码，这样写的话只会把&lt;code&gt;MySQL&lt;/code&gt;的执行路径加入到当前执行该脚本的&lt;code&gt;用户变量&lt;/code&gt;中，不会加入到&lt;code&gt;环境变量&lt;/code&gt;中。而那些没有出问题的电脑都是我自己手动在&lt;code&gt;系统变量&lt;/code&gt;中设置&lt;code&gt;MySQL&lt;/code&gt;执行路径的！&lt;/p&gt;

&lt;p&gt;该问题的解决方法也很简单，在&lt;strong&gt;&lt;em&gt;setx&lt;/em&gt;&lt;/strong&gt;后面加上&lt;strong&gt;&lt;em&gt;-m&lt;/em&gt;&lt;/strong&gt;即可，这样&lt;code&gt;bat&lt;/code&gt;脚本执行时会把&lt;code&gt;MySQL&lt;/code&gt;的执行路径写入&lt;code&gt;系统变量&lt;/code&gt;的PATH变量中，不会写入&lt;code&gt;用户变量&lt;/code&gt;的PATH变量中：
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;@echo&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;%&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;Path&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;%&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;setx&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;m&lt;/span&gt; &lt;span style=&#34;color: #66d9ef&#34;&gt;PATH&lt;/span&gt; &lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;%Path%;C:\INTA\Database&lt;/span&gt;&lt;span style=&#34;color: #ae81ff&#34;&gt;\b&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;in;&amp;quot;&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;@echo&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;%&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;Path&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;%&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Orz~&lt;br /&gt;
想不到由于一个&lt;strong&gt;&lt;em&gt;-m&lt;/em&gt;&lt;/strong&gt;而让自己郁闷了这么久!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>利用Github Pages和基于Go的Hugo搭建个人博客</title>
      <link>http://lucumt.info/posts/create-website-with-hugo/</link>
      <pubDate>Sat, 27 Feb 2016 22:23:37 +0800</pubDate>
      
      <guid>http://lucumt.info/posts/create-website-with-hugo/</guid>
      <description>

&lt;p&gt;一直以来都想拥有一个属于自己的博客，前段时间在学习&lt;code&gt;Go&lt;/code&gt; ，于是利用&lt;code&gt;Hugo&lt;/code&gt; 和&lt;code&gt;Github Pages&lt;/code&gt; 搭建了一个简易的个人博客，先简单记录下。&lt;/p&gt;

&lt;h1 id=&#34;环境准备:ef8b9e40461ea61e62e36d1aa4c54d14&#34;&gt;环境准备&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt;1.4+&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gohugo.io&#34;&gt;Hugo&lt;/a&gt;v0.14+&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pages.github.com/&#34;&gt;Github Pages&lt;/a&gt;账号&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.godaddy.com&#34;&gt;GoDaddy&lt;/a&gt;域名&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;过程概要:ef8b9e40461ea61e62e36d1aa4c54d14&#34;&gt;过程概要&lt;/h1&gt;

&lt;h2 id=&#34;在github上创建一个自己的项目:ef8b9e40461ea61e62e36d1aa4c54d14&#34;&gt;在Github上创建一个自己的项目&lt;/h2&gt;

&lt;p&gt;参考&lt;code&gt;[Github Pages]&lt;/code&gt; 官网首页的说明，按照提示步骤依次操作即可。在此过程中，有两个步骤需要我们进行选择：&lt;br /&gt;
1. 创建&lt;strong&gt;User or origanization site&lt;/strong&gt;或&lt;strong&gt;Project site&lt;/strong&gt;,我个人选择的是&lt;strong&gt;Project site&lt;/strong&gt;。
&lt;img src=&#34;https://ooo.0o0.ooo/2016/02/29/56d46b8727135.png&#34; alt=&#34;png_1&#34; /&gt;
&lt;br /&gt;
2. 若选择的是&lt;strong&gt;Project site&lt;/strong&gt;,则会让选择&lt;strong&gt;Generate a site&lt;/strong&gt;或&lt;strong&gt;Start from scratch&lt;/strong&gt;，个人选择&lt;strong&gt;Start from scratch&lt;/strong&gt;从头开始搭建。
&lt;img src=&#34;https://ooo.0o0.ooo/2016/02/27/56d1c72e8b3ba.png&#34; alt=&#34;png_2.png&#34; /&gt;
&lt;br /&gt;
当然个人的爱好不同，不一定非得选择&lt;strong&gt;Project site&lt;/strong&gt;和&lt;strong&gt;Start from scratch&lt;/strong&gt;，这不是本文的重点，只要能按照&lt;code&gt;Github Pages&lt;/code&gt;的提示成功搭建自己的静态博客即可。&lt;/p&gt;

&lt;h2 id=&#34;利用hugo作为博客生成器:ef8b9e40461ea61e62e36d1aa4c54d14&#34;&gt;利用Hugo作为博客生成器&lt;/h2&gt;

&lt;p&gt;由于&lt;code&gt;Github Pages&lt;/code&gt; 只支持静态的html页面托管，所以需要采用&lt;code&gt;Jekyll&lt;/code&gt; 、&lt;code&gt;Logdown&lt;/code&gt; 等静态博客生成器来快速生成HTML页面，避免纯手动编写时的费时费力。&lt;/p&gt;

&lt;p&gt;由于自己近期一直在学习&lt;code&gt;Go&lt;/code&gt;，为了加深自己对于&lt;code&gt;Go&lt;/code&gt;的运用，于是便选择&lt;code&gt;Hugo&lt;/code&gt; 作为自己的博客生成器。&lt;code&gt;Hugo&lt;/code&gt; 是一个基于&lt;code&gt;Go]&lt;/code&gt;开发的静态生成器，它采用&lt;em&gt;&lt;a href=&#34;https://zh.wikipedia.org/zh-cn/Markdown&#34;&gt;Markdown&lt;/a&gt;&lt;/em&gt; 语法来编写博客生成，然后生成相应的HTML页面。&lt;/p&gt;

&lt;h3 id=&#34;安装go:ef8b9e40461ea61e62e36d1aa4c54d14&#34;&gt;安装Go&lt;/h3&gt;

&lt;p&gt;访问&lt;a href=&#34;https://golang.org/dl/&#34;&gt;Golang下载页&lt;/a&gt;根据自己电脑的操作系统选择是Linux版本或Windows版本，同时注意是选择32位还是64位，一定要与自己的操作系统相匹配。
以我自己的64位win7系统为例，安装过程如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;下载&lt;strong&gt;go1.4.2.windows-amd64.msi&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;双击安装，默认是安装在C盘下，由于windows操作系统的特性，我通常不倾向于安装在C盘，故需要设置&lt;code&gt;PATH&lt;/code&gt;、&lt;code&gt;GOPATH&lt;/code&gt;和&lt;code&gt;GOROOT&lt;/code&gt;这三个环境变量，我自己把&lt;code&gt;Go&lt;/code&gt;安装在*D:\code\go*下，这三个变量相应的设置为:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;PATH=&amp;rsquo;D:\code\go\bin&amp;rsquo;;%PATH%&lt;br /&gt;
GOPATH=&amp;rsquo;D:\code\gopath&amp;rsquo;&lt;br /&gt;
GOROOT=&amp;rsquo;D:\code\go&amp;rsquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中&lt;strong&gt;PATH&lt;/strong&gt;变量的作用主要是为了将&lt;code&gt;Go&lt;/code&gt;的各种命令加到cmd中。&lt;strong&gt;GOROOT&lt;/strong&gt;则是当我们将&lt;code&gt;Go&lt;/code&gt;安装在我们的自定义目录时，需要制定该安装目录，若安装在默认目录&lt;strong&gt;C:\go&lt;/strong&gt;下则不用设置&lt;strong&gt;GOROOT&lt;/strong&gt;目录，官方文档原文为&lt;em&gt;GOROOT must be set only when installing to a custom location.&lt;/em&gt; 比较难懂的是&lt;strong&gt;GOPATH&lt;/strong&gt;,官方文档上的说明为 &lt;em&gt;Create a directory to contain your workspace, $HOME/work for example, and set the GOPATH environment variable to point to that location.&lt;/em&gt; 据此我们可以将&lt;strong&gt;GOPATH&lt;/strong&gt;理解为工作目录，它主要用来存放&lt;code&gt;Go&lt;/code&gt;代码编译之后的可执行文件，其位置可以随意设置，只要不与&lt;strong&gt;GOROOT&lt;/strong&gt;相同即可。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;安装完成之后，重新打开cmd窗口，输入&lt;strong&gt;go version&lt;/strong&gt;之后按Enter键，若出现如下信息，则表示&lt;code&gt;Go&lt;/code&gt;安装成功:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;C:\Users\Administrator&amp;gt;go version&lt;br /&gt;
go version go1.4.2 windows/amd64&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;安装hugo:ef8b9e40461ea61e62e36d1aa4c54d14&#34;&gt;安装Hugo&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Hugo&lt;/code&gt;的安装过程与&lt;code&gt;Go&lt;/code&gt;的类似.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先在&lt;a href=&#34;https://github.com/spf13/hugo/releases&#34;&gt;Hugo下载页&lt;/a&gt;根据自己操作系统的类型和位数下载相应的安装包，然后设置对应的&lt;strong&gt;PATH&lt;/strong&gt;环境变量即可。我的安装在 &lt;em&gt;D:\program\hugo&lt;/em&gt; 所以相应的环境变量设置为&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;PATH=&amp;rsquo;D:\program\hugo&amp;rsquo;;%PATH%&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;重新打开cmd窗口，输入&lt;strong&gt;hugo version&lt;/strong&gt;，若出现如下信息，则表示&lt;code&gt;Hugo&lt;/code&gt;安装成功：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;C:\Users\Administrator&amp;gt;hugo version
Hugo Static Site Generator v0.14 BuildDate: 2015-05-26T01:29:16+08:00&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;关于&lt;code&gt;Hugo&lt;/code&gt;的基本操作命令，可以参见&lt;a href=&#34;https://gohugo.io/overview/quickstart/&#34;&gt;Hugo快速入门&lt;/a&gt;，此处不再详述。&lt;/p&gt;

&lt;h2 id=&#34;在github-pages上托管hugo:ef8b9e40461ea61e62e36d1aa4c54d14&#34;&gt;在Github Pages上托管Hugo&lt;/h2&gt;

&lt;h3 id=&#34;安装命令:ef8b9e40461ea61e62e36d1aa4c54d14&#34;&gt;安装命令&lt;/h3&gt;

&lt;p&gt;最权威的信息还是来源于官方文档，可以参见&lt;a href=&#34;https://gohugo.io/tutorials/github-pages-blog/&#34;&gt;在Github Pages上托管Hugo&lt;/a&gt;,主要的&lt;code&gt;Git&lt;/code&gt;操作命令如下：&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #75715e&#34;&gt;# Create a new orphand branch (no commit history) named gh-pages&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;git&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;checkout&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;--&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;orphan&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;gh&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;pages&lt;/span&gt;

&lt;span style=&#34;color: #75715e&#34;&gt;# Unstage all files&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;git&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;rm&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;--&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;cached&lt;/span&gt; &lt;span style=&#34;color: #960050; background-color: #1e0010&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;(git&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;ls&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;files)&lt;/span&gt;

&lt;span style=&#34;color: #75715e&#34;&gt;# Grab one file from the master branch so we can make a commit&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;git&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;checkout&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;master&lt;/span&gt; &lt;span style=&#34;color: #66d9ef&#34;&gt;README&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;md&lt;/span&gt;

&lt;span style=&#34;color: #75715e&#34;&gt;# Add and commit that file&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;git&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;add&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;git&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;commit&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;m&lt;/span&gt; &lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;INIT: initial commit on gh-pages branch&amp;quot;&lt;/span&gt;

&lt;span style=&#34;color: #75715e&#34;&gt;# Push to remote gh-pages branch&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;git&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;push&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;origin&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;gh&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;pages&lt;/span&gt;

&lt;span style=&#34;color: #75715e&#34;&gt;# Return to master branch&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;git&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;checkout&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;master&lt;/span&gt;

&lt;span style=&#34;color: #75715e&#34;&gt;# Remove the public folder to make room for the gh-pages subtree&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;rm&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;rf&lt;/span&gt; &lt;span style=&#34;color: #66d9ef&#34;&gt;public&lt;/span&gt;

&lt;span style=&#34;color: #75715e&#34;&gt;# Add the gh-pages branch of the repository. It will look like a folder named public&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;git&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;subtree&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;add&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;--&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;prefix&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;git@github&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;com&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;:spencerlyon2&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;hugo_gh_blog&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;git&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;gh&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;pages&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;--&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;squash&lt;/span&gt;

&lt;span style=&#34;color: #75715e&#34;&gt;# Pull down the file we just committed. This helps avoid merge conflicts&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;git&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;subtree&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;pull&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;--&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;prefix&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;git@github&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;com&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;:spencerlyon2&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;hugo_gh_blog&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;git&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;gh&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;pages&lt;/span&gt;

&lt;span style=&#34;color: #75715e&#34;&gt;# Run hugo. Generated site will be placed in public directory (or omit -t ThemeName if you&amp;#39;re not using a theme)&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;hugo&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;t&lt;/span&gt; &lt;span style=&#34;color: #66d9ef&#34;&gt;ThemeName&lt;/span&gt;

&lt;span style=&#34;color: #75715e&#34;&gt;# 如果不是第一次创建，那么后续更新时可以从此步骤开始&lt;/span&gt;
&lt;span style=&#34;color: #75715e&#34;&gt;# Add everything&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;git&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;add&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;A&lt;/span&gt;

&lt;span style=&#34;color: #75715e&#34;&gt;# Commit and push to master&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;git&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;commit&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;m&lt;/span&gt; &lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;Updating site&amp;quot;&lt;/span&gt;

&lt;span style=&#34;color: #75715e&#34;&gt;# Push to master&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;git&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;push&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;origin&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;master&lt;/span&gt;

&lt;span style=&#34;color: #75715e&#34;&gt;# 将主干中public目录同步到gh-pages分支上&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;git&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;subtree&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;push&lt;/span&gt; &lt;span style=&#34;color: #f92672&#34;&gt;--&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;prefix&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;git@github&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;com&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;:spencerlyon2&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;hugo_gh_blog&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;git&lt;/span&gt; &lt;span style=&#34;color: #f8f8f2&#34;&gt;gh&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;pages&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h3 id=&#34;说明信息:ef8b9e40461ea61e62e36d1aa4c54d14&#34;&gt;说明信息&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;上述命令的核心思想把源代码放在&lt;strong&gt;master&lt;/strong&gt;上，把生成的静态html代码通过&lt;strong&gt;substree&lt;/strong&gt;命令放到&lt;strong&gt;branch&lt;/strong&gt;上；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Git&lt;/code&gt;主干的名字可以随便取，但是分支的名字必须为&lt;code&gt;gh-pages&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;上述命令针对的是从头到尾开始创建一个&lt;code&gt;Git&lt;/code&gt;项目然后提交，如果之前已经有&lt;code&gt;gh-pages&lt;/code&gt;项目了，则可以从 &lt;em&gt;git subtree add &amp;ndash;prefix=public git@github.com:spencerlyon2/hugo_gh_blog.git gh-pages &amp;ndash;squash&lt;/em&gt; 这句代码开始执行；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;相关命令:ef8b9e40461ea61e62e36d1aa4c54d14&#34;&gt;相关命令&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;生成绑定到指定域名的页面
&lt;code&gt;hugo server -D --baseUrl=&amp;quot;http://lucumt.info&amp;quot; --appendPort=false&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;lt;&amp;ndash;待续&amp;ndash;&amp;gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>