<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 飞狐的部落格</title>
    <link>https://lucumt.info/posts/</link>
    <description>Recent content in Posts on 飞狐的部落格</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 24 Dec 2017 10:28:03 +0800</lastBuildDate>
    <atom:link href="https://lucumt.info/posts/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>将基于Github Pages的自定义域名博客迁移到HTTPS</title>
      <link>https://lucumt.info/posts/migrate-github-blog-from-http-to-https/</link>
      <pubDate>Sun, 24 Dec 2017 10:28:03 +0800</pubDate>
      
      <guid>https://lucumt.info/posts/migrate-github-blog-from-http-to-https/</guid>
      <description>

&lt;p&gt;越来越多的网站和个人博客都变成 &lt;strong&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTPS&#34; title=&#34;https://en.wikipedia.org/wiki/HTTPS&#34;&gt;HTTPS&lt;/a&gt;&lt;/strong&gt; ，而自己的博客一直都是用的是 &lt;strong&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol&#34; title=&#34;https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol&#34;&gt;HTTP&lt;/a&gt;&lt;/strong&gt; 协议，作为一个具有强迫症的人，每次用 &lt;strong&gt;&lt;a href=&#34;https://www.google.cn/chrome/browser/desktop/index.html&#34; title=&#34;https://www.google.cn/chrome/browser/desktop/index.html&#34;&gt;Chrome&lt;/a&gt;&lt;/strong&gt; 浏览器打开个人博客时看见浏览器地址栏显示的&lt;img src=&#34;https://lucumt.info/blog_img/migrate-github-blog-from-http-to-https/http_icon.png&#34; alt=&#34;&amp;quot;Chrome HTTP标识&amp;quot;&#34; title=&#34;Chrome HTTP标识&#34; /&gt;
 都感觉很不舒服。趁着前段时间不太忙，将个人博客从 &lt;em&gt;HTTP&lt;/em&gt; 迁移到了 &lt;em&gt;HTTPS&lt;/em&gt; ，先记录下。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;
一开始我想直接通过在 &lt;strong&gt;&lt;a href=&#34;https://www.godaddy.com/&#34;&gt;GoDaddy&lt;/a&gt;&lt;/strong&gt; 上直接购买 &lt;em&gt;HTTPS&lt;/em&gt; 服务来实现，去官网查看后发现费用太高，一年大约100美刀，果断弃之。 Google后发现很多人都用 &lt;strong&gt;&lt;a href=&#34;https://www.cloudflare.com/&#34;&gt;Cloudflare&lt;/a&gt;&lt;/strong&gt; 通过转发请求来实现 &lt;em&gt;HTTPS&lt;/em&gt; 访问，操作起来也很快，自己便也采用 &lt;em&gt;Cloudflare&lt;/em&gt; 实现， 本文主要是基于 &lt;em&gt;Cloudflare&lt;/em&gt; 的实现说明。&lt;/p&gt;

&lt;h2 id=&#34;操作过程:a714b797edb698eabc838855a40c47d3&#34;&gt;操作过程&lt;/h2&gt;

&lt;h3 id=&#34;给博客添加自定义域名:a714b797edb698eabc838855a40c47d3&#34;&gt;给博客添加自定义域名&lt;/h3&gt;

&lt;p&gt;本人使用的是 &lt;em&gt;GoDaddy&lt;/em&gt; 来设置自定义域名，具体操作请参见 &lt;strong&gt;&lt;a href=&#34;https://lucumt.info/posts/create-website-with-hugo/#%E5%88%A9%E7%94%A8godaddy%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D:ef8b9e40461ea61e62e36d1aa4c54d14&#34;&gt;利用GoDaddy配置自定义域名&lt;/a&gt;&lt;/strong&gt;， 核心的操作就是给 &lt;strong&gt;CNAME&lt;/strong&gt; 文件添加 &lt;em&gt;Github Pages&lt;/em&gt; 给出的两条&lt;strong&gt;A&lt;/strong&gt;记录IP地址，此处不再详述。&lt;/p&gt;

&lt;h3 id=&#34;利用cloudflare修改dns服务器:a714b797edb698eabc838855a40c47d3&#34;&gt;利用Cloudflare修改DNS服务器&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;打开 &lt;em&gt;Cloudflare官网&lt;/em&gt; 注册一个 &lt;em&gt;Cloudflare&lt;/em&gt; 账户。注册成功之后，点击页面右上角的 &lt;em&gt;add site&lt;/em&gt; 链接，添加一个网站，在下图输入框中输入自己的域名，点击 Begin Scan 按钮开始扫描。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/migrate-github-blog-from-http-to-https/add_site_in_cloudflare.png&#34; alt=&#34;&amp;quot;在Cloudflare中扫描站点&amp;quot;&#34; title=&#34;在Cloudflare中扫描站点&#34; /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;扫描完毕后点击 &lt;em&gt;Contiue Setup&lt;/em&gt; ，在类似如下图所示的界面中选择 &lt;em&gt;Free Website&lt;/em&gt; ，然后点击页面底部的 &lt;em&gt;Continue&lt;/em&gt; 按钮。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/migrate-github-blog-from-http-to-https/cloudflare_free_website.png&#34; alt=&#34;&amp;quot;选择Cloudflare免费站点&amp;quot;&#34; title=&#34;选择Cloudflare免费站点&#34; /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在下图所示的 &lt;em&gt;Cloudflare Nameservers&lt;/em&gt; 说明界面中根据要求来修改自定义域名的DNS服务器。
&lt;img src=&#34;https://lucumt.info/blog_img/migrate-github-blog-from-http-to-https/cloudflare_nameservers.png&#34; alt=&#34;&amp;quot;Cloudflare扫描结果&amp;quot;&#34; title=&#34;Cloudflare扫描结果&#34; /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;登录 &lt;em&gt;GoDaddy&lt;/em&gt; ，打开响应域名的 &lt;em&gt;Manage DNS&lt;/em&gt; 界面，将 &lt;em&gt;Nameservers&lt;/em&gt; 从 &lt;em&gt;Default&lt;/em&gt; 修改为 &lt;em&gt;Custom&lt;/em&gt; 然后添加前一个步骤中的两个值分别加上并点击保存。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/migrate-github-blog-from-http-to-https/modify_dns_server_in_godaddy.png&#34; alt=&#34;&amp;quot;Cloudflare扫描结果&amp;quot;&#34; title=&#34;Cloudflare扫描结果&#34; /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;回到 &lt;em&gt;Cloudflare&lt;/em&gt; 网站，点击 &lt;em&gt;Overview&lt;/em&gt; 按钮，查看域名的状态是否为如下所示的 &lt;em&gt;Active*，若是则表示DNS服务器修改成功，若不是 *Active&lt;/em&gt; 请等待几分钟。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/migrate-github-blog-from-http-to-https/cloudflare_website_actived.png&#34; alt=&#34;&amp;quot;Cloudflare中配置DNS成功&amp;quot;&#34; title=&#34;Cloudflare中配置DNS成功&#34; /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;cloudflare中开启https设置:a714b797edb698eabc838855a40c47d3&#34;&gt;Cloudflare中开启HTTPS设置&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;在 &lt;em&gt;Cloudflare&lt;/em&gt; 网站上点击顶部的 &lt;em&gt;Crypto&lt;/em&gt; 按钮，将状态修改为 *Full*。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/migrate-github-blog-from-http-to-https/cloudflare_ssl_setting.png&#34; alt=&#34;&amp;quot;Cloudflare中SSL设置&amp;quot;&#34; title=&#34;Cloudflare中SSL设置&#34; /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在顶部切换到 &lt;em&gt;Page Rules&lt;/em&gt; 界面，点击 &lt;em&gt;Create Page Rule&lt;/em&gt; ，添加规则&lt;code&gt;http://lucumt.info/*&lt;/code&gt; 并选择 &lt;em&gt;Always Use HTTPS&lt;/em&gt; 来强制该域名下的所有请求都是用HTTPS实现，然后点击 &lt;em&gt;Save and Deploy&lt;/em&gt; 来部署该规则，注意此处的规则是 &lt;em&gt;HTTP&lt;/em&gt; 而不是 &lt;em&gt;HTTPS&lt;/em&gt; 。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/migrate-github-blog-from-http-to-https/cloudflare_page_rule_setting.png&#34; alt=&#34;&amp;quot;Cloudflare中Page Rule设置&amp;quot;&#34; title=&#34;Cloudflare中Page Rule设置&#34; /&gt;
&lt;br /&gt;
执行完这一步后理论上通过 &lt;em&gt;HTTPS&lt;/em&gt; 可以正常的访问个人博客，但还需对博客源码做一些修改。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;将代码中所有http修改为https:a714b797edb698eabc838855a40c47d3&#34;&gt;将代码中所有HTTP修改为HTTPS&lt;/h3&gt;

&lt;p&gt;在执行完前面的步骤后，在浏览器中用 &lt;em&gt;HTTPS&lt;/em&gt; 访问个人博客时，可能看到的还是&lt;img src=&#34;https://lucumt.info/blog_img/migrate-github-blog-from-http-to-https/http_icon.png&#34; alt=&#34;&amp;quot;Chrome HTTP标识&amp;quot;&#34; title=&#34;Chrome HTTP标识&#34; /&gt;
而不是自己期望中的小绿锁，同时浏览器控制台可能会出现类似 &lt;em&gt;Mixed Content,The page at &amp;hellip;,The request has been blocked,the content must be serverd over HTTPS&lt;/em&gt; 的错误信息。其原因是由于某些页面中存在混合内容，即部分请求还是以 &lt;em&gt;HTTP&lt;/em&gt; 方式实现的，如加载 &lt;em&gt;Javascript&lt;/em&gt; 、 &lt;em&gt;CSS&lt;/em&gt; 等，解决方法也很简单，&lt;strong&gt;将所有的HTTP请求都改为HTTPS即可&lt;/strong&gt; 。&lt;/p&gt;

&lt;p&gt;以我个人基于 &lt;strong&gt;&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;&lt;/strong&gt; 的博客为例，要进行如下几步操作：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将个人 &lt;em&gt;Hugo&lt;/em&gt; 源代码中所有的 &lt;em&gt;HTTP&lt;/em&gt; 请求都修改为 &lt;em&gt;HTTP&lt;/em&gt;,包括页面中的直接请求和 &lt;em&gt;Javascript&lt;/em&gt; 、 &lt;em&gt;CSS&lt;/em&gt; 等文件中的间接请求。&lt;/li&gt;
&lt;li&gt;利用 &lt;code&gt;hugo server -D --baseUrl=&amp;quot;https://lucumt.info&amp;quot; --appendPort=false&lt;/code&gt; 重新生成基于 &lt;em&gt;HTTPS&lt;/em&gt; 的源文件页面。&lt;/li&gt;
&lt;li&gt;将生成的博客源代码重新上传到 &lt;em&gt;Github&lt;/em&gt; 仓库中，经过1分钟左右以 &lt;em&gt;HTTPS&lt;/em&gt; 的方式在浏览器中打开个人博客，期待中的小绿锁入愿出现，世界终于和谐了！&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/migrate-github-blog-from-http-to-https/open-blog-website-via-https.png&#34; alt=&#34;&amp;quot;通过HTTPS打开个人博客&amp;quot;&#34; title=&#34;通过HTTPS打开个人博客&#34; /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;注意事项:a714b797edb698eabc838855a40c47d3&#34;&gt;注意事项&lt;/h2&gt;

&lt;p&gt;通过 &lt;em&gt;Cloudflare&lt;/em&gt; 虽然可以快速的将自己的个人博客迁移到 &lt;em&gt;HTTPS&lt;/em&gt; ，但基于以下两个方面的原因，在条件许可的情况下还是应该使用其他方式实现HTTPS:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;免费计划下的 &lt;em&gt;Cloudflare&lt;/em&gt; 实际上相当于一个中介，我们的访问请求先被 &lt;em&gt;Cloudflare&lt;/em&gt; 代理实现 &lt;em&gt;HTTPS&lt;/em&gt; 接收到然后将其转发给原始的服务器（如 &lt;em&gt;Github Pages&lt;/em&gt; 服务器）。虽然浏览器与 &lt;em&gt;Cloudflare&lt;/em&gt; 之间的通信是 &lt;em&gt;HTTPS&lt;/em&gt; 加密，但是 &lt;em&gt;Cloudflare&lt;/em&gt; 与实际服务器之间的通信不一定是加密的，存在被挟持和篡改的可能。 &lt;em&gt;Cloudflare&lt;/em&gt; 之前也被爆出过 &lt;strong&gt;&lt;a href=&#34;https://thehackernews.com/2017/02/cloudflare-vulnerability.html&#34; title=&#34;Serious Bug Exposes Sensitive Data From Millions Sites Sitting Behind CloudFlare&#34;&gt;安全漏洞和敏感数据泄露&lt;/a&gt;&lt;/strong&gt;，故商业网站通常不用 &lt;em&gt;Cloudflare&lt;/em&gt; 免费计划，但个人博客出于增加搜索引擎收录和省钱等原因，可以使用 &lt;em&gt;Cloudflare&lt;/em&gt; 免费计划。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/migrate-github-blog-from-http-to-https/cloudflare_ssl_website.png&#34; alt=&#34;&amp;quot;Cloudflare代理实现HTTPS&amp;quot;&#34; title=&#34;Cloudflare代理实现HTTPS&#34; /&gt;&lt;/li&gt;
&lt;li&gt;由于经过 &lt;em&gt;Cloudflare&lt;/em&gt; 这层代码，访问速度肯定没有直接访问原始服务器那么快，对于响应速度要求高的用户不合适。&lt;/li&gt;
&lt;li&gt;由于众所周知的原因，在天朝 &lt;em&gt;Cloudflare&lt;/em&gt; 访问速度比国内慢，而且指不定哪天就被ban了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bakumon.me/blog/p/github-pages-https-ssl.html&#34;&gt;https://bakumon.me/blog/p/github-pages-https-ssl.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://help.github.com/articles/securing-your-github-pages-site-with-https/&#34;&gt;https://help.github.com/articles/securing-your-github-pages-site-with-https/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>从复杂代码中找出Bug的几种方法</title>
      <link>https://lucumt.info/posts/different-ways-find-bug-in-complex-code/</link>
      <pubDate>Sat, 23 Dec 2017 12:07:40 +0800</pubDate>
      
      <guid>https://lucumt.info/posts/different-ways-find-bug-in-complex-code/</guid>
      <description>

&lt;p&gt;工作中有时候会遇到某些大段复杂代码出现Bug的情况，不同于一般行数较小或逻辑较简单的代码，对于大段复杂的代码进行分析可能会很耗时，本文介绍几种个人在工作中用到的方法，供大家参考。&lt;/p&gt;

&lt;h2 id=&#34;将log级别开启到debug:c6528d23af9c43af76bed9bb9927b4cb&#34;&gt;将Log级别开启到Debug&lt;/h2&gt;

&lt;p&gt;将Log的级别变为Debug后，会比INFO状态下看到更多的详细日志信息，仔细分析这些输出信息，有时候可以发现是哪一步不能按照预期工作，据此缩小查找范围，从而解决缺陷。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/different-ways-find-bug-in-complex-code/debug_log_output.png&#34; alt=&#34;&amp;quot;Debug级别的日志输出&amp;quot;&#34; title=&#34;Debug级别的日志输出&#34; /&gt;
&lt;br /&gt;
实际使用中由于Debug级别的log输出信息庞大，查看输出log很耗时，在实际开发中用得不多，常用的场景如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;知道大致的代码范围，通过观察log输出来确定具体的原因&lt;/li&gt;
&lt;li&gt;压根不知道问题出在哪里，通过观察log输出来获取有用信息，辅助以其它手段来分析&lt;/li&gt;
&lt;li&gt;多线程等无法利用Debug调试的环境&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;利用ide进行debug:c6528d23af9c43af76bed9bb9927b4cb&#34;&gt;利用IDE进行Debug&lt;/h2&gt;

&lt;p&gt;在IDE中开启Debug模式进行调试是开发过程中最常用的一种手段，通过Debug调试可以找出哪些代码被执行，哪些没有被执行，以及在执行过程中相关变量的值。Debug调试在大部分情况下都可以帮我们找出缺陷，但在多线程应用、 &lt;em&gt;HTML&lt;/em&gt; 页面样式调试等场景下并不适用Debug方式。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/different-ways-find-bug-in-complex-code/debug_in_ide.png&#34; alt=&#34;&amp;quot;在IDE中进行Debug&amp;quot;&#34; title=&#34;在IDE中进行Debug&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;在代码仓库中进行版本回溯:c6528d23af9c43af76bed9bb9927b4cb&#34;&gt;在代码仓库中进行版本回溯&lt;/h2&gt;

&lt;p&gt;若已知出问题的代码在以前没有问题，只是最近的更改才出现问题，可以通过从代码仓库中找出历史版本与目前的版本进行对比，看看有哪些差异，通常问题都发生在这些有差异的地方。&lt;/p&gt;

&lt;p&gt;与其它方式相比此种方法耗时最少，通过这种方式找出的bug一般都是某些关键配置写错了或代码语法不正确时控制台没有输出完整的错误信息，如在Ajax方法中在某些配置项后面少写了一个 &lt;code&gt;,&lt;/code&gt;时，在某些浏览器中进行调试时只会出现 &lt;em&gt;Uncaught SyntaxError: Unexpected identifier&lt;/em&gt; 这种错误消息，无法根据错误信息具体定位到哪一行代码出错。&lt;/p&gt;

&lt;h2 id=&#34;通过二分查找定位:c6528d23af9c43af76bed9bb9927b4cb&#34;&gt;通过二分查找定位&lt;/h2&gt;

&lt;p&gt;我最喜欢用的方法之一，二分查找定位的操作和二分查找算法类似，先将一部代码注意掉或插入试探性代码，确定问题是在这一边或那一边，确定完大致的区域后，对该问题区域再次采用二分查找来定位，直到找到问题原因为止。此种方法和二分查找算法一样耗时较少。
&lt;img src=&#34;https://lucumt.info/blog_img/different-ways-find-bug-in-complex-code/binary_search_debug.png&#34; alt=&#34;&amp;quot;通过二分查找确认问题&amp;quot;&#34; title=&#34;通过二分查找确认问题&#34; /&gt;
&lt;br /&gt;
此方法常用的场景如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不方便利用Debug日志或Debug调试的地方&lt;/li&gt;
&lt;li&gt;&lt;em&gt;HTML&lt;/em&gt; 、&lt;em&gt;JSP&lt;/em&gt; 等View层的代码&lt;/li&gt;
&lt;li&gt;刚上手某项技术，对其原理了解不深入&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;重新编写代码实现:c6528d23af9c43af76bed9bb9927b4cb&#34;&gt;重新编写代码实现&lt;/h2&gt;

&lt;p&gt;若前面几种方法均不能凑效，可以采取终极大法： &lt;strong&gt;重新编码实现！&lt;/strong&gt; ，&lt;em&gt;不识庐山真面目，只缘身在此山中&lt;/em&gt; ，有些代码的实现逻辑本身就有问题，若直接对其进行Debug调试或分析，可能会陷入该代码错误的陷阱中。如我们可能认为某段代码代码是没有问题的，然后基于该代码进行进一步的分析调试，却无论如何都得不到自己想要的结果，问题的原因就在于该段代码本身就是错误的。起始点选错了，无论后面怎么做，都无济于事。&lt;/p&gt;

&lt;p&gt;根据原始的需求，在不参照现有代码实现方式的基础上，以白板的方式重新编程实现功能，在对比旧的代码，就能发现问题产生的原因。若这种方式还不能凑效，可以让其他同事协助审查自己的代码，或者审核原有的需求本身是否有问题，通常这种情形意味着我们的代码必须要重构。&lt;/p&gt;

&lt;h2 id=&#34;总结:c6528d23af9c43af76bed9bb9927b4cb&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;好的代码会自己说话，平时编码时要注意细节、符合规范，必要时对代码进行重构，将复杂的代码进行抽取简化。代码重构虽然对我们的工作产出不会有立竿见影的效果，但也绝不是白白浪费我们的时间，不断重构后的实现良好的代码，不仅有利于调试分析，也有利于他人顺利接手。&lt;/p&gt;

&lt;p&gt;在一些成立时间较长的公司或多或少都会存在一些 &lt;strong&gt;炸弹代码&lt;/strong&gt;，此处说的炸弹代码是指那些功能很重要实现又很复杂的代码，最开始开发该功能的人离职后，后面接手的人看不懂该代码，由于各种原因无法对其进行重构，在后续开发时，只能不断的在其后面添加新的业务逻辑，而不敢修改已有的，导致代码量越来越臃肿，越臃肿就越看不懂，陷入恶性循环。这样的代码在后续每次调试分析时都是大坑，而如果一开始就进行适当的重构，或许不会发生这种情况。&lt;/p&gt;

&lt;p&gt;Orz~ 我承认 &lt;strong&gt;炸弹代码&lt;/strong&gt; 这个词是我自己发明的！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在不同版本的MyBatis中通过Log4j打印实际执行的SQL</title>
      <link>https://lucumt.info/posts/print-sql-in-different-mybatis-version/</link>
      <pubDate>Mon, 18 Dec 2017 18:33:14 +0800</pubDate>
      
      <guid>https://lucumt.info/posts/print-sql-in-different-mybatis-version/</guid>
      <description>

&lt;p&gt;项目中ORM框架用的是 &lt;strong&gt;&lt;a href=&#34;http://www.mybatis.org/mybatis-3/&#34;&gt;MyBatis&lt;/a&gt;&lt;/strong&gt;，最近由于业务上的需求将 &lt;em&gt;MyBatis&lt;/em&gt; 从3.1.1升级到3.4.5，发现升级后通过 &lt;strong&gt;&lt;a href=&#34;https://logging.apache.org/log4j/1.2/download.html&#34;&gt;Log4j&lt;/a&gt;&lt;/strong&gt; 显示SQL的配置方式发生了变化，由于变化较大，故先记录下。&lt;/p&gt;

&lt;p&gt;假设我们测试的sql文件为 &lt;em&gt;UserMapper.xml&lt;/em&gt; ， 对应的代码如下，其命名空间为 &lt;em&gt;com.lucumt.mapper.UserMappper&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot; &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;

&amp;lt;mapper namespace=&amp;quot;com.lucumt.mapper.UserMappper&amp;quot;&amp;gt;
    &amp;lt;select id=&amp;quot;getUsers&amp;quot; parameterType=&amp;quot;String&amp;quot; resultType=&amp;quot;com.lucumt.model.UserModel&amp;quot;&amp;gt;
        SELECT id,username,password,create_time AS createTime FROM system_users WHERE username!=#{username}
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应的执行代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testMybatis(){
    String resource = &amp;quot;mybatis-config.xml&amp;quot;;
    InputStream is = AppTest.class.getClassLoader().getResourceAsStream(resource);
    SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is);
    
    SqlSession session = sessionFactory.openSession();
    String statement = &amp;quot;com.lucumt.mapper.UserMappper.getUsers&amp;quot;;
    List&amp;lt;UserModel&amp;gt; userList = session.selectList(statement, &amp;quot;admin&amp;quot;);
    for(UserModel u:userList){
    	System.out.println(u.toString());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本文会基于上述代码说明不同版本下如何利用 &lt;em&gt;Log4j&lt;/em&gt; 在 &lt;em&gt;MyBatis&lt;/em&gt; 中配置打印日志以及其实现原理。&lt;/p&gt;

&lt;h2 id=&#34;mybatis3-1-1显示sql的配置与分析:7eadf44b310a8365cd3dc766a1e45c58&#34;&gt;MyBatis3.1.1显示SQL的配置与分析&lt;/h2&gt;

&lt;h3 id=&#34;log4j相关配置:7eadf44b310a8365cd3dc766a1e45c58&#34;&gt;Log4j相关配置&lt;/h3&gt;

&lt;p&gt;在 &lt;em&gt;MyBatis3.1.1&lt;/em&gt; 及以前的版本中若我们想通过 &lt;em&gt;Log4j&lt;/em&gt; 配置来打印实际执行的SQL，&lt;em&gt;log4j.properties&lt;/em&gt; 的配置通常类似如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#在不开启log4j DEBUG模式下显示mybatis中运行的SQL语句 
log4j.logger.java.sql.Connection=DEBUG 
log4j.logger.java.sql.Statement=DEBUG 
log4j.logger.java.sql.PreparedStatement=DEBUG 
log4j.logger.java.sql.ResultSet=DEBUG 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;原理分析:7eadf44b310a8365cd3dc766a1e45c58&#34;&gt;原理分析&lt;/h3&gt;

&lt;p&gt;以 &lt;em&gt;log4j.logger.java.sql.Connection=DEBUG&lt;/em&gt;  这个配置为例，分析源码可知其sql日志来源于&lt;code&gt;ConnectionLogger&lt;/code&gt;，查看 &lt;em&gt;ConnectionLogger&lt;/em&gt; 的代码可知，&lt;em&gt;ConnectionLogger&lt;/em&gt; 以硬编码的方式生成了一个log对象,当 &lt;em&gt;DEBUG&lt;/em&gt; 模式开启时该log对象会打印sql语句等信息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class ConnectionLogger extends BaseJdbcLogger implements InvocationHandler {

  //生成一个Connection的log
  private static final Log log = LogFactory.getLog(Connection.class);

  private Connection connection;

  private ConnectionLogger(Connection conn, Log statementLog) {
    super(statementLog);
    this.connection = conn;
    if (isDebugEnabled()) {
      debug(&amp;quot;ooo Using Connection [&amp;quot; + conn + &amp;quot;]&amp;quot;);
    }
  }

  public Object invoke(Object proxy, Method method, Object[] params)
      throws Throwable {
    try {
      if (&amp;quot;prepareStatement&amp;quot;.equals(method.getName())) {
        if (isDebugEnabled()) {//打印执行的SQL语句
          debug(&amp;quot;==&amp;gt;  Preparing: &amp;quot; + removeBreakingWhitespace((String) params[0]));
        }        
        PreparedStatement stmt = (PreparedStatement) method.invoke(connection, params);
        stmt = PreparedStatementLogger.newInstance(stmt, getStatementLog());
        return stmt;
      }
      //... other code
    } catch (Throwable t) {
      throw ExceptionUtil.unwrapThrowable(t);
    }
  }

  //... other code

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果如下&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/print-sql-in-different-mybatis-version/mybatis-3.1.1-print-sql-result.png&#34; alt=&#34;&amp;quot;MyBatis3.1.1时显示执行SQL&amp;quot;&#34; title=&#34;MyBatis1.1.1时显示执行SQL&#34; /&gt;
&lt;br /&gt;
从上述代码可知在 &lt;em&gt;Mybatis3.1.1&lt;/em&gt; 中通过 &lt;em&gt;Log4j&lt;/em&gt; 实现打印执行SQL的操作很简单，实现原理也易懂，但其存在的一个缺点: &lt;strong&gt;当开启打印SQL日志后，会打印所有正在执行的SQL语句，不能实现针对特定SQL的打印&lt;/strong&gt; ，基于此 &lt;em&gt;MyBatis&lt;/em&gt; 从3.2.0版本之后重新实现了相关功能。&lt;/p&gt;

&lt;h2 id=&#34;mybatis3-4-5显示sql的配置与分析:7eadf44b310a8365cd3dc766a1e45c58&#34;&gt;MyBatis3.4.5显示SQL的配置与分析&lt;/h2&gt;

&lt;h3 id=&#34;log4j相关配置-1:7eadf44b310a8365cd3dc766a1e45c58&#34;&gt;Log4j相关配置&lt;/h3&gt;

&lt;p&gt;在 &lt;em&gt;MyBatis3.2.0&lt;/em&gt; 及以后的版本中若我们想通过Log4j配置来打印实际执行的SQL，&lt;em&gt;log4j.properties&lt;/em&gt; 的配置通常类似如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#在不开启log4j DEBUG模式下显示mybatis中运行的SQL语句 
log4j.logger.com.lucumt.mapper=DEBUG 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在本文写作时，mybatis官网上已有关于这方面更 &lt;strong&gt;&lt;a href=&#34;http://www.mybatis.org/mybatis-3/zh/logging.html&#34;&gt;详细的说明&lt;/a&gt;&lt;/strong&gt; 。&lt;/p&gt;

&lt;h3 id=&#34;原理分析-1:7eadf44b310a8365cd3dc766a1e45c58&#34;&gt;原理分析&lt;/h3&gt;

&lt;p&gt;同样以 &lt;em&gt;log4j.logger.java.sql.Connection=DEBUG&lt;/em&gt; 为例，其sql日志来源于 &lt;em&gt;ConnectionLogger&lt;/em&gt; ，对应代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class ConnectionLogger extends BaseJdbcLogger implements InvocationHandler {

  private final Connection connection;

  //通过注入的方式生成log对象
  private ConnectionLogger(Connection conn, Log statementLog, int queryStack) {
    super(statementLog, queryStack);
    this.connection = conn;
  }

  @Override
  public Object invoke(Object proxy, Method method, Object[] params)
      throws Throwable {
    try {
      if (Object.class.equals(method.getDeclaringClass())) {
        return method.invoke(this, params);
      }    
      if (&amp;quot;prepareStatement&amp;quot;.equals(method.getName())) {
        if (isDebugEnabled()) {
          debug(&amp;quot; Preparing: &amp;quot; + removeBreakingWhitespace((String) params[0]), true);
        }        
      }
      //... other code
    } catch (Throwable t) {
      throw ExceptionUtil.unwrapThrowable(t);
    }
  }

  //... other code

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上述代码可知，其日志生成是调用&lt;code&gt;BaseJdbcLogger&lt;/code&gt;的构造方法生成的，&lt;em&gt;BaseJdbcLogger&lt;/em&gt; 代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public abstract class BaseJdbcLogger {

  protected Log statementLog;
  protected int queryStack;


  public BaseJdbcLogger(Log log, int queryStack) {
    this.statementLog = log;
    if (queryStack == 0) {
      this.queryStack = 1;
    } else {
      this.queryStack = queryStack;
    }
  }
   
  //... other code
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DEBUG模式下查看 &lt;em&gt;ConnectionLogger&lt;/em&gt; 的调用堆栈如下&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/print-sql-in-different-mybatis-version/connection_logger_stack.png&#34; alt=&#34;&amp;quot;ConnectionLogger的调用堆栈&amp;quot;&#34; title=&#34;ConnectionLogger的调用堆栈&#34; /&gt;
&lt;br /&gt;
从其调用堆栈可知log对象是通过&lt;code&gt;MappedStatement&lt;/code&gt;生成的，如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SimpleExecutor extends BaseExecutor {
   
  //... other code

  @Override
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; doQuery(MappedStatement ms,Object parameter,
                  RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
    Statement stmt = null;
    try {
      Configuration configuration = ms.getConfiguration();
      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
      //log对象通过MappedStatement生成
      stmt = prepareStatement(handler, ms.getStatementLog());
      return handler.&amp;lt;E&amp;gt;query(stmt, resultHandler);
    } finally {
      closeStatement(stmt);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看 &lt;em&gt;MappedStatement&lt;/em&gt; 的源码，发现log的生成是在 &lt;em&gt;Builder&lt;/em&gt; 方法中，如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class MappedStatement {

  public static class Builder {
    private MappedStatement mappedStatement = new MappedStatement();

    public Builder(Configuration configuration, String id, SqlSource sqlSource, SqlCommandType sqlCommandType) {
      mappedStatement.configuration = configuration;
      mappedStatement.id = id;
      mappedStatement.sqlSource = sqlSource;
      mappedStatement.statementType = StatementType.PREPARED;
      mappedStatement.parameterMap = new ParameterMap.Builder(configuration, &amp;quot;defaultParameterMap&amp;quot;, null, new ArrayList&amp;lt;ParameterMapping&amp;gt;()).build();
      mappedStatement.resultMaps = new ArrayList&amp;lt;ResultMap&amp;gt;();
      mappedStatement.sqlCommandType = sqlCommandType;
      mappedStatement.keyGenerator = configuration.isUseGeneratedKeys() &amp;amp;&amp;amp; SqlCommandType.INSERT.equals(sqlCommandType) ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;
      String logId = id;
      //可以通过设置logPrefix的方法来生成log对象
      if (configuration.getLogPrefix() != null) {
        logId = configuration.getLogPrefix() + id;
      }
      //通过logId生成log对象
      mappedStatement.statementLog = LogFactory.getLog(logId);
      mappedStatement.lang = configuration.getDefaultScriptingLanguageInstance();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过上面的代码可知log对象是由logId生成的，进一步debug发现logId是由 &lt;strong&gt;namespace+方法id&lt;/strong&gt; 组成，在本例中为 &lt;em&gt;com.lucumt.mapper.UserMappper.getUsers&lt;/em&gt; ，而前面的配置为 &lt;em&gt;log4j.logger.com.lucumt.mapper=DEBUG&lt;/em&gt; ，由于 &lt;em&gt;Log4j&lt;/em&gt; 中的log示例的继承关系，相当于 &lt;em&gt;com.lucumt.mapper.UserMappper.getUser&lt;/em&gt; 也开启了DEBUG模式，故在实际执行时可以显示打印SQL语句，运行结果如下&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/print-sql-in-different-mybatis-version/mybatis-3.4.5-print-sql-result.png&#34; alt=&#34;&amp;quot;MyBatis3.4.5时显示执行SQL&amp;quot;&#34; title=&#34;MyBatis3.4.5时显示执行SQL&#34; /&gt;
&lt;br /&gt;
利用新版 &lt;em&gt;MyBatis&lt;/em&gt; 的这一特性，我们可以实现类似如下的不同粒度sql打印&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;log4j.logger.com.xxx.mapper=DEBUG #打印xxx包下所有的执行SQL
log4j.logger.com.yyy.mapper.PersonMapper=DEBUG #打印PersonMapper下所有的执行SQL
log4j.logger.com.zzz.mapper.GroupMapper.getGroups=DEBUG #只打印getGroups对应的执行SQL  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
由前面的代码可知 &lt;em&gt;MappedStatement&lt;/em&gt; 的 &lt;em&gt;Build&lt;/em&gt; 方法在生成log对象时会检测是否有 &lt;em&gt;logPrefix&lt;/em&gt; 配置，若有则用 &lt;em&gt;logPrefix&lt;/em&gt; 来生成log对象，于是可以通过设置 &lt;em&gt;logPrefix&lt;/em&gt; 以另外一种方式配置打印sql。 可在 &lt;em&gt;MyBatis&lt;/em&gt; 配置文件中添加如下配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;settings&amp;gt;
   &amp;lt;setting name=&amp;quot;logPrefix&amp;quot; value=&amp;quot;dao.&amp;quot;/&amp;gt; &amp;lt;!-- 设置前缀为dao --&amp;gt;
   &amp;lt;setting name=&amp;quot;logImpl&amp;quot; value=&amp;quot;log4j&amp;quot;/&amp;gt; &amp;lt;!-- 设置使用log4j为日志实现类 --&amp;gt;
&amp;lt;/settings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后将 &lt;em&gt;log4j.properties&lt;/em&gt; 的配置修改为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;log4j.logger.dao=DEBUG
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果与前面相同，通过 &lt;em&gt;logPrefix&lt;/em&gt; 可以在有些时候简化sql打印配置。&lt;/p&gt;

&lt;h3 id=&#34;待分析问题:7eadf44b310a8365cd3dc766a1e45c58&#34;&gt;待分析问题&lt;/h3&gt;

&lt;p&gt;若将 &lt;em&gt;MyBatis&lt;/em&gt; 的版本变 &lt;em&gt;3.3.0&lt;/em&gt; 时，通过 &lt;em&gt;Log4j&lt;/em&gt; 配置打印SQL时，如下所示的配置方式只有部分生效，原因待分析&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;log4j.logger.com.xxx=DEBUG #可以打印SQL
log4j.logger.com.xxx.mapper=DEBUG #可以打印SQL
log4j.logger.com.xxx.mapper.UserMapper=DEBUG #不能打印SQL
log4j.logger.com.xxx.mapper.UserMapper.getUsers=DEBUG #不能打印SQL
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>在不重新编译的情况下直接修改Java Class文件中的内容</title>
      <link>https://lucumt.info/posts/modify-java-class-file-content-directly/</link>
      <pubDate>Sat, 12 Aug 2017 18:09:53 +0800</pubDate>
      
      <guid>https://lucumt.info/posts/modify-java-class-file-content-directly/</guid>
      <description>

&lt;p&gt;Java程序实际上执行的是Java文件编译后的Class文件，这是任何一个Java开发人员都了解的基本知识。若Java程序执行的结果不符合要求，通常的解决方法是先修改Java文件，重新编译成Class文件后再次执行。但有时候我们不能直接修改Java文件（如只有包含class文件的jar包），此时我们就只能直接修改Class文件，本文将展示在基于不同的需求通过可视化工具和Javassist库来直接对Class文件进行修改的方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：由于直接修改class文件会涉及到class文件结构的相关知识，所以利用此种方式时最好对class文件结构有一定的了解&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;修改class文件中的变量:4e9cb51181f8e993ffa84b42e58265dc&#34;&gt;修改Class文件中的变量&lt;/h2&gt;

&lt;p&gt;下面的代码为一个典型的输出Hello World的Java小程序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.lucumt;

public class Test {
	public static String language = &amp;quot;Java&amp;quot;;
	public static void main(String[] args) {
		sayHello();
	}

	public static void sayHello() {
		System.out.println(&amp;quot;=====Hello &amp;quot;+language+&amp;quot; World!======&amp;quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在cmd命令行中运行该程序的结果如下&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/modify-java-class-file-content-directly/simple-class-before-modifing-running-result.png&#34; alt=&#34;未修改之前的运行结果&#34; title=&#34;未修改之前的Java代码运行结果&#34; /&gt;
&lt;br /&gt;
若想将运行结果从 &lt;em&gt;Hello Java World&lt;/em&gt; 修改为 &lt;em&gt;Hello Golang China&lt;/em&gt; ，除了通过修改源代码重新编译运行这个方法之外我们还可以利用工具直接修改原有的class文件来实现。&lt;/p&gt;

&lt;p&gt;首先从 &lt;strong&gt;&lt;a href=&#34;http://set.ee/jbe/&#34; title=&#34;点击链接去下载jbe&#34;&gt;JBE&lt;/a&gt;&lt;/strong&gt; 下载 JBE(Java Bytecode Editor),JBE是一个用于浏览和修改Java Class文件的开源软件，在其官网上可以看到如下图所示的说明信息&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/modify-java-class-file-content-directly/jbe-official-introduction.png&#34; alt=&#34;JBE介绍&#34; title=&#34;JBE官方介绍&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;下载完该软件后，在该软件中打开我们要修改的Class文件&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/modify-java-class-file-content-directly/open-class-file-using-jbe.png&#34; alt=&#34;在JBE中打开文件&#34; title=&#34;在JBE中打开文件&#34; /&gt;
&lt;br /&gt;
首先我们需要将静态变量 &lt;em&gt;language&lt;/em&gt; 的值从 &lt;em&gt;Java&lt;/em&gt; 修改为 &lt;em&gt;Golang&lt;/em&gt;, 由于 &lt;em&gt;language&lt;/em&gt; 是一个静态变量，故我们需要在class文件的 &lt;em&gt;clinit&lt;/em&gt; 方法中找到该变量并修改其值。如下图所示，展开 &lt;em&gt;clinit&lt;/em&gt; 并切换到Code Editor页，可以看到 &lt;em&gt;language&lt;/em&gt; 的值为 &lt;em&gt;Java&lt;/em&gt; ，在Code Editor部分将 &lt;em&gt;Java&lt;/em&gt; 修改为 &lt;em&gt;Golang&lt;/em&gt; 然后点击Save method即可完成静态变量值的修改。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/modify-java-class-file-content-directly/jbe-modify-static-field.png&#34; alt=&#34;在JBE中修改静态变量值&#34; title=&#34;在JBE中修改静态变量值&#34; /&gt;
&lt;br /&gt;
接着展开 &lt;em&gt;sayHello&lt;/em&gt; 方法，同样切换到Code Editor页，将 &lt;em&gt;World&lt;/em&gt; 修改为 &lt;em&gt;China&lt;/em&gt; 后点击Save method，至此整个修改操作完成。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/modify-java-class-file-content-directly/jbe-modify-method-value.png&#34; alt=&#34;在JBE中修改方法输出值&#34; title=&#34;在JBE中修改方法输出值&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;在命令行中重新执行该程序，输出结果为 &lt;em&gt;Hello Golang China&lt;/em&gt; ，符合我们的要求。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/modify-java-class-file-content-directly/simple-classa-after-modifing-running-result.png&#34; alt=&#34;修改之后的运行结果&#34; title=&#34;修改之后的Java代码运行结果&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;修改class文件中的方法:4e9cb51181f8e993ffa84b42e58265dc&#34;&gt;修改Class文件中的方法&lt;/h2&gt;

&lt;p&gt;对于较为简单的修改需求我们可以利用JBE等工具来直接修改，若要对class文件进行较为复杂的修改，如增加新方法，修改已有方法的实现逻辑等，对于此种需求虽然也可以用JBE实现目的，但工作量很大，容易出错，此时JBE已经不太适合使用，需要寻找其它更快捷的方法。&lt;/p&gt;

&lt;p&gt;由于Java文件后生成的class文件是一个包含Java字节码的二进制文件，程序最终执行的就是二进制文件中的字节码，我们的需求可以归纳为如何修改Java字节码文件。前一部分通过JBE来修改class文件只不过是将这个过程进行了图形化封装，我们需要找到更底层的实现方法来适应我们的需求。&lt;/p&gt;

&lt;p&gt;此时 &lt;strong&gt;&lt;a href=&#34;http://jboss-javassist.github.io/javassist/ Javassist官网&#34;&gt;Javassist&lt;/a&gt;&lt;/strong&gt; 闪亮登场！在Javassit官网关于其的第一句介绍为 &lt;em&gt;Javassist (Java Programming Assistant) makes Java bytecode manipulation simple. It is a class library for editing bytecodes in Java&lt;/em&gt; 。Javassist天生就是为修改Java字节码而来的，它提供了源代码和字节码两种级别的API接口，为了实现的简便性，本文主要介绍利用源代码API来修改class文件。&lt;/p&gt;

&lt;p&gt;下面的代码为一个计算两个整数相加的程序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.lucumt;

public class Test1 {
	public static void main(String[] args) {
          Test1 t1 = new Test1();
          int result = t1.addNumber(3, 5);
          System.out.println(&amp;quot;result is: &amp;quot;+result);
	}
	
	public int addNumber(int a,int b){
		return a+b;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正常情况下，其输出结果如下&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/modify-java-class-file-content-directly/java-method-before-modifing-running-result.png&#34; alt=&#34;未修改方法前的运行结果&#34; title=&#34;未修改方法前的运行结果&#34; /&gt;
&lt;br /&gt;
若我们想将 &lt;em&gt;addNumber&lt;/em&gt; 的返回结果从两个数之和变为两个数立方后求和，则可以利用Javassist提供的API通过Java程序来直接修改class文件。&lt;/p&gt;

&lt;p&gt;关于如何使用Javassist，请直接参看相应的 &lt;strong&gt;&lt;a href=&#34;http://jboss-javassist.github.io/javassist/tutorial/tutorial.html&#34;&gt;入门教程&lt;/a&gt;&lt;/strong&gt; ，本文不再详细说明，利用Javassist修改 &lt;em&gt;addNumber&lt;/em&gt; 的Java代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.lucumt.test;

import java.io.IOException;

import javassist.CannotCompileException;
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtMethod;
import javassist.NotFoundException;

public class UpdateMethod {

	public static void main(String[] args) {
		updateMethod();
	}
	
	public static void updateMethod(){
		try {
			ClassPool cPool = new ClassPool(true);
		        //如果该文件引入了其它类，需要利用类似如下方式声明
			//cPool.importPackage(&amp;quot;java.util.List&amp;quot;);
			
			//设置class文件的位置
			cPool.insertClassPath(&amp;quot;D:\\Java\\eclipse\\newworkspace\\test\\bin&amp;quot;);
			
			//获取该class对象
			CtClass cClass = cPool.get(&amp;quot;com.lucumt.Test1&amp;quot;);
			
			//获取到对应的方法
			CtMethod cMethod = cClass.getDeclaredMethod(&amp;quot;addNumber&amp;quot;);
			
			//更改该方法的内部实现
			//需要注意的是对于参数的引用要以$开始，不能直接输入参数名称
			cMethod.setBody(&amp;quot;{ return $1*$1*$1+$2*$2*$2; }&amp;quot;);
			
			//替换原有的文件
			cClass.writeFile(&amp;quot;D:\\Java\\eclipse\\newworkspace\\test\\bin&amp;quot;);
			
			System.out.println(&amp;quot;=======修改方法完=========&amp;quot;);
		} catch (NotFoundException e) {
			e.printStackTrace();
		} catch (CannotCompileException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}

	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行该代码后重新执行 &lt;em&gt;Test1&lt;/em&gt; 后的结果如下，从图中可以看出运行结果符合预期&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/modify-java-class-file-content-directly/java-method-after-modifing-runnning-result.png&#34; alt=&#34;修改方法后的运行结果&#34; title=&#34;修改方法后的运行结果&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;关于 &lt;em&gt;UpdateMethod&lt;/em&gt; 工具类有如下几点说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果要修改的class文件中引入了其它类，需要调用 &lt;em&gt;ClassPool&lt;/em&gt; 中的 &lt;em&gt;importPackage&lt;/em&gt; 方法引入该类，否则程序会报错&lt;/li&gt;
&lt;li&gt;修改完后，一定要调用 &lt;em&gt;CtClass&lt;/em&gt; 中的 &lt;em&gt;writeFile&lt;/em&gt; 方法覆盖原有的class文件，否则修改不生效&lt;/li&gt;
&lt;li&gt;在修改方法的过程中若要引用方法参数，不能在修改程序代码中直接写该参数，否则程序会抛出&lt;em&gt;javassist.CannotCompileException: [source error] no such field:&lt;/em&gt; 异常。在本例中 &lt;em&gt;addNumber&lt;/em&gt; 的两个参数分别为 &lt;em&gt;a&lt;/em&gt; 和 &lt;em&gt;b&lt;/em&gt; ，在修改时不能写成&lt;code&gt;cMethod.setBody(&amp;quot;{ return a*a*a+b*b*b; }&amp;quot;)&lt;/code&gt;需要修改为&lt;code&gt;cMethod.setBody(&amp;quot;{ return $1*$1*$1+$2*$2*$2; }&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在Javassist的 &lt;strong&gt;&lt;a href=&#34;http://jboss-javassist.github.io/javassist/tutorial/tutorial2.html#intro&#34;&gt;Introspection and customization&lt;/a&gt;&lt;/strong&gt; 部分有如下一段话&lt;br /&gt;
&lt;em&gt;The parameters passed to the target method are accessible with $1, $2, &amp;hellip; instead of the original parameter names. $1 represents the first parameter, $2 represents the second parameter, and so on. The types of those variables are identical to the parameter types. $0 is equivalent to this. If the method is static, $0 is not available.&lt;/em&gt;&lt;br /&gt;
从中可知，方法中的参数从 &lt;em&gt;$1&lt;/em&gt; 开始，若该方法为非 &lt;em&gt;static&lt;/em&gt; 方法，可以用 &lt;em&gt;$0&lt;/em&gt; 来表示该方法实例自身，若该方法为 &lt;em&gt;static&lt;/em&gt; 方法，则 &lt;em&gt;$0&lt;/em&gt; 不可用&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;在class文件中增加方法:4e9cb51181f8e993ffa84b42e58265dc&#34;&gt;在Class文件中增加方法&lt;/h2&gt;

&lt;p&gt;Javassist不仅可以修改已有的方法，还可以给class文件增加新的方法。仍以前面的 &lt;em&gt;Test1&lt;/em&gt; Java代码中为例，现要求增加一个名为 &lt;em&gt;showParameter&lt;/em&gt; 的方法并在 &lt;em&gt;addNumber&lt;/em&gt; 方法中调用，其主要功能是输出 &lt;em&gt;addNumber&lt;/em&gt; 中传入的参数。利用Javassist修改class文件实现该功能的代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.lucumt.test;

import java.io.IOException;

import javassist.CannotCompileException;
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtMethod;
import javassist.CtNewMethod;
import javassist.NotFoundException;

public class AddMethod {

	public static void main(String[] args) {
		addMethod();
	}
	
	public static void addMethod(){
		try {
			ClassPool cPool = new ClassPool(true);
			cPool.insertClassPath(&amp;quot;D:\\Java\\eclipse\\newworkspace\\test\\bin&amp;quot;);
			CtClass cClass = cPool.get(&amp;quot;com.lucumt.Test1&amp;quot;);
			
			
			CtMethod cMethod = cClass.getDeclaredMethod(&amp;quot;addNumber&amp;quot;);
			
			//增加一个新方法
			String methodStr =&amp;quot;public void showParameters(int a,int b){&amp;quot; 
					    +&amp;quot;  System.out.println(\&amp;quot;First parameter: \&amp;quot;+a);&amp;quot;
					    +&amp;quot;  System.out.println(\&amp;quot;Second parameter: \&amp;quot;+b);&amp;quot;
					    +&amp;quot;}&amp;quot;;
			CtMethod newMethod = CtNewMethod.make(methodStr, cClass);
			cClass.addMethod(newMethod);
			
			//调用新增的方法
			cMethod.setBody(&amp;quot;{ showParameters($1,$2);return $1*$1*$1+$2*$2*$2; }&amp;quot;);
			cClass.writeFile(&amp;quot;D:\\Java\\eclipse\\newworkspace\\test\\bin&amp;quot;);
			
		} catch (NotFoundException e) {
			e.printStackTrace();
		} catch (CannotCompileException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}

	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行该代码后重新执行 &lt;em&gt;Test1&lt;/em&gt; 后的结果如下，从图中可以看出运行结果符合预期&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/modify-java-class-file-content-directly/java-add-method-runnning-result.png&#34; alt=&#34;新增方法后的运行结果&#34; title=&#34;新增方法后的运行结果&#34; /&gt;
&lt;br /&gt;
从上述代码可以看出，利用Javassist增加方法比修改方法更简单，先将要新增的方法内容赋值到字符串，然后分别调用相关类的 &lt;em&gt;make&lt;/em&gt; 和 &lt;em&gt;addMethod&lt;/em&gt; 方法即可。&lt;/p&gt;

&lt;h2 id=&#34;后记:4e9cb51181f8e993ffa84b42e58265dc&#34;&gt;后记&lt;/h2&gt;

&lt;p&gt;利用JBE或Javassist虽然可以实现直接修改class文件的内容，但毕竟属于不正规的做法，可能会导致后续版本不一致等问题，在条件允许的情况下还是要尽量通过修改Java文件然后重新编译的方式来实现目的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>解决EasyUI DataGrid中的行在列冻结时无法对齐的问题</title>
      <link>https://lucumt.info/posts/easyui-datagrid-row-not-align-when-column-frozen/</link>
      <pubDate>Sun, 06 Aug 2017 00:06:36 +0800</pubDate>
      
      <guid>https://lucumt.info/posts/easyui-datagrid-row-not-align-when-column-frozen/</guid>
      <description>

&lt;p&gt;相对于传统的用HTML中TABLE实现的表格，利用 &lt;strong&gt;&lt;a href=&#34;https://www.jeasyui.com&#34;&gt;EasyUI&lt;/a&gt;&lt;/strong&gt; 中的 &lt;strong&gt;&lt;a href=&#34;https://www.jeasyui.com/demo/main/index.php?plugin=DataGrid&#34;&gt;DataGrid&lt;/a&gt;&lt;/strong&gt; 实现的表格具有很多优点，如可以 &lt;em&gt;对列宽进行拖动调整、列冻结、行冻结、自定义格式化&lt;/em&gt; 等功能，故而在Web开发中得到了广泛的应用。最近自己在使用DataGrid的列冻结功能时遇到了由于某些单元格中的内容较多导致该行无法对齐的问题，由于当前在EasyUI官网中无法找到该问题的解决方案，自己研究DataGrid的实现原理后，找到了变通的解决方案，故先记录下。&lt;/p&gt;

&lt;h2 id=&#34;easyui-datagrid正常情况下的列冻结:1a1d88573c9d97df57840a524ba54e28&#34;&gt;EasyUI DataGrid正常情况下的列冻结&lt;/h2&gt;

&lt;p&gt;下图为一个常见的DataGrid使用示例，该图展示了我们在使用EasyUI DataGrid时经常会遇到的一个问题：&lt;strong&gt;由于某个列的长度很长导致表格出现滚动条&lt;/strong&gt;&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/easyui-datagrid-row-not-align-when-column-frozen/datagrid-no-frozen-column1.png&#34; alt=&#34;&amp;quot;没有冻结列时正常显示的DataGrid&amp;quot;&#34; title=&#34;没有冻结列时正常显示的DataGrid&#34; /&gt;
&lt;br /&gt;
对应的代码为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;thead&amp;gt;
   &amp;lt;tr&amp;gt;
     &amp;lt;th data-options=&amp;quot;field:&#39;name&#39;&amp;quot;&amp;gt;&amp;lt;b&amp;gt;书名&amp;lt;/b&amp;gt;&amp;lt;/th&amp;gt;
     &amp;lt;th data-options=&amp;quot;field:&#39;price&#39;,align:&#39;center&#39;,width:70&amp;quot;&amp;gt;&amp;lt;b&amp;gt;价格&amp;lt;/b&amp;gt;&amp;lt;/th&amp;gt;
     &amp;lt;th data-options=&amp;quot;field:&#39;pubdate&#39;,align:&#39;center&#39;,width:90&amp;quot;&amp;gt;&amp;lt;b&amp;gt;出版日期&amp;lt;/b&amp;gt;&amp;lt;/th&amp;gt;
     &amp;lt;th data-options=&amp;quot;field:&#39;description&#39;,width:800&amp;quot;&amp;gt;&amp;lt;b&amp;gt;简要介绍&amp;lt;/b&amp;gt;&amp;lt;/th&amp;gt;
   &amp;lt;/tr&amp;gt;
&amp;lt;/thead&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得益于EasyUI DataGrid强大的功能，当表格中列的宽度太长时，它会自动加上横向滚动条，避免像传统的HTML TABLE表格在内容过多时会自己挤成一团，通过拖动滚动条，我们可以很方便的查看表格中各列的内容。&lt;/p&gt;

&lt;p&gt;但有时候我们会运到另外一个问题，拖动滚动条时前面的某些列就不见了，如本例中的书名，在某些情况下可能会对我们的使用带来不便。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/easyui-datagrid-row-not-align-when-column-frozen/datagrid-no-frozen-column2.png&#34; alt=&#34;&amp;quot;拖动滚动条时无法看见前面的列&amp;quot;&#34; title=&#34;拖动滚动条时无法看见前面的列&#34; /&gt;
&lt;br /&gt;
此时DataGrid的列冻结功能就可以派上用场了，只需要将需要固定的列冻结即可，在本例中我想把书名列冻结，在需要修改代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;lt;thead frozen=&amp;quot;true&amp;quot;&amp;gt;
   &amp;lt;tr&amp;gt;
     &amp;lt;th data-options=&amp;quot;field:&#39;name&#39;&amp;quot;&amp;gt;&amp;lt;b&amp;gt;书名&amp;lt;/b&amp;gt;&amp;lt;/th&amp;gt;
   &amp;lt;/tr&amp;gt;
 &amp;lt;/thead&amp;gt;
 &amp;lt;thead&amp;gt;
   &amp;lt;tr&amp;gt;
     &amp;lt;th data-options=&amp;quot;field:&#39;price&#39;,align:&#39;center&#39;,width:70&amp;quot;&amp;gt;&amp;lt;b&amp;gt;价格&amp;lt;/b&amp;gt;&amp;lt;/th&amp;gt;
     &amp;lt;th data-options=&amp;quot;field:&#39;pubdate&#39;,align:&#39;center&#39;,width:90&amp;quot;&amp;gt;&amp;lt;b&amp;gt;出版日期&amp;lt;/b&amp;gt;&amp;lt;/th&amp;gt;
     &amp;lt;th data-options=&amp;quot;field:&#39;description&#39;,width:800&amp;quot;&amp;gt;&amp;lt;b&amp;gt;简要介绍&amp;lt;/b&amp;gt;&amp;lt;/th&amp;gt;
   &amp;lt;/tr&amp;gt;
 &amp;lt;/thead&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其对应的运行效果如下：&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/easyui-datagrid-row-not-align-when-column-frozen/datagrid-frozen-column1.png&#34; alt=&#34;&amp;quot;冻结列之后的DataGrid显示效果&amp;quot;&#34; title=&#34;冻结列之后的DataGrid显示效果&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;easyui-datagrid非正常情形下的列冻结效果:1a1d88573c9d97df57840a524ba54e28&#34;&gt;EasyUI DataGrid非正常情形下的列冻结效果&lt;/h2&gt;

&lt;p&gt;大多数情况下这种列冻结都能满足我们的需求，但上述冻结列正常显示有一个前提：&lt;strong&gt;表格中每一行各列的高度一致&lt;/strong&gt;，若表格中某些行中存在列高超出DataGrid正常高度的情形(25px)，在进行列冻结时就会出现冻结行和非冻结行无法对齐的问题。&lt;/p&gt;

&lt;p&gt;下图为一个列超出正常高度的DataGrid显示效果，从图中可以看出由于描述信息中的文字较多，导致正常的高度都比DataGrid默认的高度要很多，直观的显示就是不同行的高度不一致。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/easyui-datagrid-row-not-align-when-column-frozen/datagrid-no-frozen-column3.png&#34; alt=&#34;&amp;quot;列高超出正常高度时的DataGrid&amp;quot;&#34; title=&#34;列高超出正常高度时的DataGrid&#34; /&gt;
&lt;br /&gt;
此时若对该表格进列冻结，同样会出现出现如前所述的冻结效果，但 &lt;strong&gt;如果我们在一开始就将描述信息这列隐藏掉，之后通过点击等方式让该列显示，则会出现冻结行和非冻结行无法对齐的情况&lt;/strong&gt;，如下图所示&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/easyui-datagrid-row-not-align-when-column-frozen/datagrid-frozen-column-not-align-row.png&#34; alt=&#34;&amp;quot;列高超出正常高度时的DataGrid&amp;quot;&#34; title=&#34;列高超出正常高度时的DataGrid&#34; /&gt;
&lt;br /&gt;
对应的关键代码如下，也可以点击&lt;a href=&#34;https://jsfiddle.net/wch9rnr2/8/&#34;&gt;jsfiddle.net/wch9rnr2/8/&lt;/a&gt;查看完整的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;button type=&amp;quot;button&amp;quot; onclick=&amp;quot;toggleDescription()&amp;quot;&amp;gt;隐藏或显示描述信息&amp;lt;/button&amp;gt;
function toggleDescription(){
	var colOptions = $(&amp;quot;#dg&amp;quot;).datagrid(&amp;quot;getColumnOption&amp;quot;,&amp;quot;description&amp;quot;);
	var isHidden = !!colOptions.hidden;
  if(isHidden){
     $(&amp;quot;#dg&amp;quot;).datagrid(&amp;quot;showColumn&amp;quot;,&amp;quot;description&amp;quot;);
  }else{
     $(&amp;quot;#dg&amp;quot;).datagrid(&amp;quot;hideColumn&amp;quot;,&amp;quot;description&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上图可以看出此时书名列和其余列已经无法对齐，严重印象了我们的使用效果。&lt;/p&gt;

&lt;h2 id=&#34;解决方案:1a1d88573c9d97df57840a524ba54e28&#34;&gt;解决方案&lt;/h2&gt;

&lt;p&gt;要想解决该问题，首先需要找出该问题产生的根源，利用Chrome或其它浏览器调试工具可知，当有部分列冻结时，DataGrid表格被分成了两个不同的表格，一个是冻结的表格，一个是未冻结的表格。进一步分析发现导致无法对齐的问题根源为 &lt;strong&gt;由于两个表格中同一行的高度不同，导致实际显示时看起来表格行没有对齐&lt;/strong&gt;。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/easyui-datagrid-row-not-align-when-column-frozen/datagrid-frozen-source-element.png&#34; alt=&#34;&amp;quot;DataGrid列冻结时的源代码&amp;quot;&#34; title=&#34;DataGrid列冻结时的源代码&#34; /&gt;
&lt;br /&gt;
找到问题根源后，要解决该问题，我们只需要让表格中每一行高度保持一致即可，具体来说就是 &lt;strong&gt;要在EasyUI DataGrid渲染表格之前将同一行的每一个单元格的高度保持一致即可&lt;/strong&gt;。问题转化为寻找适当的方法切入点来修改单元格高度，即对单元格的高度进行校验。&lt;/p&gt;

&lt;p&gt;为了修正单元格的高度，我们需要首先找出特定行已冻结单元格和未冻结单元格的高度，而要找出它们的高度必须要等EasyUI DataGrid渲染完毕之后才能获取到其实际高度。本列中由于点击按钮时会对最后一列进行隐藏或显示，所以我们可以在&lt;code&gt;toggleDescription&lt;/code&gt;方法的最后执行相应的校验逻辑。&lt;/p&gt;

&lt;p&gt;进一步调试分析后发现，对于DataGrid中的某一个数据行而言，冻结列的单元格高度都一样，非冻结列的单元格高度也一样，&lt;strong&gt;为了保持整行对齐，我们只需要高度较小的单元格的高度设置为高度较高的单元格的高度即可。考虑到有些影响列，同时为了简化实现，可以将及解决方案从设置单元格的高度更改为设置特定行在冻结和非冻结部分的行高即可&lt;/strong&gt;。至于如何设置EasyUI DataGrid中数据行的高度，请参见EasyUI作者&lt;strong&gt;stworthy&lt;/strong&gt;大神在&lt;a href=&#34;http://www.jeasyui.com/forum/index.php?topic=4951.0&#34;&gt;datagrid dynamically set / reset row height&lt;/a&gt;中的回复，在该问题中，&lt;strong&gt;stworthy&lt;/strong&gt;给出的解决方案如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var dg = $(&#39;#dg&#39;);
dg.datagrid(&#39;options&#39;).rowHeight = 40;
for(var i=0; i&amp;lt;dg.datagrid(&#39;getRows&#39;).length; i++){
    dg.datagrid(&#39;refreshRow&#39;, i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基于此，我们可以将&lt;code&gt;toggleDescription&lt;/code&gt;方法改进如下，完整的代码请参见&lt;a href=&#34;https://jsfiddle.net/wch9rnr2/9/&#34;&gt;jsfiddle.net/wch9rnr2/9/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function toggleDescription(){
  var dg = $(&amp;quot;#dg&amp;quot;);
	var colOptions = dg.datagrid(&amp;quot;getColumnOption&amp;quot;,&amp;quot;description&amp;quot;);
	var isHidden = !!colOptions.hidden;
  if(isHidden){
     dg.datagrid(&amp;quot;showColumn&amp;quot;,&amp;quot;description&amp;quot;);
  }else{
     dg.datagrid(&amp;quot;hideColumn&amp;quot;,&amp;quot;description&amp;quot;);
  }
 
 var dgOptions = dg.datagrid(&amp;quot;options&amp;quot;);
 var rows = dg.datagrid(&amp;quot;getRows&amp;quot;);
 var row = null;
 var tr = null;
 var height1 =0;
 var height2 =0;
 for(var i in rows){
    row = rows[i];
	  tr = dgOptions.finder.getTr(dg[0],i);
	  height1 = $(tr[0]).height();//冻结行的高度
	  height2 = $(tr[1]).height();//非冻结行的高度
	  if((isHidden&amp;amp;&amp;amp;height2&amp;gt;height1)||(!isHidden&amp;amp;&amp;amp;height1&amp;gt;height2)){
         //冻结部分在显示时的高度取较大的那个
         $(tr[0]).css(&amp;quot;height&amp;quot;,height2+&amp;quot;px&amp;quot;);
	  }
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时当我们点击按钮来显示描述信息时，DataGrid中的每一行都已经对齐，如下图所示，至此问题获得解决！&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/easyui-datagrid-row-not-align-when-column-frozen/datagrid-frozen-column2.png&#34; alt=&#34;&amp;quot;重新校验后的DataGrid冻结列显示效果&amp;quot;&#34; title=&#34;重新校验后的DataGrid冻结列显示效果&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;在实际使用中，我发现有时候上述JavaScript校验代码还是不能正常工作，其原因为在执行校验代码时，EasyUI DataGrid还没有完全渲染完毕，此时可以利用&lt;strong&gt;&lt;a href=&#34;https://www.w3schools.com/JSREF/met_win_setTimeout.asp&#34;&gt;setTimeout&lt;/a&gt;&lt;/strong&gt;函数来延后校验代码的执行，修改后的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function toggleDescription(){
  var dg = $(&amp;quot;#dg&amp;quot;);
	var colOptions = dg.datagrid(&amp;quot;getColumnOption&amp;quot;,&amp;quot;description&amp;quot;);
	var isHidden = !!colOptions.hidden;
  if(isHidden){
     dg.datagrid(&amp;quot;showColumn&amp;quot;,&amp;quot;description&amp;quot;);
  }else{
     dg.datagrid(&amp;quot;hideColumn&amp;quot;,&amp;quot;description&amp;quot;);
  }
 
 var dgOptions = dg.datagrid(&amp;quot;options&amp;quot;);
 var rows = dg.datagrid(&amp;quot;getRows&amp;quot;);
 var row = null;
 var tr = null;
 var height1 =0;
 var height2 =0;
 setTimeout(function(){
   for(var i in rows){
      row = rows[i];
      tr = dgOptions.finder.getTr(dg[0],i);
      height1 = $(tr[0]).height();//冻结行的高度
      height2 = $(tr[1]).height();//非冻结行的高度
      if((isHidden&amp;amp;&amp;amp;height2&amp;gt;height1)||(!isHidden&amp;amp;&amp;amp;height1&amp;gt;height2)){
           //冻结部分在显示时的高度取较大的那个
           $(tr[0]).css(&amp;quot;height&amp;quot;,height2+&amp;quot;px&amp;quot;);
      }
    } 
 },1000);//延后一秒执行
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;考虑到实际使用中EasyUI DataGrid的渲染时间无法确定，用&lt;strong&gt;&lt;a href=&#34;https://www.w3schools.com/JSREF/met_win_setTimeout.asp&#34;&gt;setTimeout&lt;/a&gt;&lt;/strong&gt;并非最优解，希望EasyUI官方后续能为该问题提供更合理的解决方案!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>4. [译]并发的模型</title>
      <link>https://lucumt.info/posts/java-concurrency/concurrency-models/</link>
      <pubDate>Sat, 05 Aug 2017 00:10:11 +0800</pubDate>
      
      <guid>https://lucumt.info/posts/java-concurrency/concurrency-models/</guid>
      <description>

&lt;p&gt;本文翻译自&lt;strong&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/concurrency-models.html&#34;&gt;Java Concurrency / Concurrency Models&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;并发系统可以使用不同的并发模型来实现，并发模型是指线程在系统中如何写作来完成给定的任务。不同的并发模型以不同的方式拆分任务，线程间以不同的方式协作和通信，本文将深入研究在撰写本文时最流行并发模型(2015年)。&lt;/p&gt;

&lt;h2 id=&#34;并发模型和分布式系统相似之处:9ebec4031501f63cd264123a50a14d31&#34;&gt;并发模型和分布式系统相似之处&lt;/h2&gt;

&lt;p&gt;本文中描述的并发模型与分布式系统中使用的架构类似，在一个并发系统中，不同的线程之间互相通信，在一个分布式系统中，不同的进程间彼此通信（这些进程可能在不同的电脑上）。线程和进程在本质上时非常相似的，这就是为什么不同的并发模型与不同的分布式系统架构通常看起来相似。&lt;/p&gt;

&lt;p&gt;虽然分布式系统还有额外的挑战，如网络故障、远程计算机或进程关闭等，但一个运行在大型服务器上的并发系统也可能会遇到类似的问题，如CPU故障、网卡故障、硬盘故障等，虽然其发生的概率较低，但理论上仍然可以发生。&lt;/p&gt;

&lt;p&gt;由于并发模型和分布式系统架构类似，它们通常可以相互借鉴，比如在线程中分配工作的模型通常与分布式系统中的负载均衡类似，它们的错误处理手段也类似，例如日志（logging）、故障切换（fail-over）和等幂性任务（idempotency of jobs）等。&lt;/p&gt;

&lt;h2 id=&#34;并行工作者模型-parallel-workers-model:9ebec4031501f63cd264123a50a14d31&#34;&gt;并行工作者模型(Parallel Workers model)&lt;/h2&gt;

&lt;p&gt;并行工作者模型是本文要说明的第一个并发模型，该模型会将系统中到来的任务分配给不同的工作者，如下图所示：&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/concurrency-models/concurrency-models-1.png&#34; alt=&#34;&amp;quot;并行工作者模型&amp;quot;&#34; title=&#34;并行工作者模型&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;并发模型中有一个“委托者”将到来的任务分配给不同的工作者，每个工作者完成整个任务，每个工作者在不同的线程中（也有可能在不同的CPU）并行工作。&lt;/p&gt;

&lt;p&gt;如果一个汽车厂采用了并行工作者模型，那么每辆汽车将由一个工人根据说明书从头到尾来制造。&lt;/p&gt;

&lt;p&gt;并行工作者模型是Java应用程序中使用最广泛的并发模型（尽管这种情形正在发生变化），&lt;strong&gt;&lt;a href=&#34;https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/package-summary.html&#34;&gt;java.util.concurrent &lt;/a&gt;&lt;/strong&gt; 中的许多包都被设计用于此模型，你也可以在Java企业级服务器的设计中找到此模型的应用踪迹。&lt;/p&gt;

&lt;h2 id=&#34;并行工作者模型的优点:9ebec4031501f63cd264123a50a14d31&#34;&gt;并行工作者模型的优点&lt;/h2&gt;

&lt;p&gt;并行工作者模型的优点是理解容易，当要增加应用程序的并行能力时我们只需添加更多的工作者即可。&lt;/p&gt;

&lt;p&gt;例如，假设你想实现一个网络爬虫，你可以使用不同数量的工作者线程来爬取制定数量的页面，根据结果来决定使用多少个工作者线程具有最短的抓取时间（同时意味着最优性能）。由于网络爬虫是IO密集型工作，在等待下载数据时会浪费大量时间，若每个CPU只运行一个线程时效率不高，所以最终的结果可能会是在电脑中一个CPU/内核运行多个线程。&lt;/p&gt;

&lt;h2 id=&#34;并行工作者模型的缺点:9ebec4031501f63cd264123a50a14d31&#34;&gt;并行工作者模型的缺点&lt;/h2&gt;

&lt;p&gt;并行工作者模式在其简单外表之下还有若干缺点，我将在以下部分说明其中最为明显的几个。&lt;/p&gt;

&lt;h3 id=&#34;状态共享将使复杂性增加:9ebec4031501f63cd264123a50a14d31&#34;&gt;状态共享将使复杂性增加&lt;/h3&gt;

&lt;p&gt;实际上并行工作者模型比上面说明的还要复杂一些，并行工作者通常需要访问一些共享数据，它们可能存储在内存中也可能存在数据库中，下面的图标展示了这种情形是如何是的并行工作者模型变得复杂的。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/concurrency-models/concurrency-models-2.png&#34; alt=&#34;&amp;quot;并行工作者访问共享数据&amp;quot;&#34; title=&#34;并行工作者访问共享数据&#34; /&gt;
&lt;br /&gt;
其中的一些共享状态可能在类似于任务队列的通信过程中，但是另外一些共享状态可能是商业数据、缓存数据、数据库的连接池等。一旦共享状态引入到了并行工作者模型，问题就开始变得复杂。线程需要一种方式来访问共享数据以确保一个线程对共享数据的更改对其它线程是可见的（将其推送到主内存中，而不是仅停留在执行线程的CPU缓存中）。线程间需要避免竞争条件、死锁和其它共享状态相关的问题。&lt;/p&gt;

&lt;p&gt;另外，当线程间在等待彼此访问共享数据结构时，会降低应用程序的并行性。许多并发数据结构都是阻塞式的，这意味着在给定时间只有一个或一组有限的线程可以访问它们，这可能导致线程对这些共享数据的竞争，高度竞争将会导致访问共享数据的代码从本质上变为串行执行。&lt;/p&gt;

&lt;p&gt;现代的 &lt;strong&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/non-blocking-algorithms.html&#34;&gt;非阻塞并行算法(non-blocking concurrency algorithms )&lt;/a&gt;&lt;/strong&gt; 可能会减少竞争和提高性能，但是非阻塞算法很难实现。&lt;/p&gt;

&lt;p&gt;持久化数据结构是另外一种选择，一个持久化数据在自身被修改时会始终保留之前的值。因此，如果多个线程同时操作一个持久化数据并且其中一个修改了该数据，该线程会得到新数据的引用，而其它线程在则保持着对未修改的旧数据的引用，从而依旧保持一致。在Scala编程中包含若干个持久化的数据结构。&lt;/p&gt;

&lt;p&gt;虽然持久化数据结构是并发修改共享数据的一种看似优雅的解决方案，但其执行性能并不理想。例如，一个持久化的列表会把新元素加入其首部并且返回对该新增元素的引用（它将会指向列表的其余元素）。所有其它的线程仍然保持着对先前列表中第一个元素的引用，对这些线程而言该列表并没有发生修改，它们看不见新增加的元素。&lt;/p&gt;

&lt;p&gt;这种持久化的列表可以用链表来实现，不幸的是，现在的硬件并不能很好的支持链表，链表中的每一个元素都是一个单独的对象，这些对象可以遍布计算机的内存。现在的CPU在访问连续的内存地址时速度更快，因此实现为数组(Array)结构会获得更高的性能。对于一个以数组方式存储的数据而言，CPU缓存可以一次将更大的数组块加载到缓存中，一旦数据加载完毕，CPU可以直接在缓存中访问这些数据，而这对于元素分散在RAM中的链表而言是不太可能实现的。&lt;/p&gt;

&lt;h3 id=&#34;无状态的工作者:9ebec4031501f63cd264123a50a14d31&#34;&gt;无状态的工作者&lt;/h3&gt;

&lt;p&gt;共享状态可以被系统中的其它线程修改，因此工作者(workers)在每次需要它们时都必须重新读取该状态，以确保它在最新的副本上工作，无论共享状态是保存在内存还是外部数据库中，都是如此。一个工作者不在其内部保存状态（而是在每次需要时都重新读取），我们称之为无状态。&lt;/p&gt;

&lt;h3 id=&#34;任务顺序的不确定:9ebec4031501f63cd264123a50a14d31&#34;&gt;任务顺序的不确定&lt;/h3&gt;

&lt;p&gt;并行工作者模型的另一个缺点是任务执行的顺序无法确定。没有办法来确保某个任务最先执行或最后执行，任务A在任务B之前分配给一个工作者，但是任务B可能先于任务A执行。&lt;/p&gt;

&lt;p&gt;并能工作者模型的不确定性使得很难在任何给定的时间点推理系统的状态，它同样使得确保一个任务在另外一个任务之前执行变得更难（如果可能）。&lt;/p&gt;

&lt;h2 id=&#34;流水线模型-assembly-line:9ebec4031501f63cd264123a50a14d31&#34;&gt;流水线模型（Assembly Line）&lt;/h2&gt;

&lt;p&gt;第二种并发模型我称之为流水线模型，我选择名称以符合早期“并行工作者”的含义。在不同的平台/社区中，其他的开发人员或许使用其它的名称，如反应式系统(reactive systems)，或事件驱动系统(event driven systems)，下图是流水线并发模型的一个展示&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/concurrency-models/concurrency-models-3.png&#34; alt=&#34;&amp;quot;流水线并发模型&amp;quot;&#34; title=&#34;流水线并发模型&#34; /&gt;
&lt;br /&gt;
这些工作者就像工厂里的工人一样组织起来，每个工作者只完成整个任务的一部分，当该部分任务完成时，该工作者将任务转移到下一个工作者。每个工作者都在自己的线程中运行，并且没有与其它的工作者共享状态，因此流水线模型有时也被称之为无共享的并发模型。&lt;/p&gt;

&lt;p&gt;流水线模型通常用于系统中的非阻塞IO操作，非阻塞IO意味着当一个工作者(worker)开始一个IO操作时(如从网络读取文件或数据)，该工作者(worker)不必等待IO操作结束。IO操作通常较慢，因此等待IO操作完成是对CPU时间的浪费，CPU可以在此时做一些其它事情。当IO操作完成时，IO操作的结果（如数据状态读取或输入写入）会传给下一个工作者(worker)。&lt;/p&gt;

&lt;p&gt;使用非阻塞IO时，IO操作的结果决定了工作者(worker)之间的边界，一个工作者(worker)在不得不开始IO操作之前可以尽可能的完成任务，然后放弃对该任务的控制，当IO操作结束时，在流水线上的另一个工作者(worker)以类似的方式继续完成该任务，直到它不得不开始IO操作。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/concurrency-models/concurrency-models-4.png&#34; alt=&#34;&amp;quot;非阻塞IO操作&amp;quot;&#34; title=&#34;非阻塞IO操作&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;实际中，上述这些任务可能不会沿着一条流水线流动，因为大多数操作系统可以同时运行多个任务，这些任务根据实际需求沿着流水线逐个的被工作者处理。在实际使用中可能会有多个虚拟流水线同时运行，下图展示了在实际使用中任务如何在这种流水线上流转。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/concurrency-models/concurrency-models-5.png&#34; alt=&#34;&amp;quot;多条流水线的模型&amp;quot;&#34; title=&#34;多条流水线的模型&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;任务甚至可以转发给多个工作者进行并发处理，例如，一个任务可以被同时转发给一个任务执行器和一个任务日志记录器。下图展示了如何将三条装配线的中任务转发给同一个工作者完成（中间装配线上的最后一个工人）：&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/concurrency-models/concurrency-models-6.png&#34; alt=&#34;&amp;quot;多条流水线指向同一个工作者&amp;quot;&#34; title=&#34;多条流水线指向同一个工作者&#34; /&gt;
&lt;br /&gt;
流水线甚至可以做的比上面展示的更复杂。&lt;/p&gt;

&lt;h3 id=&#34;响应式-事件驱动系统:9ebec4031501f63cd264123a50a14d31&#34;&gt;响应式、事件驱动系统&lt;/h3&gt;

&lt;p&gt;使用流水线并发模型的系统有时候也被称之为 &lt;em&gt;响应式系统&lt;/em&gt; 或 &lt;em&gt;事件驱动系统&lt;/em&gt; 。系统工作者在事件发生时做出对应的响应：从外部接收消息或转发给其它工作者等。事件驱动的例子可能是传入的HTTP请求，也可能是某个文件完成加载到内存中等。&lt;/p&gt;

&lt;p&gt;在写作本文时，已经有一些有趣的响应式/事件驱动平台可以使用，并且在将来会出现更多的。其中一些比较受欢迎的如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;http://tutorials.jenkov.com/vert.x/index.html&#34;&gt;Vert.x&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Akka&lt;/li&gt;
&lt;li&gt;Node.JS (JavaScript)&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对我个人而言，我发现Vert.x十分有趣(尤其是像我这种对Java/JVM落伍的人)。&lt;/p&gt;

&lt;h3 id=&#34;参与者-actors-与管道-channels-对比:9ebec4031501f63cd264123a50a14d31&#34;&gt;参与者(Actors)与管道(Channels)对比&lt;/h3&gt;

&lt;p&gt;参与者（Actors）和管道（Channels）是两种类似的流水线（响应式/事件驱动）模型。&lt;/p&gt;

&lt;p&gt;在参与者模型中，每个工作者被称之为一个参与者，参与者之间可以直接发消息给对方，这些消息以异步方式来发送和处理。参与者可以用于处理如前所述的一个或多个流水线任务，下图展示了这种模型：&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/concurrency-models/concurrency-models-7.png&#34; alt=&#34;&amp;quot;参与者模型&amp;quot;&#34; title=&#34;参与者模型&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;在管道(Channel)模型中，工作者之间不直接互相沟通，相反地，他们会将消息发布到不同的管道中，其他的工作者可以在这些管道上收听消息，同时消息发送者不必知道谁在收听消息。下图展示了该模型：&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/concurrency-models/concurrency-models-8.png&#34; alt=&#34;&amp;quot;管道模型&amp;quot;&#34; title=&#34;管道模型&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;在写作本文时，管道模型对我而言似乎更灵活：一个工作者不必知道在流水线上的哪个工作者要处理接下来的任务，它只需要知道需要将任务转发到哪个管道（或发送消息哪个管道等），在管道中的收听者可以订阅和取消订阅而不会影响到往管道中正在写入的工作者，这允许工作者之间有某种程度的低耦合。&lt;/p&gt;

&lt;h2 id=&#34;流水线模型-assembly-line-的优点:9ebec4031501f63cd264123a50a14d31&#34;&gt;流水线模型（Assembly Line）的优点&lt;/h2&gt;

&lt;p&gt;相对于并行工作者模型，流水线模型有一些优点，在接下来的部分，我会叙述其中最突出的几个优点。&lt;/p&gt;

&lt;h3 id=&#34;无共享状态:9ebec4031501f63cd264123a50a14d31&#34;&gt;无共享状态&lt;/h3&gt;

&lt;p&gt;工作者之间不共享状态的情形意味着它们可以在实现时不必考虑在状态共享时所遇到的各种并发问题，这让工作者的实现变得更加容易，在实现工作者时可以假设只有一个线程在处理该工作，本质上就是一个单线程实现。&lt;/p&gt;

&lt;h3 id=&#34;有状态的工作者:9ebec4031501f63cd264123a50a14d31&#34;&gt;有状态的工作者&lt;/h3&gt;

&lt;p&gt;由于工作者知道没有其它线程修改它们的数据，这些工作者可以具有状态。在说有状态时我的意思是它们可以保留在内存中操作所需的数据，只有写入才会改变最终的外部存储系统。因此，一个有状态的工作者通常比无状态的工作者执行更快。&lt;/p&gt;

&lt;h3 id=&#34;更好的硬件协同:9ebec4031501f63cd264123a50a14d31&#34;&gt;更好的硬件协同&lt;/h3&gt;

&lt;p&gt;单线程代码的优点在于它通常更符合底层硬件的工作原理。首先你通常可以创建更优化的数据结构和算法当你能假定代码会以单线程模式执行。&lt;/p&gt;

&lt;p&gt;其次,如前所述单线程有状态的工作者可以在内存中缓存数据，当数据在内存中缓存时，有很大的概率该数据也会被缓存到CPU缓存中，这样数据获取变得更快。&lt;/p&gt;

&lt;p&gt;当代码以一种自然受益于底层硬件工作原理的方式编写时，我称之为 &lt;em&gt;硬件协调*，有些开发者称之为 *mechanical sympathy&lt;/em&gt; ，我更倾向于硬件协同因为计算机只有很少的机械部件，同时单词“sympathy”在这种情况下被用作比喻“更高的匹配”，而我认为单词“conform”能更高的传达其含义。不管怎么说，这些都是吹毛求疵，可以使用你喜欢的任何术语来描述。&lt;/p&gt;

&lt;h3 id=&#34;任务可排序:9ebec4031501f63cd264123a50a14d31&#34;&gt;任务可排序&lt;/h3&gt;

&lt;p&gt;根据流水线模型实现的并发系统使得排序变得可能，任务排序使得在任何给定时间点更容易理解系统的状态。此外，你可以将所有传入的任务写入日志，如果系统的任何部分发生故障，则可以使用该日志从头重建系统的状态。这些任务以某种顺序写入日志，这个顺序称为该任务顺序，下图展示了这种设置如何实现：&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/concurrency-models/concurrency-models-8.png&#34; alt=&#34;&amp;quot;任务可排序&amp;quot;&#34; title=&#34;任务可排序&#34; /&gt;
&lt;br /&gt;
确保一个任务的顺序实现起来不一定容易，但通常是可能的。如果你可以实现的话，它将会大大简化类似于数据备份、恢复数据、复制数据等的任务，这些都可以通过日志文件来完成。&lt;/p&gt;

&lt;h2 id=&#34;流水线模型-assembly-line-的缺点:9ebec4031501f63cd264123a50a14d31&#34;&gt;流水线模型（Assembly Line）的缺点&lt;/h2&gt;

&lt;p&gt;流水线模型的最主要缺点是通常将执行一个任务分配到多个工作者，因此，当项目中有多个类时，将难以准确的看出哪段代码在执行给定的任务。&lt;/p&gt;

&lt;p&gt;代码编写也可能会变得更难，工作者代码有时候被写作回调处理器(callback handlers)。在代码中有太多嵌套的回调处理器时可能会导致某些开发人员所谓的 &lt;em&gt;回调陷阱(callback hell)&lt;/em&gt; 。回调陷阱简单的说就是在所有的回调中很难追踪代码真正在干啥以及确保每个回调都可以访问它需要的数据。&lt;/p&gt;

&lt;p&gt;而使用并行工作者模型，这往往很容易。你可以打开对应的工作者代码，并从头到尾读取要执行的代码。当然，并行工作者模型也可能传播到不同的类中，但是要执行的序列通常更容易从代码中读取。&lt;/p&gt;

&lt;h2 id=&#34;功能并行-functional-parallelism-模型:9ebec4031501f63cd264123a50a14d31&#34;&gt;功能并行(Functional Parallelism)模型&lt;/h2&gt;

&lt;p&gt;功能\函数并行模型是第三种并发模型，最近谈论得很多(2015)。&lt;/p&gt;

&lt;p&gt;功能\函数并行性的基本思想是通过函数调用实现程序，功能可以被看作是发送消息到彼此的“代理”或“角色”，就像流水线并发模型（AKA反应或事件驱动系统）一样，当一个函数调用另一个函数时，类似于消息发送。&lt;/p&gt;

&lt;p&gt;传递给函数的所有参数都被复制，所以在接收函数之外没有任何实体可以操纵数据，这种复制对于对于避免共享数据的条件竞争至关重要，它使得函数执行类似于原子操作，每个函数调用都可以独立于任何其他函数调用执行。&lt;/p&gt;

&lt;p&gt;当每个函数调用可以独立执行时，可以在单独的CPU上执行每个函数调用，这意味着，在多个CPU上可以并行执行功能实现的算法。&lt;/p&gt;

&lt;p&gt;使用Java 7，我们得到了包含 &lt;em&gt;ForkJoinPool&lt;/em&gt; 模型的 &lt;strong&gt;java.util.concurrent&lt;/strong&gt; 包，可以帮助您实现类似于功能并行性的功能，而使用Java 8，我们将得到并行流，可以帮助您并行化大型集合的迭代。请记住，有开发人员批评 &lt;em&gt;ForkAndJoinPool&lt;/em&gt; 模型（您可以在我的ForkAndJoinPool教程中找到一个相应的批评链接）。&lt;/p&gt;

&lt;p&gt;关于功能\函数并行的难点在于知道哪个函数调用需要并行化，跨CPU的协调功能调用带来了一定的开销。只有由功能/函数完成的工作单位具有一定的大小，才能值得这个开销，如果函数调用非常小，尝试并行化它们可能比单个线程的单个CPU执行更慢。&lt;/p&gt;

&lt;p&gt;从我的理解（事实上根本不完美），您可以使用事件响应驱动模型来实现实现算法，并实现与功能并行性相似的工作分解。在我看来，通过事件响应驱动模型，你可以掌握如何来实现并行化。&lt;/p&gt;

&lt;p&gt;另外，只有当前任务是程序执行的唯一任务时，将任务分配给多个CPU，协调开销才有意义。然而，如果系统同时执行多个其他任务（如Web服务器，数据库服务器和许多其它系统），则无需尝试并行化单个任务。计算机中的其它CPU可能正在忙于处理其它任务，所以没有理由试图用较慢的功能并行任务来打扰他们。如有可能，你最好使用流水线并发模型，因为它在以单线程模式顺序执行的程序中具有更少的开销，并且更好的符合底层硬件的工作原理。&lt;/p&gt;

&lt;h2 id=&#34;孰优孰劣:9ebec4031501f63cd264123a50a14d31&#34;&gt;孰优孰劣&lt;/h2&gt;

&lt;p&gt;那么，哪种并发模型更好呢？&lt;/p&gt;

&lt;p&gt;通常情况下，答案取决于你的系统应该做什么。 如果你的工作自然并行，独立，无需共享状态，则可以使用并行工作模型来实现系统。但许多任务不是自然并行和独立的，对于这些类型的系统，我相信流水线并发模型比缺点有更多的优点，比并行工作模型更有优势。你甚至不需要自己编写所有的流水线路基础设施，像Vert.x这样的现代平台为你已经实现了很多。 就个人而言，我将探索在Vert.x等平台上运行的设计，以便我的下一个项目。我个人感觉JavaEE没有尽头。&lt;/p&gt;

&lt;p&gt;&amp;lt;–翻译结束!–&amp;gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在MyEclipse项目中不能打开birt报表的解决方法</title>
      <link>https://lucumt.info/posts/cannot-open-birt-report-in-myeclipse-project/</link>
      <pubDate>Fri, 07 Apr 2017 10:47:28 +0800</pubDate>
      
      <guid>https://lucumt.info/posts/cannot-open-birt-report-in-myeclipse-project/</guid>
      <description>&lt;p&gt;由于业务要求，需要在利用MyEclipse中开发的Web项目中添加&lt;code&gt;Birt&lt;/code&gt;报表统计功能，新建完一个 &lt;em&gt;report.rptdesign&lt;/em&gt; 文件后双击该文件出现如下错误:&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/cannot-open-birt-report-in-myeclipse-project/cannot-open-birt.png&#34; alt=&#34;无法打开报表文件&#34; title=&#34;无法打开birt报表文件&#34; /&gt;
&lt;br /&gt;
错误信息提示MyEclipse无法打开 &lt;em&gt;Birt&lt;/em&gt; 报表编辑器，对于此种情况，网上搜索相应的解决方案后一般都让我们给该项目添加报表支持，即选中该项目，然后右键 &lt;em&gt;MyEclipse&lt;/em&gt; -&amp;gt; &lt;em&gt;Add Report  Capabilities&lt;/em&gt; 来对该项目添加 &lt;em&gt;Birt&lt;/em&gt; 报表支持。此种方式虽能解决问题，但却同时额外的引入了系统内置的 &lt;em&gt;Birt&lt;/em&gt; jar包和相应的report文件夹，给我们的项目造成了一定的干扰。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/cannot-open-birt-report-in-myeclipse-project/birt-project-in-myeclipse.png&#34; alt=&#34;birt项目&#34; title=&#34;MyEclipse中的birt项目&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;分析上述添加完 &lt;em&gt;Birt&lt;/em&gt; 报表支持的项目文件后，可发现与普通的Java Web项目相比  &lt;em&gt;.project&lt;/em&gt; 文件在 &lt;em&gt;natures&lt;/em&gt; 下面多了一个  &lt;em&gt;com.genuitec.eclipse.reporting.reportnature&lt;/em&gt; 的配置项，而该配置项正是用于在项目中支持 &lt;em&gt;Birt&lt;/em&gt; 报表操作。&lt;/p&gt;

&lt;p&gt;据此，我们可以采用另外一个方式来解决在MyEclipse中无法打开 &lt;em&gt;Birt&lt;/em&gt; 报表的问题：&lt;strong&gt;将 &lt;em&gt;com.genuitec.eclipse.reporting.reportnature&lt;/em&gt; 配置项添加到当前项目 &lt;em&gt;.project&lt;/em&gt; 文件的 &lt;em&gt;natures&lt;/em&gt; 配置项下面&lt;/strong&gt;，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;projectDescription&amp;gt;
    &amp;lt;name&amp;gt;teq&amp;lt;/name&amp;gt;
    &amp;lt;comment&amp;gt;&amp;lt;/comment&amp;gt;
    &amp;lt;projects&amp;gt;
    &amp;lt;/projects&amp;gt;
    &amp;lt;buildSpec&amp;gt;
       ...
    &amp;lt;/buildSpec&amp;gt;
    &amp;lt;natures&amp;gt;
        &amp;lt;!--添加报表支持 --&amp;gt;
        &amp;lt;nature&amp;gt;com.genuitec.eclipse.reporting.reportnature&amp;lt;/nature&amp;gt;
        &amp;lt;nature&amp;gt;com.genuitec.eclipse.j2eedt.core.webnature&amp;lt;/nature&amp;gt;
        &amp;lt;nature&amp;gt;org.eclipse.jdt.core.javanature&amp;lt;/nature&amp;gt;
        &amp;lt;nature&amp;gt;org.eclipse.wst.jsdt.core.jsNature&amp;lt;/nature&amp;gt;
    &amp;lt;/natures&amp;gt;
&amp;lt;/projectDescription&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用此种方式既可解决无法打开 &lt;em&gt;Birt&lt;/em&gt; 报表问题，又能避免添加冗余的jar文件和文件夹，给我们的开发省去不必要的麻烦。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3. [译]多线程的成本</title>
      <link>https://lucumt.info/posts/java-concurrency/multithreading-costs/</link>
      <pubDate>Sat, 01 Apr 2017 21:57:30 +0800</pubDate>
      
      <guid>https://lucumt.info/posts/java-concurrency/multithreading-costs/</guid>
      <description>

&lt;p&gt;本文翻译自&lt;strong&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/costs.html&#34;&gt;Java Concurrency / Multithreading Costs&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从一个单线程程序切换为多线程程序在给我们带来好处的同时也会产生一些额外的成本，不要因为会使用多线程就将一个程序变为多线程实现。在准备使用多线程时，我们应该有一个清楚的认识：使用多线程带来的好处大于其成本，当有不确定时，我们应该尝试度量应用程序的性能和响应性来决定是否采用多线程，而不是靠猜来决定。&lt;/p&gt;

&lt;h2 id=&#34;更复杂的设计:40e6cc49e0f5e4f0e9401d25e902878f&#34;&gt;更复杂的设计&lt;/h2&gt;

&lt;p&gt;尽管多线程应用程序的某些部分比单线程应用程序更简单，但其它部分却更为复杂。在执行通过多线程访问共享数据时需要特别注意，同时多线程间的交互也不是那么简单,由不正确的线程同步引起的错误可能会非常难以检测、复现和修复。&lt;/p&gt;

&lt;h2 id=&#34;上下文切换开销:40e6cc49e0f5e4f0e9401d25e902878f&#34;&gt;上下文切换开销&lt;/h2&gt;

&lt;p&gt;当CPU从执行一个线程切换到执行另外一个线程时，CPU需要保存当前线程的本地数据，程序指针等，并加载下一个线程的本地数据，程序指针等来执行线程，这种切换被称作上下文切换，CPU从一个线程的上下文中执行切换到在另一个线程的上下文中执行。&lt;/p&gt;

&lt;p&gt;上下文切换的代价并不便宜，在线程间要避免不必要的切换。可以在维基百科上阅读 &lt;strong&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Context_switch&#34;&gt;Context switch&lt;/a&gt;&lt;/strong&gt;来了解更多关于上下文切换的知识。&lt;/p&gt;

&lt;h2 id=&#34;加重资源消耗:40e6cc49e0f5e4f0e9401d25e902878f&#34;&gt;加重资源消耗&lt;/h2&gt;

&lt;p&gt;线程需要计算机的一些资源才能运行，除了CPU时间之外，线程需要一些内存来维护其本地堆栈，它也可能会占用操作系统的一些资源来管理该线程。我们可以尝试创建100个什么操作也没有的等待线程来看看在运行这些线程时应用程序需要多少内存。&lt;/p&gt;

&lt;p&gt;&amp;lt;–翻译结束!–&amp;gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2. [译]多线程的优点</title>
      <link>https://lucumt.info/posts/java-concurrency/multithreading-benefits/</link>
      <pubDate>Sat, 01 Apr 2017 13:18:43 +0800</pubDate>
      
      <guid>https://lucumt.info/posts/java-concurrency/multithreading-benefits/</guid>
      <description>

&lt;p&gt;本文翻译自&lt;strong&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/benefits.html&#34;&gt;Java Concurrency / Multithreading Benefits&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;尽管多线程给程序实现带来了挑战，但由于多线程的一些优点我们仍然在使用它，其中的一些优点如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;更好的资源利用&lt;/li&gt;
&lt;li&gt;在某些场景可以简化程序设计&lt;/li&gt;
&lt;li&gt;提高程序响应&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;更好的资源利用:03f2a6ff6ff43564d8cd77dcf4ddb389&#34;&gt;更好的资源利用&lt;/h2&gt;

&lt;p&gt;假设我们有一个程序从本地磁盘中读取和处理文件，若读取和处理一个文件的耗时分别为5秒钟和2秒钟，则读取处理2个文件的耗时如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;5 seconds reading file A
2 seconds processing file A
5 seconds reading file B
2 seconds processing file B
-----------------------
14 seconds total//串行读取时总共耗时14秒
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当从磁盘读取文件时CPU的大部分时间都花费在等待从磁盘读取数据，在此期间CPU大部分时间都处于空闲状态。这些空闲时间可以做一些其它的事情，通过改变操作顺序，CPU可以被更好的利用，如下面的列子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;5 seconds reading file A
5 seconds reading file B + 2 seconds processing file A
2 seconds processing file B
-----------------------
12 seconds total//并行读取时总共耗时12秒
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中，CPU先等待读取第一个文件，然后开始读取第二个文件，在读取第二个文件的同时，CPU可以同时处理第一个文件。请记住，当等待从磁盘读取数据时，CPU大部分时间处于空闲状态！&lt;/p&gt;

&lt;p&gt;通常情况下，CPU在等待IO响应时可以做一些其它事情，这不仅适用于磁盘IO操作，也适用于网络IO操作，或者读取用户输入,网络和磁盘IO操作通常比CPU和内存IO操作慢很多。&lt;/p&gt;

&lt;h2 id=&#34;简化程序设计:03f2a6ff6ff43564d8cd77dcf4ddb389&#34;&gt;简化程序设计&lt;/h2&gt;

&lt;p&gt;如果在单线程应用程序中编程实现上述读取和处理文件的功能，就必须跟踪每个文件的读取和处理状态。相反的，在多线程程序中我们可以开启两个线程，每个线程读取和处理同一个文件。每个线程在等待从磁盘读取文件时都会被阻塞，但在等待的同时，其它线程可以利用CPU来处理已经读取的文件。这样能够是的CPU和磁盘都被更好的使用，而且由于每个线程只需要跟踪一个文件，编程实现也会变得更简单。&lt;/p&gt;

&lt;h2 id=&#34;提高程序响应:03f2a6ff6ff43564d8cd77dcf4ddb389&#34;&gt;提高程序响应&lt;/h2&gt;

&lt;p&gt;将单线程应用变为多线程应用的另一个常见目的是获得更快的响应。假设有一个服务器程序在某个端口监听请求，当接收到一个请求后，服务器处理该请求，处理完后再继续监听，该循环监听服务器的设计草图如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while(server is active){
    listen for request //监听请求
    process request//处理请求
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果某个请求需要花费很长的时间来处理，那么在此期间其它的客户端就不能向此服务器发送请求，只有当服务器处于监听状态时才能够接收请求。&lt;/p&gt;

&lt;p&gt;一种替代方案是让监听线程将接收到的请求发送给worker线程处理，然后立即恢复监听，worker线程对请求进行处理并给客户端发送回复，此种服务器的设计草图如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while(server is active){
    listen for request //监听请求
    hand request to worker thread//将接收到的请求发送给worker线程处理
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这种方式下，服务器线程会迅速返回监听，因而更多的客户端可以给服务器发送请求，服务器的响应也得以提高。&lt;/p&gt;

&lt;p&gt;该方法同样适用于桌面应用程序，如果你点击一个按钮来开启一个长任务，而执行该任务的线程是更新窗口、按钮等部件的线程，那么在该任务运行期间，该桌面程序将无法响应其它操作。相反的，可以将该任务移交给一个worker线程，当worker线程处理该任务时，更新窗口的线程处于空闲状态，可以响应其它用户请求，当worker线程执行完任务时通知更新窗口线程，该窗口线程根据执行结果来更新程序。因而利用worker线程设计实现的程序对用户更具有响应性。&lt;/p&gt;

&lt;p&gt;&amp;lt;–翻译结束!–&amp;gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1. [译]Java多线程与并发教程</title>
      <link>https://lucumt.info/posts/java-concurrency/java-concurrency-multithreading-tutorial/</link>
      <pubDate>Thu, 30 Mar 2017 14:49:08 +0800</pubDate>
      
      <guid>https://lucumt.info/posts/java-concurrency/java-concurrency-multithreading-tutorial/</guid>
      <description>

&lt;p&gt;本文翻译自&lt;strong&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/index.html&#34;&gt;Java Concurrency / Multithreading Tutorial&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最开始一台电脑只有单个CPU，只能一次运行一个任务，之后出现的多任务处理则意味着计算机在同一时间可以处理多个程序（也可以称之为任务或进程），虽然它们并不是真正的并发。由于单个CPU被不同的程序共用，操作系统需要在程序运行过程中不停地切换CPU，在短暂的执行一个程序后就立即切换到下一个程序。&lt;/p&gt;

&lt;p&gt;多任务处理给软件开发人员提出了新的挑战，程序不能再假定拥有CPU所有的可用时间、内存和其它计算机资源，一个好的程序应该及时释放所有不需要使用的资源，以便其它程序可以使用它们。
之后出现的多线程则意味着可以在同一个程序里面执行多个线程，每一个执行的线程可以被认为是CPU在执行当前程序，当在同一个程序里面执行多个线程时，看起来像是拥有多个CPU在执行该程序。&lt;/p&gt;

&lt;p&gt;多线程虽然是提高某些类型程序性能的良方，但是多线程比多任务更具有挑战性。由于这些线程执行的是相同的程序，因此它们同时读写相同的内存，这可能会导致在单线程中不会出现的错误结果。某些错误结果不会出现在单CPU中机器中是由于两个线程不可能同时执行。现在的电脑大都拥有多核甚至多CPU，这意味着多个不同的线程可以被不同的内核或CPU同时执行。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/java-concurrency/java-concurrency-multithreading-tutorial/java-concurrency-tutorial-introduction_1.png&#34; alt=&#34;多线程介绍1&#34; /&gt;
&lt;br /&gt;
如果一个线程读取一个内存地址同时另一个线程向其写入信息，第一个线程在读取完成时会得到什么值呢？旧的值还是被第二个线程写入的新值？亦或是这两个值得混合？若两个线程同时向一个内存地址写入信息，当这两个线程运行完毕时，最终的值会是什么呢？是第一个线程写入的值还是第二个线程写入的值？亦或是这两个线程写入值的混合？&lt;/p&gt;

&lt;p&gt;在缺少适当措施的情况下，上述的任意一种结果都可能出现，程序的运行结果甚至不可预测，每一次的执行结果可能都不同。因此怎么处理多线程对于软件开发人员很重要，这意味着我们需要学习如何控制线程来访问共享资源如内存、文件、数据库等，而这正是本系列教程所要阐述的主题之一。&lt;/p&gt;

&lt;h2 id=&#34;java中的多线程和并发:8ce159d4bfbd6fb97f86a98ef4f33138&#34;&gt;Java中的多线程和并发&lt;/h2&gt;

&lt;p&gt;Java是最先让多线程对开发人员变得简单的程序语言之一，Java在最开始的时候就已经具备了多线程的能力，因此Java开发人员经常面临上文所述的并发问题。这正是我编写本系列Java并发教程的原因，作为自己的笔记以及其他可能从中获益的Java开发人员。&lt;/p&gt;

&lt;p&gt;本教程将主要关注于Java中的多线程，但其中的一些多线程问题与多任务和分布式系统系统中出现的问题类似，因此在本教程中可能会出现对多任务和分布式系统的引用。并发不等于多线程，它们是不同的概念。&lt;/p&gt;

&lt;h2 id=&#34;java并发在2015的现状和展望:8ce159d4bfbd6fb97f86a98ef4f33138&#34;&gt;Java并发在2015的现状和展望&lt;/h2&gt;

&lt;p&gt;自从第一本Java并发书籍问世之后，关于并发架构和设计领域已经发生了很多变化，Java 5甚至提供了concurrency工具包。新的类似于Vert.x、Play/Akka和Qbit的异步无共享平台和API已经出现。这些平台使用了一个不同于标准Java/JEE并发的模型来处理线程、共享内存和锁。新的无阻塞并发算法已经公开，类似于LMax Disrupter这样的非阻塞工具也已经添加到我们的工具箱。在Java7中通过Fork和Join框架引入了并行性功能编程，并在Java8中引入了流相关的API。&lt;/p&gt;

&lt;p&gt;所有这些新的进展让我觉得是时候编更新本系列的Java并发教程，因此本教程再一次处于编写中状态，新的教程会在时间允许编写时发布。&lt;/p&gt;

&lt;p&gt;&amp;lt;–翻译结束!–&amp;gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在Intellij IDEA中引用Golang本地包</title>
      <link>https://lucumt.info/posts/import-local-package-in-intellij-idea/</link>
      <pubDate>Sun, 05 Mar 2017 14:04:43 +0800</pubDate>
      
      <guid>https://lucumt.info/posts/import-local-package-in-intellij-idea/</guid>
      <description>

&lt;p&gt;在学习&lt;code&gt;Golang&lt;/code&gt;时，自己最开始用的是eclpse中的&lt;a href=&#34;https://goclipse.github.io/&#34;&gt;goclipse&lt;/a&gt;插件来进行 &lt;em&gt;Golang&lt;/em&gt; 编程，但其对&lt;em&gt;Golang&lt;/em&gt; 的支持不是太好，如代码格式化、自动导入引用包等都无法直接在eclipse中使用，并且其自动提示功能也没有像 &lt;em&gt;Java&lt;/em&gt; 那么强，于是转用&lt;a href=&#34;https://www.jetbrains.com/idea/&#34;&gt;Intellij IDEA&lt;/a&gt;安装&lt;a href=&#34;https://plugins.jetbrains.com/plugin/5047-go&#34;&gt;Golang插件&lt;/a&gt;来替代使用，安装完插件后的&lt;a href=&#34;https://www.jetbrains.com/idea/&#34;&gt;Intellij IDEA&lt;/a&gt;对 &lt;em&gt;Golang&lt;/em&gt; 的支持在各方面都很令人满意，唯独引入本地包的支持不太好用。经过一阵摸索自己找出了解决方案，先记录下。&lt;/p&gt;

&lt;h2 id=&#34;在eclipse中引用golang本地包:bb4f21717a930ee21245b90e8acfc2d5&#34;&gt;在Eclipse中引用Golang本地包&lt;/h2&gt;

&lt;p&gt;若我们采用的是&lt;a href=&#34;https://goclipse.github.io/&#34;&gt;goclipse&lt;/a&gt;来开发 &lt;em&gt;Golang&lt;/em&gt; ,则在其中引用本地包很简单，和引用Java包类似。如下图所示，假设 &lt;em&gt;src&lt;/em&gt; 是源代码所在的目录，在 &lt;em&gt;src&lt;/em&gt; 的 &lt;em&gt;sec&lt;/em&gt; 文件夹下有一个名为 &lt;em&gt;calculate.go&lt;/em&gt; 的文件，其中有一个名为 &lt;em&gt;Add&lt;/em&gt; 的函数用于计算两个整数的相加之和。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/import-local-page-in-intellij-idea/goclipse_package.png&#34; alt=&#34;goclipse中的本地包&#34; /&gt;
&lt;br /&gt;
若要在主程序main方法中调用 &lt;em&gt;Add&lt;/em&gt; 方法，先通过import引入该文件的包名&lt;code&gt;import service&lt;/code&gt;，然后通过包名调用该方法&lt;code&gt;service.Add(1,2)&lt;/code&gt;，如下图所示，可以看出在Eclipse中引用 &lt;em&gt;Golang&lt;/em&gt; 本地包与引用Java包没有太大的区别，都是将包文件放到 &lt;em&gt;src&lt;/em&gt; 源文件夹下，然后通过包名来引用。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/import-local-page-in-intellij-idea/goclipse_package_reference.png&#34; alt=&#34;goclipse中的本地包引用&#34; /&gt;
&lt;br /&gt;
也可以通过直接导入该包所在的文件夹的名称来调用该方法，此时需要将&lt;code&gt;import service&lt;/code&gt;改为&lt;code&gt;import sec&lt;/code&gt;，如下图所示&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/import-local-page-in-intellij-idea/goclipse_package_reference_folder.png&#34; alt=&#34;goclipse中的本地包通过文件夹引用&#34; /&gt;
&lt;br /&gt;
可以看出在eclipse中导入 &lt;em&gt;Golang&lt;/em&gt; 本地包时有两种方法： &lt;strong&gt;通过import导入包名&lt;/strong&gt; 或 &lt;strong&gt;通过import导入该包对应的文件夹&lt;/strong&gt; ，这两种方法均可使程序正常运行。&lt;/p&gt;

&lt;h2 id=&#34;在intellij-idea中引用golang本地包:bb4f21717a930ee21245b90e8acfc2d5&#34;&gt;在Intellij IDEA中引用Golang本地包&lt;/h2&gt;

&lt;p&gt;下面2张图为在IDEA中建立的对应项目，图中 &lt;em&gt;gproject&lt;/em&gt; 是一个项目，&lt;em&gt;gotest&lt;/em&gt; 是一个模块，我们在 &lt;em&gt;gotest&lt;/em&gt; 下建立相关的测试文件。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/import-local-page-in-intellij-idea/idea_package.png&#34; alt=&#34;IDEA中的本地包&#34; /&gt;
&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/import-local-page-in-intellij-idea/idea_package_reference.png&#34; alt=&#34;IDEA中的本地包引用&#34; /&gt;
&lt;br /&gt;
在上述代码中我们是通过&lt;code&gt;import service&lt;/code&gt;的方式来导入相应包的，由于IDEA对Golang很强，从图中可以看出 &lt;em&gt;service&lt;/em&gt; 的颜色与其它导入包的颜色不一致，当把鼠标移动到 &lt;em&gt;service&lt;/em&gt; 上时会提示 &lt;em&gt;Cannot resolve file &amp;lsquo;service&amp;rsquo;&lt;/em&gt; ，直接运行时，会出现如下图所示 &lt;em&gt;cannot find package&lt;/em&gt; 错误，将&lt;code&gt;import service&lt;/code&gt;修改为&lt;code&gt;import sec&lt;/code&gt;时，会出现同样的错误，可以看出在idea中默认不支持直接导入本地 &lt;em&gt;Golang&lt;/em&gt; 包。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/import-local-page-in-intellij-idea/idea_package_reference_run_error.png&#34; alt=&#34;IDEA中引用本地包运行出错&#34; /&gt;
&lt;br /&gt;
从报错信息可以看出，程序在运行时先去 &lt;strong&gt;GOROOT&lt;/strong&gt; 去搜索导入包，然后去 &lt;strong&gt;GOPATH&lt;/strong&gt; 寻找导入包，最后在当前项目模块下寻找导入包，但实际上不存在 &lt;em&gt;D:\program\IntelliJ IDEA 2016.2.1\workspace\gproject\gotest\src\service&lt;/em&gt; 这个目录，故而程序报错，不能正常运行。&lt;/p&gt;

&lt;p&gt;解决该问题的关键是明白 &lt;strong&gt;&lt;a href=&#34;http://golang.org/doc/install#tarball_non_standard&#34;&gt;GOROOT&lt;/a&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;a href=&#34;http://golang.org/cmd/go/#hdr-GOPATH_environment_variable&#34;&gt;GOPATH&lt;/a&gt;&lt;/strong&gt; 的作用，根据官方文档的解释 &lt;strong&gt;GOPATH&lt;/strong&gt; 的主要作用是存放文件以便 &lt;em&gt;Golang&lt;/em&gt; 程序编译时可以进行搜索引用，&lt;strong&gt;GOPATH&lt;/strong&gt; 可以设置一个值或多个值，多个值之间以分号隔开。很明显只要我们将本地 &lt;em&gt;Golang&lt;/em&gt; 加入到 &lt;strong&gt;GOPATH&lt;/strong&gt;中即可在IDEA中正常运行该程序。&lt;/p&gt;

&lt;p&gt;如下图所示，在IDEA中依次选择 &lt;strong&gt;File-&amp;gt;Settings-&amp;gt;Language&amp;amp;Frameworks-&amp;gt;Go-&amp;gt;Go Libraries&lt;/strong&gt; ，会出现如下图所示的配置 &lt;em&gt;Golang&lt;/em&gt; 库的界面，在该界面可以添加 &lt;em&gt;Golang&lt;/em&gt; 本地包所在的路径，该界面包含3个不同作用范围的配置方式： &lt;em&gt;Global libraries&lt;/em&gt; 、 &lt;em&gt;Project libraries&lt;/em&gt; 和 &lt;em&gt;Module libraries&lt;/em&gt; ，其中 &lt;em&gt;Global libraries&lt;/em&gt; 的配置对所有项目生效为全局配置，&lt;em&gt;Project libraries&lt;/em&gt; 的配置对整个项目生效，&lt;em&gt;Module libraries&lt;/em&gt; 的配置只对模块生效，可以看出在 &lt;em&gt;Global libraries&lt;/em&gt; 默认包含了 &lt;strong&gt;GOPATH&lt;/strong&gt; 。根据实际使用的需求我们可以选择把本地包设置在 &lt;em&gt;Project libraries&lt;/em&gt; 还是 &lt;em&gt;Module libraries&lt;/em&gt; 中。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/import-local-page-in-intellij-idea/idea_package_select_gopath.png&#34; alt=&#34;IDEA中配置程序库&#34; /&gt;
&lt;br /&gt;
本文的程序都是在 &lt;em&gt;gotest&lt;/em&gt; 模块下，故将其添加到 &lt;em&gt;Module libraries&lt;/em&gt; 下，添加完的结果如下所示：&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/import-local-page-in-intellij-idea/idea_package_gopath_config.png&#34; alt=&#34;IDEA中配置程序库的结果&#34; /&gt;
&lt;br /&gt;
将本地包添加到模块库之后，还需要在go文件中将导入包的语句设置为&lt;code&gt;import sec&lt;/code&gt;，不能设置为&lt;code&gt;import service&lt;/code&gt;，然后该 &lt;em&gt;Golang&lt;/em&gt; 程序即可正常运行。&lt;/p&gt;

&lt;p&gt;可以看出，不同于&lt;a href=&#34;https://goclipse.github.io/&#34;&gt;goclipse&lt;/a&gt;，在IDEA中只能使用 &lt;strong&gt;通过import导入该包对应的文件夹&lt;/strong&gt; 来导入本地 &lt;em&gt;Golang&lt;/em&gt; 包，至于原因还需要进一步研究。&lt;/p&gt;

&lt;h2 id=&#34;利用goclipse时无法运行程序的解决方法:bb4f21717a930ee21245b90e8acfc2d5&#34;&gt;利用Goclipse时无法运行程序的解决方法&lt;/h2&gt;

&lt;p&gt;在使用&lt;a href=&#34;https://goclipse.github.io/&#34;&gt;goclipse&lt;/a&gt;运行 &lt;em&gt;Golang&lt;/em&gt; 程序时，偶尔会出现程序无法编译和运行的情况，这种情形一般都是 &lt;em&gt;src&lt;/em&gt; 没有被设置成源代码目录造成的，此时可以通过如下图所示的方法，将 &lt;em&gt;src&lt;/em&gt; 目录添加源代码目录。在Eclipse中选中该项目然后点击 &lt;strong&gt;Properties&lt;/strong&gt; ，会出现项目属性配置界面，点击 &lt;strong&gt;Go Project Configuration&lt;/strong&gt; ，通过 &lt;strong&gt;Add Folder&lt;/strong&gt; 可以将 &lt;em&gt;src&lt;/em&gt; 添加到源代码中，之后程序即可正常运行。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/import-local-page-in-intellij-idea/goclipse_add_source_folder.png&#34; alt=&#34;goclipse中添加源程序目录&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>计算两个平行于坐标轴的矩形相交的面积</title>
      <link>https://lucumt.info/posts/calculate-total-area-of-two-rectangles/</link>
      <pubDate>Sun, 26 Feb 2017 19:26:33 +0800</pubDate>
      
      <guid>https://lucumt.info/posts/calculate-total-area-of-two-rectangles/</guid>
      <description>&lt;p&gt;之前面试时遇到一个算法题: &lt;strong&gt;假定两个矩形各条边都是平行于坐标轴，已知k、l、m、n分别为其中一个矩形左下角和右上角x轴、y轴坐标，p、q、r、s分别为另一个矩形的左下角和右上角x轴、y轴坐标，求这两个矩形的总面积，当矩形相交时要减去相交的面积。&lt;/strong&gt; 此题利用常规的枚举法很复杂，但利用排除法和归纳法却能很快解决，故先记录下。&lt;/p&gt;

&lt;p&gt;很明显，此题的重点在于如何判断矩形是否相交以及检测相交形成的新矩形面积，当不相交时总面积直接为两个矩形的面积之和，当相交时需要减去相交矩形的面积，由于题目已经告诉了矩形的左下角和右上角坐标已知，问题又转化为在相交时如何计算相交矩形的左下角和右上角的坐标。&lt;/p&gt;

&lt;p&gt;最开始我想通过常规的枚举法把矩形相交的所有情况都列出来，在稿纸上简单的比划后，发现采用枚举的方式太复杂，矩形相交理论上有下图所示的16种组合方式，短时间内很难一一列举出来，实际编程中不仅代码量大还很容易产生遗漏。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/calculate-total-area-of-two-rectangles/intersect1.png&#34; alt=&#34;矩形相交1&#34; title=&#34;两个矩形边角相交以及完全包含&#34; /&gt;

&lt;img src=&#34;https://lucumt.info/blog_img/calculate-total-area-of-two-rectangles/intersect2.png&#34; alt=&#34;矩形相交2&#34; title=&#34;矩形横向相交&#34; /&gt;
&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/calculate-total-area-of-two-rectangles/intersect3.png&#34; alt=&#34;矩形相交3&#34; title=&#34;矩形纵向相交&#34; /&gt;

&lt;img src=&#34;https://lucumt.info/blog_img/calculate-total-area-of-two-rectangles/intersect4.png&#34; alt=&#34;矩形相交4&#34; title=&#34;矩形被完全包含&#34; /&gt;
&lt;br /&gt;
排除枚举方法之后，只能对其进行分析找出通用的处理方式。下图展示了在相交矩形的左下角和右上角的位置，仔细分析后便可发现&lt;strong&gt;相交矩形的左下角x,y坐标是两个矩形左下角x,y坐标中取较大值，相交矩形的右上角x,y坐标是两个矩形右上角x,y坐标中取较小值&lt;/strong&gt;。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/calculate-total-area-of-two-rectangles/position_calculate.png&#34; alt=&#34;矩形相交坐标计算&#34; title=&#34;矩形相交时形成的新矩形的坐标来源&#34; /&gt;
&lt;br /&gt;
通过分析归纳之后，我们将之前的16种相交情况统一为1个表达式，而这个表达式在编程时是很容易实现的，下面的代码展示了如何利用该表达式计算相交矩形的坐标以及其面积。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static int calculateIntersectArea(int k, int l, int m, int n, int p,int q, int r, int s) {
	int leftDownX = 0, leftDownY = 0, rightUpX = 0, rightUpY = 0;
	leftDownX = k &amp;gt; p ? k : p;
	leftDownY = l &amp;gt; q ? l : q;
	rightUpX = m &amp;lt; r ? m : r;
	rightUpY = n &amp;lt; s ? n : s;
	return (rightUpX - leftDownX) * (rightUpY - leftDownY);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;寻找出如何计算相交矩形的面积之后，还需要解决一个问题:&lt;strong&gt;上述实现只有在矩形相交时才正确，当矩形不相交时计算结果错误&lt;/strong&gt;，为此需要找出一个方法判定两个矩形是否相交。若利用枚举方法同样会有前述的16种情形需要考虑，同样很复杂，显然枚举方法不适合使用。换一种思路：&lt;strong&gt;如果把矩形不相交的情形排除掉，那么剩下的情形就是矩形相交了！&lt;/strong&gt;，而矩形不相交则相对容易多了，假设这两个矩形分别为A和B，则它们不相交一共有如下图所示的4种情况：&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/calculate-total-area-of-two-rectangles/no_interact_position_compare.png&#34; alt=&#34;矩形不相交坐标计算&#34; title=&#34;矩形不相交的4种情况&#34; /&gt;
&lt;br /&gt;
相应的代码实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static boolean isIntersect(int k, int l, int m, int n, int p, int q, int r, int s) {
	
	boolean nointersect = false;
	// B在A的上面
	nointersect = q &amp;gt; n;
	// B在A的下面
	nointersect = l &amp;gt; s;
	// B在A的左侧
	nointersect = r &amp;lt; k;
	// B在A的右侧
	nointersect = m &amp;lt; p;

	return !nointersect;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用上述2个判断方法，可以方便准确的计算出两个矩形在相交时的总面积，相应的代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static int solution(int k, int l, int m, int n, int p, int q, int r, int s) {

	int widthA = m - k;
	int heightA = n - l;
	int areaA = widthA * heightA;

	int widthB = r - p;
	int heightB = s - q;
	int areaB = widthB * heightB;
	int totalArea = areaA + areaB;

	boolean hasIntersect = isIntersect(k, l, m, n, p, q, r, s);
	if (hasIntersect) {
		totalArea -= calculateIntersectArea(k, l, m, n, p, q, r, s);
	}
	return totalArea;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析解决这个问题给我最深的感触是：&lt;strong&gt;有时候若某一类问题用枚举实现很复杂时，尝试去分析其中的规律，找出通用的解决方法&lt;/strong&gt;，不仅在算法方面，或许在生活中其它方面也适用吧！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在iframe嵌套的html5中播放视频时全屏显示和取消音量调整</title>
      <link>https://lucumt.info/posts/show-video-in-html5-page/</link>
      <pubDate>Sun, 30 Oct 2016 19:48:17 +0800</pubDate>
      
      <guid>https://lucumt.info/posts/show-video-in-html5-page/</guid>
      <description>

&lt;p&gt;由于项目需要，最近使用了在&lt;code&gt;html5&lt;/code&gt;中播放视频的功能，期间遇到了几个坑，先简单记录下。&lt;/p&gt;

&lt;h2 id=&#34;在html5页面中播放视频:29e51551d2052d8c2b6a55472d7ab989&#34;&gt;在html5页面中播放视频&lt;/h2&gt;

&lt;p&gt;如何在&lt;code&gt;html5&lt;/code&gt;页面中嵌入视频的代码在网上很容易直接搜索到，典型的代码如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;video width=&amp;quot;320&amp;quot; height=&amp;quot;240&amp;quot; controls=&amp;quot;controls&amp;quot;&amp;gt;
  &amp;lt;source src=&amp;quot;movie.mp4&amp;quot; type=&amp;quot;video/mp4&amp;quot;/&amp;gt;
  Your browser does not support the video tag.
&amp;lt;/video&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后的效果显示如下，从图中我们可以看出该视频播放界面包含 &lt;em&gt;快进&lt;/em&gt; 、 &lt;em&gt;音量调整&lt;/em&gt; 和 &lt;em&gt;全屏播放&lt;/em&gt; 这几个按钮&lt;br /&gt;
&lt;img src=&#34;https://ooo.0o0.ooo/2016/10/30/5815e96382a3c.png&#34; alt=&#34;浏览器中正常播放视频&#34; title=&#34;浏览器中正常播放视频&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;在iframe中不能全屏播放视频:29e51551d2052d8c2b6a55472d7ab989&#34;&gt;在iframe中不能全屏播放视频&lt;/h2&gt;

&lt;p&gt;项目中好多地方都用&lt;code&gt;iframe&lt;/code&gt;来嵌套html页面，最开始我是用类似如下代码在被&lt;code&gt;iframe&lt;/code&gt;包含的页面中嵌入前面的视频播放代码，
发现显示出来的视频播放器没有全屏播放按钮，通过升级浏览器版本和清除缓存等方法依然不奏效。搜索&lt;strong&gt;&lt;a href=&#34;http://stackoverflow.com/&#34;&gt;stackoverflow&lt;/a&gt;&lt;/strong&gt;找到一个类似的问题&lt;a href=&#34;http://stackoverflow.com/questions/15276929/how-to-make-a-video-fullscreen-when-it-is-placed-inside-an-iframe&#34;&gt;How to make a video fullscreen when it is placed inside an iframe?&lt;/a&gt;，阅读后发现只需要将&lt;code&gt;iframe&lt;/code&gt;修改成&lt;code&gt;&amp;lt;iframe … allowfullscreen=&amp;quot;true&amp;quot; webkitallowfullscreen=&amp;quot;true&amp;quot; mozallowfullscreen=&amp;quot;true&amp;quot;&amp;gt;&lt;/code&gt;即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;iframe&amp;gt;
  &amp;lt;!DOCTYPE html&amp;gt;
  &amp;lt;html&amp;gt;
    &amp;lt;head /&amp;gt;
    &amp;lt;body&amp;gt;
      &amp;lt;video width=&amp;quot;320&amp;quot; height=&amp;quot;240&amp;quot; controls=&amp;quot;controls&amp;quot;&amp;gt;
		&amp;lt;source src=&amp;quot;movie.mp4&amp;quot; type=&amp;quot;video/mp4&amp;quot;/&amp;gt;
		Your browser does not support the video tag.
	  &amp;lt;/video&amp;gt;
    &amp;lt;body&amp;gt;
  &amp;lt;/html&amp;gt;
&amp;lt;/iframe&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://ooo.0o0.ooo/2016/10/30/581600e124b51.png&#34; alt=&#34;视频无法进行全屏播放&#34; title=&#34;视频无法进行全屏播放&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;隐藏声音调整按钮:29e51551d2052d8c2b6a55472d7ab989&#34;&gt;隐藏声音调整按钮&lt;/h2&gt;

&lt;p&gt;有些演示视频只有图像没有声音，为了避免对使用者造成不必要的干扰，可以将声音播放按钮屏蔽掉，由于自己项目只支持基于&lt;code&gt;webkit&lt;/code&gt;内核的&lt;code&gt;Chrome&lt;/code&gt;浏览器访问，通过Google之后在 &lt;strong&gt;&lt;a href=&#34;http://stackoverflow.com/&#34;&gt;stackoverflow&lt;/a&gt;&lt;/strong&gt;找到
&lt;a href=&#34;http://stackoverflow.com/questions/15126921/why-do-no-user-agents-implement-the-css-cursor-style-for-video-elements/15145555#15145555&#34;&gt;Why do no user-agents implement the CSS cursor style for video elements&lt;/a&gt;这篇文章，其中列出了播放视频时相关控制按钮的css类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;video::-webkit-media-controls-panel&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-play-button&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-volume-slider-container&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-volume-slider&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-mute-button&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-timeline&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-current-time-display&lt;/li&gt;
&lt;li&gt;video::-webkit-full-page-media::-webkit-media-controls-panel&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-timeline-container&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-time-remaining-display&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-seek-back-button&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-seek-forward-button&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-fullscreen-button&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-rewind-button&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-return-to-realtime-button&lt;/li&gt;
&lt;li&gt;video::-webkit-media-controls-toggle-closed-captions-button&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了屏蔽掉声音播放按钮，我们只需使用 &lt;em&gt;video::-webkit-media-controls-volume-slider&lt;/em&gt; 和  &lt;em&gt;video::-webkit-media-controls-mute-button&lt;/em&gt; 这两个属性即可，相应的css代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;/**隐藏视频音量大小调整控件**/
.no_sound_style&amp;gt;video::-webkit-media-controls-volume-slider{
	display:none;
}

/**隐藏视频音量喇叭**/
.no_sound_style&amp;gt;video::-webkit-media-controls-mute-button{
	display:none;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应的显示效果如下图所示，可以看到音量喇叭和音量调整空间都消失不见&lt;br /&gt;
&lt;img src=&#34;https://ooo.0o0.ooo/2016/10/30/5815f41099feb.png&#34; alt=&#34;屏蔽了声音播放按钮&#34; title=&#34;屏蔽了播放器中的声音播放按钮&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mybatis batch insert exception的解决方法</title>
      <link>https://lucumt.info/posts/mybatis-batch-insert-exception/</link>
      <pubDate>Mon, 30 May 2016 18:20:37 +0800</pubDate>
      
      <guid>https://lucumt.info/posts/mybatis-batch-insert-exception/</guid>
      <description>&lt;p&gt;在利用 &lt;strong&gt;&lt;a href=&#34;http://www.mybatis.org/mybatis-3/&#34;&gt;MyBatis&lt;/a&gt;&lt;/strong&gt; 进行多条数据插入时，为了提高性能我们可能会使用批量插入的功能来实现。示例代码如下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SQL配置文件:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;insert id=&amp;quot;addAuthorityRoleBatch&amp;quot; parameterType=&amp;quot;List&amp;quot;&amp;gt;
    INSERT INTO system_authority_role(role_id,authority_id)
      VALUES
      &amp;lt;foreach collection=&amp;quot;list&amp;quot; item=&amp;quot;authRole&amp;quot; separator=&amp;quot;,&amp;quot;&amp;gt;
        (#{authRole.roleId},#{authRole.authorityId})
      &amp;lt;/foreach&amp;gt;
  &amp;lt;/insert&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   public void adjustRoleAuth(String roleId, String authIdsStr) {
        authRoleDao.deleteAuthorityRoleByRole(roleId);
        String[] authIds=authIdsStr.split(&amp;quot;;&amp;quot;);
        List&amp;lt;AuthorityRoleModel&amp;gt; authRoleList=new ArrayList&amp;lt;AuthorityRoleModel&amp;gt;();
        for(String authId:authIds){
            authRoleList.add(new AuthorityRoleModel(roleId,authId));
        }
        authRoleDao.addAuthorityRoleBatch(authRoleList);
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面的代码大多数时候可以正常运行，但是偶尔会出现如下异常：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;### SQL: INSERT INTO system_authority_role(role_id,authority_id)       VALUES
### Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39; at line 2
; bad SQL grammar []; nested exception is com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39; at line 2
at org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator.doTranslate(SQLErrorCodeSQLExceptionTranslator.java:233
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的异常堆栈信息显示现在执行的MySQL语句发生了语法错误，INSERT VALUE后面的值为空，由于该问题有时候发生，有时候不发生，给我们分析该问题造成了一定的困扰。&lt;strong&gt;该问题产生的根源为批量插入时的集合数据为空，使得SQL配置文件中的foreach循环没有执行，从而导致SQL语句不完整，进而产生该异常。&lt;/strong&gt;为了解决该问题我们可以批量插入之前先检查List数据集合是否为空，只有在不为空的情况下才进行插入，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void adjustRoleAuth(String roleId, String authIdsStr) {
    authRoleDao.deleteAuthorityRoleByRole(roleId);
    String[] authIds=authIdsStr.split(&amp;quot;;&amp;quot;);
    List&amp;lt;AuthorityRoleModel&amp;gt; authRoleList=new ArrayList&amp;lt;AuthorityRoleModel&amp;gt;();
    for(String authId:authIds){
        authRoleList.add(new AuthorityRoleModel(roleId,authId));
    }
    if(authRoleList.size()&amp;gt;0){//只有在List不为空时才进行插入
        authRoleDao.addAuthorityRoleBatch(authRoleList);        
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>利用SpringMVC下载大文件时内存溢出的处理</title>
      <link>https://lucumt.info/posts/download-big-file-using-springmvc/</link>
      <pubDate>Sun, 20 Mar 2016 16:41:29 +0800</pubDate>
      
      <guid>https://lucumt.info/posts/download-big-file-using-springmvc/</guid>
      <description>&lt;p&gt;文件的上传和下载是Web系统中的一个很普通的功能，实现的方式也有很多种，如利用 &lt;strong&gt;&lt;a href=&#34;https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html&#34;&gt;java.io&lt;/a&gt;&lt;/strong&gt; 下面的各种IO类自己实现，或者利用 &lt;strong&gt;&lt;a href=&#34;https://commons.apache.org/proper/commons-io/&#34;&gt;Commons IO&lt;/a&gt;&lt;/strong&gt; 包中的 &lt;strong&gt;&lt;em&gt;FileUtils&lt;/em&gt;&lt;/strong&gt; 、 &lt;strong&gt;&lt;em&gt;IOUtils&lt;/em&gt;&lt;/strong&gt; 类中封装好的方法直接调用。由于目前我所开发的系统采用了 &lt;strong&gt;&lt;a href=&#34;http://docs.spring.io/autorepo/docs/spring/3.2.x/spring-framework-reference/html/mvc.html&#34;&gt;SpringMVC&lt;/a&gt;&lt;/strong&gt; 来作为项目的MVC实现，所以很自然的采用 &lt;strong&gt;&lt;a href=&#34;http://docs.spring.io/autorepo/docs/spring/3.2.x/spring-framework-reference/html/mvc.html&#34;&gt;SpringMVC&lt;/a&gt;&lt;/strong&gt;内置的API进行文件的下载，但在实际使用过程中发现其对大文件的下载支持不太好，现把解决方案记录如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;downloadRequireDocument&amp;quot;)
public ResponseEntity&amp;lt;byte[]&amp;gt; downloadRequireDocument(String fileId,String fileName,String fileType,
     HttpServletRequest request) throws IOException{
	String filePath=fileName+fileId+&amp;quot;.&amp;quot;+fileType;
    
	HttpHeaders headers=new HttpHeaders();
	headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
	headers.setContentDispositionFormData(&amp;quot;attachment&amp;quot;,URLEncoder.encode(fileName,&amp;quot;UTF-8&amp;quot;)+&amp;quot;.&amp;quot;+fileType);
    
	File downloadFile=new File(request.getSession().getServletContext().getRealPath(File.separator)+filePath);
    
	return new ResponseEntity&amp;lt;byte[]&amp;gt;(FileUtils.readFileToByteArray(downloadFile),headers,HttpStatus.CREATED);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该段代码在下载小文件时可以正常工作，但是当要下载的文件很大时（如几百M或上G），就会发生如下错误：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;java.lang.OutOfMemoryError: Java heap space
at org.apache.commons.io.output.ByteArrayOutputStream.toByteArray(ByteArrayOutputStream.java:271)
at org.apache.commons.io.IOUtils.toByteArray(IOUtils.java:219)
at org.apache.commons.io.FileUtils.readFileToByteArray(FileUtils.java:1136)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;去网上搜索 &lt;strong&gt;&lt;em&gt;java.lang.OutOfMemoryError: Java heap space&lt;/em&gt;&lt;/strong&gt; 这个错误时，一般都建议我们在tomcat中添加如下类似设置来提高JVM的配置:&lt;br /&gt;
&lt;code&gt;set JAVA_OPTS=%JAVA_OPTS% -server -Xms800m -Xmx800m -XX:MaxNewSize=256m -XX:MaxPermSize=256m&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;但即使按照把上面的参数配置都扩大一倍，在下载更大的文件时还是会遇到 &lt;strong&gt;&lt;em&gt;java.lang.OutOfMemoryError: Java heap space&lt;/em&gt;&lt;/strong&gt; 这个错误，上面的解决方法治标不治本。分析下异常堆栈可以发现问题产生的根源在于 &lt;em&gt;at org.apache.commons.io.FileUtils.readFileToByteArray(FileUtils.java:1136)&lt;/em&gt; 这行代码，&lt;strong&gt;&lt;em&gt;FileUtils.readFileToByteArray&lt;/em&gt;&lt;/strong&gt;  会把文件一次性读入内存中，要下载的文件越大，需要占用的内存也越大，当文件的大小超过JVM和Tomcat的内存配置时，&lt;strong&gt;&lt;em&gt;OutOfMemoryError&lt;/em&gt;&lt;/strong&gt; 这个问题就会不可避免的发生。&lt;/p&gt;

&lt;p&gt;弄清产生该问题的原因之后，解决的方法也很简单：&lt;strong&gt;不利用&lt;a href=&#34;https://commons.apache.org/proper/commons-io/&#34;&gt;Commons IO&lt;/a&gt;把文件一次性读入内存，而是利用普通的文件输出流按字节分段写入文件，把占用的内存固定在一个指定的范围内，从根本上避免内存占用过高的问题&lt;/strong&gt;,替代的代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;downloadRequireDocument&amp;quot;)
public void downloadRequireDocument(String fileId,String fileName,String fileType,
	HttpServletRequest request,HttpServletResponse response) throws IOException {
	
	String filePath = request.getSession().getServletContext().getRealPath(File.separator)+fileName+&amp;quot;.&amp;quot;+fileType;
	fileName = URLEncoder.encode(fileName.trim(),&amp;quot;UTF-8&amp;quot;)+&amp;quot;.&amp;quot;+fileType;
	response.setHeader(&amp;quot;Content-Disposition&amp;quot;,&amp;quot;attachment;filename=&amp;quot;+fileName);

	InputStream is = new FileInputStream(filePath);
	
	int read =0;
	byte[] bytes = new byte[2048];
	OutputStream os = response.getOutputStream();
	while((read = is.read(bytes))!=-1){//按字节逐个写入，避免内存占用过高
		os.write(bytes, 0, read);
	}
	os.flush();
	os.close();
	is.close();
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>