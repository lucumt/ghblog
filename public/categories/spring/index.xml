<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Spring on 飞狐的部落格</title>
    <link>https://lucumt.info/categories/spring/</link>
    <description>Recent content in Spring on 飞狐的部落格</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 09 Jan 2018 22:10:30 +0800</lastBuildDate>
    <atom:link href="https://lucumt.info/categories/spring/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>在Quartz中动态设置定时任务的执行时间</title>
      <link>https://lucumt.info/posts/update-quartz-scheduler-dynamic/</link>
      <pubDate>Tue, 09 Jan 2018 22:10:30 +0800</pubDate>
      
      <guid>https://lucumt.info/posts/update-quartz-scheduler-dynamic/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://www.quartz-scheduler.org/&#34;&gt;Quartz&lt;/a&gt;&lt;/strong&gt;是软件开发中常用的任务调度框架，实际中通常结合 &lt;strong&gt;&lt;a href=&#34;https://spring.io/&#34;&gt;Spring&lt;/a&gt;&lt;/strong&gt; 一起使用，并在 &lt;em&gt;Spring&lt;/em&gt; 的配置文件中利用 &lt;em&gt;0 0 12 ? * WED&lt;/em&gt; 这种方式以硬编码的方式配置定时任务的执行时间。有时候需要动态的设置定时任务的执行时间，如让用户自己选择何时备份数据，此时就需要采用动态设置其执行时间。&lt;/p&gt;

&lt;p&gt;为实现动态设置定时任务执行时间的功能，首先需要实现以硬编码的方式设置定时任务执行时间，然后在其基础上修改为可动态设置，本文基于这两分部分逐步介绍如何实现。&lt;/p&gt;

&lt;h2 id=&#34;硬编码设置定时时间:ee29255b0280dc2ee86b959313ce9c99&#34;&gt;硬编码设置定时时间&lt;/h2&gt;

&lt;p&gt;本文采用 &lt;em&gt;Quartz + &lt;strong&gt;&lt;a href=&#34;https://spring.io/guides/gs/serving-web-content/&#34;&gt;SpringMVC&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt; 的实现框架，同时基于 &lt;strong&gt;&lt;a href=&#34;https://maven.apache.org/&#34;&gt;Maven&lt;/a&gt;&lt;/strong&gt;运行，相关配置过程如下：&lt;br /&gt;
1.首先在 &lt;em&gt;POM&lt;/em&gt; 文件中引入相应的依赖JAR包。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;
	&amp;lt;dependency&amp;gt;
		&amp;lt;groupId&amp;gt;org.quartz-scheduler&amp;lt;/groupId&amp;gt;
		&amp;lt;artifactId&amp;gt;quartz&amp;lt;/artifactId&amp;gt;
		&amp;lt;version&amp;gt;2.3.0&amp;lt;/version&amp;gt;
	&amp;lt;/dependency&amp;gt;
	&amp;lt;dependency&amp;gt;
		&amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
		&amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
		&amp;lt;version&amp;gt;1.7.25&amp;lt;/version&amp;gt;
	&amp;lt;/dependency&amp;gt;
	&amp;lt;dependency&amp;gt;
		&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
		&amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
		&amp;lt;version&amp;gt;4.3.13.RELEASE&amp;lt;/version&amp;gt;
	&amp;lt;/dependency&amp;gt;
	&amp;lt;dependency&amp;gt;
		&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
		&amp;lt;artifactId&amp;gt;spring-context-support&amp;lt;/artifactId&amp;gt;
		&amp;lt;version&amp;gt;4.3.13.RELEASE&amp;lt;/version&amp;gt;
	&amp;lt;/dependency&amp;gt;
	&amp;lt;dependency&amp;gt;
		&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
		&amp;lt;artifactId&amp;gt;spring-web&amp;lt;/artifactId&amp;gt;
		&amp;lt;version&amp;gt;4.3.13.RELEASE&amp;lt;/version&amp;gt;
	&amp;lt;/dependency&amp;gt;
	&amp;lt;dependency&amp;gt;
		&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
		&amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
		&amp;lt;version&amp;gt;4.3.13.RELEASE&amp;lt;/version&amp;gt;
	&amp;lt;/dependency&amp;gt;
	&amp;lt;dependency&amp;gt;
		&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
		&amp;lt;artifactId&amp;gt;spring-tx&amp;lt;/artifactId&amp;gt;
		&amp;lt;version&amp;gt;4.3.13.RELEASE&amp;lt;/version&amp;gt;
	&amp;lt;/dependency&amp;gt;
	&amp;lt;dependency&amp;gt;
		&amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
		&amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
		&amp;lt;version&amp;gt;4.9&amp;lt;/version&amp;gt;
		&amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
	&amp;lt;/dependency&amp;gt;
	&amp;lt;dependency&amp;gt;
		&amp;lt;groupId&amp;gt;javaee&amp;lt;/groupId&amp;gt;
		&amp;lt;artifactId&amp;gt;javaee-api&amp;lt;/artifactId&amp;gt;
		&amp;lt;version&amp;gt;5&amp;lt;/version&amp;gt;
		&amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
	&amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.创建一个定时任务测试类 &lt;em&gt;TestJob&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestJob {

	private DateFormat df = new SimpleDateFormat(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;);  

	public void schedulerJob(){
		System.out.println(&amp;quot;=========定时输出:\t&amp;quot;+df.format(new Date()));
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.结合 &lt;em&gt;Spring&lt;/em&gt; 进行定时任务的配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot; 
	xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans-4.3.xsd &amp;quot;&amp;gt;

	&amp;lt;bean id=&amp;quot;testJob&amp;quot; class=&amp;quot;com.lucumt.quartz.TestJob&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;
	&amp;lt;bean id=&amp;quot;testJobDetail&amp;quot; class=&amp;quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&amp;quot;&amp;gt;
		&amp;lt;!-- 指定任务类 --&amp;gt;
		&amp;lt;property name=&amp;quot;targetObject&amp;quot; ref=&amp;quot;testJob&amp;quot; /&amp;gt;
		&amp;lt;!-- 指定任务执行的方法 --&amp;gt;
		&amp;lt;property name=&amp;quot;targetMethod&amp;quot; value=&amp;quot;schedulerJob&amp;quot; /&amp;gt;
	&amp;lt;/bean&amp;gt;
	&amp;lt;bean id=&amp;quot;testJobTrigger&amp;quot;
		class=&amp;quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&amp;quot;&amp;gt;
		&amp;lt;property name=&amp;quot;jobDetail&amp;quot; ref=&amp;quot;testJobDetail&amp;quot; /&amp;gt;
		&amp;lt;!-- 每10秒运行一次 --&amp;gt;
		&amp;lt;property name=&amp;quot;cronExpression&amp;quot; value=&amp;quot;0/10 * * * * ?&amp;quot; /&amp;gt;
	&amp;lt;/bean&amp;gt;

	&amp;lt;bean class=&amp;quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&amp;quot;&amp;gt;
		&amp;lt;property name=&amp;quot;triggers&amp;quot;&amp;gt;
			&amp;lt;list&amp;gt;
				&amp;lt;ref bean=&amp;quot;testJobTrigger&amp;quot; /&amp;gt;
			&amp;lt;/list&amp;gt;
		&amp;lt;/property&amp;gt;
	&amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.&lt;em&gt;web.xml&lt;/em&gt; 中配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;web-app version=&amp;quot;2.5&amp;quot; xmlns=&amp;quot;http://java.sun.com/xml/ns/javaee&amp;quot;
	xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
	xsi:schemaLocation=&amp;quot;http://java.sun.com/xml/ns/javaee  http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&amp;quot;&amp;gt;
	&amp;lt;display-name&amp;gt;Dynamic Quartz Scheduler&amp;lt;/display-name&amp;gt;
	&amp;lt;listener&amp;gt;
		&amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-class&amp;gt;
	&amp;lt;/listener&amp;gt;
	&amp;lt;context-param&amp;gt;
		&amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
		&amp;lt;param-value&amp;gt;classpath*:spring-context-*.xml&amp;lt;/param-value&amp;gt;
	&amp;lt;/context-param&amp;gt;

&amp;lt;/web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
配置完成后，在 &lt;em&gt;eclipse&lt;/em&gt; 中运行&lt;code&gt;tomcat7:run&lt;/code&gt;运行结果如下，可以看出定时任务每隔10秒执行一次。&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/update-quartz-scheduler-dynamic/static_scheduler_output.png&#34; alt=&#34;&amp;quot;未修改之前的定时任务输出&amp;quot;&#34; title=&#34;未修改之前的定时任务输出&#34; /&gt;
&lt;br /&gt;
上述的硬编码设置将 &lt;em&gt;Quartz&lt;/em&gt; 的执行时间通过硬编码方式写入XML配置文件中，这是最常见的用法，但通过XML配置文件写入定时时间时无法动态的更改其执行时间。&lt;/p&gt;

&lt;h2 id=&#34;动态设置定时时间:ee29255b0280dc2ee86b959313ce9c99&#34;&gt;动态设置定时时间&lt;/h2&gt;

&lt;p&gt;为了便于演示，本文采用Web程序的方式展示相关操作过程。&lt;br /&gt;
1.增加一个 &lt;em&gt;testScheduler.jsp&lt;/em&gt; 展示操作界面:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;%@ page language=&amp;quot;java&amp;quot; import=&amp;quot;java.util.*&amp;quot; pageEncoding=&amp;quot;UTF-8&amp;quot;%&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
	&amp;lt;meta http-equiv=&amp;quot;content-type&amp;quot; content=&amp;quot;text/html; charset=UTF-8&amp;quot;&amp;gt;
	&amp;lt;title&amp;gt;动态设置quartz&amp;lt;/title&amp;gt;
	&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;js/jquery-2.1.1.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
	&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; href=&amp;quot;js/bootstrap/css/bootstrap.min.css&amp;quot;/&amp;gt;
	&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;js/bootstrap/js/bootstrap.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
	&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
	  .container{
	     margin-top: 30px;
	     margin-left: auto;
	     margin-right: auto;
	     padding: 10px;
	     background-color: #d0d0d0;
	     border-radius: 5px;
	     min-height:400px;
	  }
	  
	  .hidden{
	     display: none;
	  }
	&amp;lt;/style&amp;gt;
	&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
	  function changeScheduler(){
		  var hiddenId = $(&amp;quot;.hidden&amp;quot;).attr(&amp;quot;id&amp;quot;);
		  var expression = null;
		  if(hiddenId==&amp;quot;scheduler_one&amp;quot;){
			  $(&amp;quot;#scheduler_one&amp;quot;).removeClass(&amp;quot;hidden&amp;quot;);
			  $(&amp;quot;#scheduler_two&amp;quot;).addClass(&amp;quot;hidden&amp;quot;);
			  expression=&amp;quot;0/10 * * * * ?&amp;quot;;
		  }else{
			  $(&amp;quot;#scheduler_one&amp;quot;).addClass(&amp;quot;hidden&amp;quot;);
			  $(&amp;quot;#scheduler_two&amp;quot;).removeClass(&amp;quot;hidden&amp;quot;);
			  expression=&amp;quot;0/30 * * * * ?&amp;quot;;
		  }
		  sendChangeRequest(expression);
	  }
	  
	  function sendChangeRequest(expression){
		  $.ajax({
			  url:&amp;quot;changeScheduler&amp;quot;,
			  type:&amp;quot;post&amp;quot;,
			  data:{
				  expression:expression
			  },
			  success:function(){
			  }
		  });
	  }
	&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div class=&amp;quot;container-fluid container&amp;quot;&amp;gt;
     &amp;lt;div id=&amp;quot;scheduler_one&amp;quot;&amp;gt;
                      当前定时任务的表达式为&amp;lt;b&amp;gt;0/10 * * * * ?&amp;lt;/b&amp;gt;,每隔10秒输出一次
     &amp;lt;/div&amp;gt;
     &amp;lt;div id=&amp;quot;scheduler_two&amp;quot; class=&amp;quot;hidden&amp;quot;&amp;gt;
                      当前定时任务的表达式为&amp;lt;b&amp;gt;0/30 * * * * ?&amp;lt;/b&amp;gt;,每隔30秒输出一次
     &amp;lt;/div&amp;gt;
     &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-primary btn-sm&amp;quot; onclick=&amp;quot;changeScheduler()&amp;quot;&amp;gt;切换定时时间&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.增加一个Controller类 &lt;em&gt;QuartzController&lt;/em&gt; 用于响应前端重新设置定时任务时间的请求&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller(&amp;quot;/&amp;quot;)
public class QuartzController {
	
	@Autowired
	private JobScheduler jobScheduler;

	@RequestMapping(&amp;quot;testScheduler&amp;quot;)
	public String testScheduler(){
		return &amp;quot;testScheduler&amp;quot;;
	}
	
	@RequestMapping(&amp;quot;changeScheduler&amp;quot;)
	@ResponseBody
	public String changeScheduler(String expression){
		System.out.println(&amp;quot;执行时间被修改为:\t&amp;quot;+expression);
		jobScheduler.resetJob(expression);
		return &amp;quot;SUCCESS&amp;quot;;
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.在时任务测试类 &lt;em&gt;TestJob&lt;/em&gt; 中添加一个 &lt;em&gt;resetJob&lt;/em&gt; 方法，用于重新设置定时任务执行时间&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class JobScheduler implements ServletContextAware {

	private DateFormat df = new SimpleDateFormat(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;);
	
	private ServletContext context;
	
	@Override
	public void setServletContext(ServletContext context) {
       this.context=context;		
	}

	public void schedulerJob() {
		System.out.println(&amp;quot;=========定时输出:\t&amp;quot; + df.format(new Date())); 
	}
	
    //通过此方法重新设置定时任务调度时间
	public void resetJob(String expression){
		ApplicationContext applicationContext = WebApplicationContextUtils.getRequiredWebApplicationContext(context);
		Scheduler scheduler = (Scheduler) applicationContext.getBean(&amp;quot;testScheduler&amp;quot;);
		CronTriggerImpl trigger = null;
		try {
			TriggerKey triggerKeys = TriggerKey.triggerKey(&amp;quot;testJobTrigger&amp;quot;,Scheduler.DEFAULT_GROUP);
			trigger = new CronTriggerImpl();
			trigger.setCronExpression(expression);
			trigger.setKey(triggerKeys);//要确保key相同
			scheduler.rescheduleJob(triggerKeys,trigger);
		} catch (ParseException | SchedulerException e) {
			e.printStackTrace();
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.其他配置文件保持不变，修改后的运行界面如下&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/update-quartz-scheduler-dynamic/dynamic_scheduler_button.png&#34; alt=&#34;&amp;quot;修改定时任务的操作界面&amp;quot;&#34; title=&#34;修改定时任务的操作界面&#34; /&gt;
&lt;br /&gt;
5.多次点击该按钮，控制台输出如下，可以看出实现了动态设置定时任务的功能&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/update-quartz-scheduler-dynamic/dynamic_scheduler_output.png&#34; alt=&#34;&amp;quot;动态修改定时任务后的运行效果&amp;quot;&#34; title=&#34;动态修改定时任务后的运行效果&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;上述代码是基于 &lt;em&gt;Quartz2.3.0&lt;/em&gt; 来实现的，相关源代码请参见 &lt;strong&gt;&lt;a href=&#34;https://github.com/lucumt/myrepository/tree/master/java/quartz_demo&#34;&gt;quartz_demo&lt;/a&gt;&lt;/strong&gt; ，其核心在于 &lt;em&gt;resetJob&lt;/em&gt; 方法通过调用 &lt;strong&gt;&lt;a href=&#34;https://github.com/quartz-scheduler/quartz/blob/master/quartz-core/src/main/java/org/quartz/impl/triggers/CronTriggerImpl.java&#34;&gt;CronTriggerImpl&lt;/a&gt;&lt;/strong&gt; 来重新设置定时任务执行时间，需要注意的是要确保定时任务修改前后的 &lt;em&gt;triggerKey&lt;/em&gt; 一致，这样才能修改生效，否则应用程序会在执行原有的定时任务时同时以新的时间来执行新的定时任务，即同时执行两个定时任务，达不到预期效果。&lt;/p&gt;

&lt;h2 id=&#34;quartz1-7-2中的定时任务设置:ee29255b0280dc2ee86b959313ce9c99&#34;&gt;Quartz1.7.2中的定时任务设置&lt;/h2&gt;

&lt;p&gt;在旧版的 &lt;em&gt;Quartz(1.7.2)&lt;/em&gt; 中 &lt;em&gt;rescheduleJob&lt;/em&gt; 的方法参数发生了变化，相应的 &lt;em&gt;Spring&lt;/em&gt; 版本也发生了变化，需要用 &lt;strong&gt;&lt;a href=&#34;https://docs.spring.io/spring/docs/3.0.x/javadoc-api/org/springframework/scheduling/quartz/CronTriggerBean.html&#34;&gt;CronTriggerBean&lt;/a&gt;&lt;/strong&gt; 替换 *CronTriggerImpl*，对应的实现代码可修改为如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void resetJob(String expression){
	ApplicationContext applicationContext = WebApplicationContextUtils.getRequiredWebApplicationContext(context);
	Scheduler scheduler = (Scheduler) applicationContext.getBean(&amp;quot;testScheduler&amp;quot;);
	try {
		CronTriggerBean trigger = new CronTriggerBean();
		trigger.setCronExpression(expression);
		trigger.setName(&amp;quot;testJobTrigger&amp;quot;);
		trigger.setGroup(Scheduler.DEFAULT_GROUP);
		trigger.setJobName(&amp;quot;testJobDetail&amp;quot;);
		scheduler.rescheduleJob(&amp;quot;testJobTrigger&amp;quot;, Scheduler.DEFAULT_GROUP, trigger);
	} catch (SchedulerException | ParseException e) {
		e.printStackTrace();
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其运行结果和前面的一致。&lt;/p&gt;

&lt;h2 id=&#34;通过spring获取trigger导致的重复执行问题:ee29255b0280dc2ee86b959313ce9c99&#34;&gt;通过Spring获取Trigger导致的重复执行问题&lt;/h2&gt;

&lt;p&gt;将上述代码中的 &lt;em&gt;CronTriggerBean&lt;/em&gt; 初始化从 &lt;em&gt;new&lt;/em&gt; 关键字实现变为通过 &lt;em&gt;Schduler&lt;/em&gt; 获取原有的任务后重新更新，修改后的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void resetJob(String expression){
    ApplicationContext applicationContext = WebApplicationContextUtils.getRequiredWebApplicationContext(context);
    Scheduler scheduler = (Scheduler) applicationContext.getBean(&amp;quot;testScheduler&amp;quot;);
    try {
        CronTriggerBean trigger = (CronTriggerBean) scheduler.getTrigger(&amp;quot;testJobTrigger&amp;quot;, Scheduler.DEFAULT_GROUP);//通过scheduler获取
        trigger.setCronExpression(expression);
        trigger.setName(&amp;quot;testJobTrigger&amp;quot;);
        scheduler.rescheduleJob(&amp;quot;testJobTrigger&amp;quot;, Scheduler.DEFAULT_GROUP, trigger);
    } catch (SchedulerException | ParseException e) {
        e.printStackTrace();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际运行时会发现每次动态切换 &lt;em&gt;Quartz&lt;/em&gt; 的执行时间时都会导致该定时任务被执行两次或错误执行的现象，如下图所示：&lt;br /&gt;
&lt;img src=&#34;https://lucumt.info/blog_img/update-quartz-scheduler-dynamic/dynamic_scheduler_output_wrong.png&#34; alt=&#34;&amp;quot;动态修改定时任务后定时任务错误执行&amp;quot;&#34; title=&#34;动态修改定时任务后定时任务错误执行&#34; /&gt;
&lt;br /&gt;
初步上述问题产生的原因为通过 &lt;em&gt;Scheduler&lt;/em&gt; 获取的是已有的 &lt;em&gt;Trigger&lt;/em&gt; 而导致重复执行（不论 &lt;em&gt;Quartz&lt;/em&gt; 新旧版本均有此问题 ），如果采用 &lt;em&gt;new&lt;/em&gt; 关键字重新创建一个 &lt;em&gt;Trigger&lt;/em&gt; 则此问题会消失，至于为何采用旧的 &lt;em&gt;Trigger&lt;/em&gt; 会导致定时任务错误执行，还有待进一步分析。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>利用SpringMVC下载大文件时内存溢出的处理</title>
      <link>https://lucumt.info/posts/download-big-file-using-springmvc/</link>
      <pubDate>Sun, 20 Mar 2016 16:41:29 +0800</pubDate>
      
      <guid>https://lucumt.info/posts/download-big-file-using-springmvc/</guid>
      <description>&lt;p&gt;文件的上传和下载是Web系统中的一个很普通的功能，实现的方式也有很多种，如利用 &lt;strong&gt;&lt;a href=&#34;https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html&#34;&gt;java.io&lt;/a&gt;&lt;/strong&gt; 下面的各种IO类自己实现，或者利用 &lt;strong&gt;&lt;a href=&#34;https://commons.apache.org/proper/commons-io/&#34;&gt;Commons IO&lt;/a&gt;&lt;/strong&gt; 包中的 &lt;strong&gt;&lt;em&gt;FileUtils&lt;/em&gt;&lt;/strong&gt; 、 &lt;strong&gt;&lt;em&gt;IOUtils&lt;/em&gt;&lt;/strong&gt; 类中封装好的方法直接调用。由于目前我所开发的系统采用了 &lt;strong&gt;&lt;a href=&#34;http://docs.spring.io/autorepo/docs/spring/3.2.x/spring-framework-reference/html/mvc.html&#34;&gt;SpringMVC&lt;/a&gt;&lt;/strong&gt; 来作为项目的MVC实现，所以很自然的采用 &lt;strong&gt;&lt;a href=&#34;http://docs.spring.io/autorepo/docs/spring/3.2.x/spring-framework-reference/html/mvc.html&#34;&gt;SpringMVC&lt;/a&gt;&lt;/strong&gt;内置的API进行文件的下载，但在实际使用过程中发现其对大文件的下载支持不太好，现把解决方案记录如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;downloadRequireDocument&amp;quot;)
public ResponseEntity&amp;lt;byte[]&amp;gt; downloadRequireDocument(String fileId,String fileName,String fileType,
     HttpServletRequest request) throws IOException{
	String filePath=fileName+fileId+&amp;quot;.&amp;quot;+fileType;
    
	HttpHeaders headers=new HttpHeaders();
	headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
	headers.setContentDispositionFormData(&amp;quot;attachment&amp;quot;,URLEncoder.encode(fileName,&amp;quot;UTF-8&amp;quot;)+&amp;quot;.&amp;quot;+fileType);
    
	File downloadFile=new File(request.getSession().getServletContext().getRealPath(File.separator)+filePath);
    
	return new ResponseEntity&amp;lt;byte[]&amp;gt;(FileUtils.readFileToByteArray(downloadFile),headers,HttpStatus.CREATED);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该段代码在下载小文件时可以正常工作，但是当要下载的文件很大时（如几百M或上G），就会发生如下错误：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;java.lang.OutOfMemoryError: Java heap space
at org.apache.commons.io.output.ByteArrayOutputStream.toByteArray(ByteArrayOutputStream.java:271)
at org.apache.commons.io.IOUtils.toByteArray(IOUtils.java:219)
at org.apache.commons.io.FileUtils.readFileToByteArray(FileUtils.java:1136)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;去网上搜索 &lt;strong&gt;&lt;em&gt;java.lang.OutOfMemoryError: Java heap space&lt;/em&gt;&lt;/strong&gt; 这个错误时，一般都建议我们在tomcat中添加如下类似设置来提高JVM的配置:&lt;br /&gt;
&lt;code&gt;set JAVA_OPTS=%JAVA_OPTS% -server -Xms800m -Xmx800m -XX:MaxNewSize=256m -XX:MaxPermSize=256m&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;但即使按照把上面的参数配置都扩大一倍，在下载更大的文件时还是会遇到 &lt;strong&gt;&lt;em&gt;java.lang.OutOfMemoryError: Java heap space&lt;/em&gt;&lt;/strong&gt; 这个错误，上面的解决方法治标不治本。分析下异常堆栈可以发现问题产生的根源在于 &lt;em&gt;at org.apache.commons.io.FileUtils.readFileToByteArray(FileUtils.java:1136)&lt;/em&gt; 这行代码，&lt;strong&gt;&lt;em&gt;FileUtils.readFileToByteArray&lt;/em&gt;&lt;/strong&gt;  会把文件一次性读入内存中，要下载的文件越大，需要占用的内存也越大，当文件的大小超过JVM和Tomcat的内存配置时，&lt;strong&gt;&lt;em&gt;OutOfMemoryError&lt;/em&gt;&lt;/strong&gt; 这个问题就会不可避免的发生。&lt;/p&gt;

&lt;p&gt;弄清产生该问题的原因之后，解决的方法也很简单：&lt;strong&gt;不利用&lt;a href=&#34;https://commons.apache.org/proper/commons-io/&#34;&gt;Commons IO&lt;/a&gt;把文件一次性读入内存，而是利用普通的文件输出流按字节分段写入文件，把占用的内存固定在一个指定的范围内，从根本上避免内存占用过高的问题&lt;/strong&gt;,替代的代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;downloadRequireDocument&amp;quot;)
public void downloadRequireDocument(String fileId,String fileName,String fileType,
	HttpServletRequest request,HttpServletResponse response) throws IOException {
	
	String filePath = request.getSession().getServletContext().getRealPath(File.separator)+fileName+&amp;quot;.&amp;quot;+fileType;
	fileName = URLEncoder.encode(fileName.trim(),&amp;quot;UTF-8&amp;quot;)+&amp;quot;.&amp;quot;+fileType;
	response.setHeader(&amp;quot;Content-Disposition&amp;quot;,&amp;quot;attachment;filename=&amp;quot;+fileName);

	InputStream is = new FileInputStream(filePath);
	
	int read =0;
	byte[] bytes = new byte[2048];
	OutputStream os = response.getOutputStream();
	while((read = is.read(bytes))!=-1){//按字节逐个写入，避免内存占用过高
		os.write(bytes, 0, read);
	}
	os.flush();
	os.close();
	is.close();
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>利用Spring Security动态的改变权限</title>
      <link>https://lucumt.info/posts/update-authority-dynamic-using-spring-security/</link>
      <pubDate>Sun, 20 Mar 2016 16:05:52 +0800</pubDate>
      
      <guid>https://lucumt.info/posts/update-authority-dynamic-using-spring-security/</guid>
      <description>&lt;p&gt;利用 &lt;strong&gt;&lt;a href=&#34;http://projects.spring.io/spring-security/&#34;&gt;Spring Security&lt;/a&gt;&lt;/strong&gt; 来管理我们的web程序时，通常需要在&lt;strong&gt;&lt;em&gt;UserDetailsService&lt;/em&gt;&lt;/strong&gt; 接口中的 &lt;strong&gt;&lt;em&gt;loadUserByUsername&lt;/em&gt;&lt;/strong&gt; 方法中来初始化权限信息,但 &lt;strong&gt;&lt;em&gt;UserDetailsService&lt;/em&gt;&lt;/strong&gt; 一般用于登录验证，这也意味着用户的权限在登录过程中就会被计算出来。通常情况下由于用户的权限很少发生变化，在登录过程中计算出用户权限是合理的，但有些情况下，我们需要在中途来动态的改变用户的权限，此时我们可以利用 &lt;strong&gt;&lt;a href=&#34;http://projects.spring.io/spring-security/&#34;&gt;Spring Security&lt;/a&gt;&lt;/strong&gt; 提供的API来实现。&lt;/p&gt;

&lt;p&gt;以我自己的项目为例，&lt;strong&gt;&lt;em&gt;UserDetailsService&lt;/em&gt;&lt;/strong&gt; 接口中的 &lt;strong&gt;&lt;em&gt;loadUserByUsername&lt;/em&gt;&lt;/strong&gt; 具体实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
       
	UserModel userModel=userDao.getUserByUsername(username);
       
	if(userModel==null){
		throw new UsernameNotFoundException(username+&amp;quot; not exist!&amp;quot;);
	}
	
	List&amp;lt;GrantedAuthority&amp;gt; userAuthList=new ArrayList&amp;lt;GrantedAuthority&amp;gt;();
    
	//查询出用户相关的所有权限并放入List中
	List&amp;lt;AuthorityVO&amp;gt; authList=authorityDao.queryAuthorityByUserId(userModel.getId());
	for(AuthorityVO authVO:authList){
		userAuthList.add(new SimpleGrantedAuthority(authVO.getAuthName()));
	}

	//将查询出来的权限赋予用户
	UserDetails userDetails=new User(userModel.getUsername(),userModel.getPassword(),true,true,true,true,userAuthList);
	
	return userDetails;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码会一次性的把用户权限查询出来然后放入特定的 &lt;strong&gt;session&lt;/strong&gt; 中，但是 &lt;strong&gt;&lt;em&gt;UserDetailService&lt;/em&gt;&lt;/strong&gt; 方法一般只在用户登录web系统成功时才会被调用一次，使用范围较为局限，有时候我们需要在用户使用的过程中动态的改变用户的权限（譬如在我自己的项目中，当用户选中不同的项目之后，不同的项目对应不同的权限）。利用 &lt;strong&gt;&lt;a href=&#34;http://projects.spring.io/spring-security/&#34;&gt;Spring Security&lt;/a&gt;&lt;/strong&gt; 来管理权限信息时，用户的权限本质上是存储在一个 &lt;strong&gt;session&lt;/strong&gt; 中，只不过被&lt;strong&gt;&lt;a href=&#34;http://projects.spring.io/spring-security/&#34;&gt;Spring Security&lt;/a&gt;&lt;/strong&gt;进行了进一步的封装而已。所以若想动态的改变用户的权限，我们只需要将用户的信息重新存储到 &lt;strong&gt;session&lt;/strong&gt; 中即可，具体代码如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;GrantedAuthority&amp;gt; authList=new ArrayList&amp;lt;GrantedAuthority&amp;gt;();//用于存储修改之后的权限列表
authList.add(new SimpleGrantedAuthority(&amp;quot;addUser&amp;quot;));
authList.add(new SimpleGrantedAuthority(&amp;quot;editUser&amp;quot;));

SecurityContext context=SecurityContextHolder.getContext();

UserDetails userDetails=(UserDetails) context.getAuthentication().getPrincipal();
Authentication auth=new UsernamePasswordAuthenticationToken(userDetails,userDetails.getPassword(),authList);

context.setAuthentication(auth); //重新设置上下文中存储的用户权限
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>在Spring中利用Mock对HttpServletRequest进行单元测试</title>
      <link>https://lucumt.info/posts/using-mock-test-http-servlet-request/</link>
      <pubDate>Sat, 19 Mar 2016 22:43:47 +0800</pubDate>
      
      <guid>https://lucumt.info/posts/using-mock-test-http-servlet-request/</guid>
      <description>

&lt;h2 id=&#34;编写单元测试时的注意事项:ce3acd839c9974eb09add799db7e87e2&#34;&gt;编写单元测试时的注意事项&lt;/h2&gt;

&lt;p&gt;根据软件开发过程中的&lt;strong&gt;&lt;em&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Test-driven_development&#34;&gt;TDD&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; 理论，在我们编写自己的代码时，要尽量使得该代码能够进行单元测试。为了能够使得代码可以进行单元测试，我们在给接口或方法传入参数时要尽量传入简单参数，避免传入 &lt;strong&gt;&lt;em&gt;HttpServletRequest&lt;/em&gt;&lt;/strong&gt; , &lt;strong&gt;&lt;em&gt;ServletContext&lt;/em&gt;&lt;/strong&gt; 等和web上下文相关的复杂对象。但仍有部分情况下基于代码简洁性和可维护性的考虑，我们需要传入 &lt;strong&gt;&lt;em&gt;HttpServletRequest&lt;/em&gt;&lt;/strong&gt; 对象，此时对此类方法进行&lt;strong&gt;&lt;a href=&#34;http://junit.org/&#34;&gt;JUnit&lt;/a&gt;&lt;/strong&gt;单元测试时会较为困难，本文介绍一种在&lt;strong&gt;&lt;a href=&#34;https://spring.io/&#34;&gt;Spring&lt;/a&gt;&lt;/strong&gt;中通过&lt;strong&gt;&lt;a href=&#34;http://mockito.org/&#34;&gt;Mock&lt;/a&gt;&lt;/strong&gt;来模拟&lt;strong&gt;&lt;em&gt;HttpServletRequest&lt;/em&gt;&lt;/strong&gt; 对象进行&lt;strong&gt;&lt;a href=&#34;http://junit.org/&#34;&gt;JUnit&lt;/a&gt;&lt;/strong&gt;单元测试的方法。&lt;/p&gt;

&lt;p&gt;假设在 &lt;strong&gt;&lt;em&gt;HttpServletRequest&lt;/em&gt;&lt;/strong&gt; 中有一个userId字符串对象，我们想在queryUserById方法中调用该参数来获取用户信息，则正确的做法应如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  String userId = request.getAttribute(&amp;quot;userId&amp;quot;).toString();//先获取userId对象
  queryUserById(userId);//然后将获取的userId传入对应方法

  public User queryUserById(String userId){//相关该方法
       User userModel = userDao.findById(userId);
       return userModel;
  }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请尽量避免使用第二种方式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  queryUserById(request);//直接传入request对象
  
  public User queryUserById(HttpServletRequest request){//相关方法
       String userId = request.getAttribute(&amp;quot;userId&amp;quot;).toString();//在该方法内部获取userId
 
       User userModel = userDao.findById(userId);
       return userModel;
  }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;若采用第一种方法，我么在进行单元测试时，可以很容易的自己制造一个String字符串来代表userId进行测试，但当采用第二种方法后，在进行单元测试时我们是比较难以模拟一个 &lt;strong&gt;HttpServletRequest&lt;/strong&gt; 对象，从而影响我们的测试。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;spring和mock在单元测试中的使用:ce3acd839c9974eb09add799db7e87e2&#34;&gt;Spring和Mock在单元测试中的使用&lt;/h2&gt;

&lt;p&gt;在某些方法中，为了减少代码量和提高程序的可读性，我们有时候需要直接传入 &lt;strong&gt;&lt;em&gt;HttpServletRequest&lt;/em&gt;&lt;/strong&gt; 或 &lt;strong&gt;&lt;em&gt;ServletContext&lt;/em&gt;&lt;/strong&gt; 对象，如果我们想对这种方法进行测试，可以利用&lt;strong&gt;&lt;a href=&#34;http://mockito.org/&#34;&gt;Mock&lt;/a&gt;&lt;/strong&gt;来模拟相关的对象。&lt;/p&gt;

&lt;p&gt;由于&lt;strong&gt;&lt;a href=&#34;https://spring.io/&#34;&gt;Spring&lt;/a&gt;&lt;/strong&gt;自身已经整合了&lt;strong&gt;&lt;a href=&#34;http://mockito.org/&#34;&gt;Mock&lt;/a&gt;&lt;/strong&gt;相关的类，故在此处展示一个示例代码，以供参考:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.File;
 
import org.junit.Test;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.mock.web.MockServletContext;
 
public class SpringMockTest {
 
@Test
public void testHttpServletRequest(){
	String realPath =&amp;quot;file:D:\\Java\\apache-tomcat-7.0.23\\webapps\\tmn&amp;quot;;
	//模拟ServletContext,同时初始化realPath，注意要有file:前缀否则会报错
	MockServletContext context = new MockServletContext(realPath);
	//获取realPath
	System.out.println(context.getRealPath(File.separator));
	//模拟HttpServletRequest
	MockHttpServletRequest request = new MockHttpServletRequest(context);
	//通过HttpServletRequest来获取realPath
	System.out.println(request.getSession().getServletContext().getRealPath(File.separator));
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意:请在上下文路径的字符串前面加上 &lt;strong&gt;file:&lt;/strong&gt; 前缀，否则程序会报错。如上面的程序，realPath的值应为 &lt;em&gt;file:D:\Java\apache-tomcat-7.0.23\webapps\tmn&lt;/em&gt; ，若去掉 &lt;em&gt;file:&lt;/em&gt; 前缀，改为 &lt;em&gt;D:\Java\apache-tomcat-7.0.23\webapps\tmn&lt;/em&gt; ，则程序会报错。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>